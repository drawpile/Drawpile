// SPDX-License-Identifier: GPL-3.0-or-later
// This file is auto-generated by configen.py, do not edit it manually.
#ifndef LIBCLIENT_CONFIG_CONFIG_H
#define LIBCLIENT_CONFIG_CONFIG_H
#include <QByteArray>
#include <QCoreApplication>
#include <QColor>
#include <QMap>
#include <QObject>
#include <QRect>
#include <QString>
#include <QStringList>
#include <QVariantHash>
#include <QVariantList>
#include <QVariantMap>
#include <QVector>
#ifdef Q_OS_ANDROID
#   include <QScreen>
#endif

#if !defined(NATIVE_DIALOGS_SETTING_AVAILABLE) && defined(Q_OS_WIN)
#	define NATIVE_DIALOGS_SETTING_AVAILABLE 1
#endif

// Call a setter member function when the setting changes.
#define CFG_BIND_SET(CFG, SETTING, SUBJECT, SETTER) \
	do { \
		::config::Config *_cfg = (CFG); \
		auto *_subject = (SUBJECT); \
		_subject->SETTER(_cfg->get##SETTING()); \
		::QObject::connect(_cfg, &::config::Config::change##SETTING, _subject, &SETTER); \
	} while(0)

// Like CFG_BIND_SET, but the setter is a lambda.
#define CFG_BIND_SET_FN(CFG, SETTING, SUBJECT, FN) \
	do { \
		::config::Config *_cfg = (CFG); \
		auto *_subject = (SUBJECT); \
		auto _fn = FN; \
		std::invoke(_fn, _cfg->get##SETTING()); \
		::QObject::connect(_cfg, &::config::Config::change##SETTING, _subject, std::move(_fn)); \
	} while(0)

// Like CFG_BIND_SET, but the "setter" takes no arguments.
#define CFG_BIND_NOTIFY(CFG, SETTING, SUBJECT, NOTIFIER) \
	do { \
		::config::Config *_cfg = (CFG); \
		auto *_subject = (SUBJECT); \
		_subject->NOTIFIER(); \
		::QObject::connect(_cfg, &::config::Config::change##SETTING, _subject, &NOTIFIER); \
	} while(0)

// Like CFG_BIND_SET_FN, but the "setter" takes no arguments.
#define CFG_BIND_NOTIFY_FN(CFG, SETTING, SUBJECT, FN) \
	do { \
		::config::Config *_cfg = (CFG); \
		auto *_subject = (SUBJECT); \
		auto _fn = FN; \
		std::invoke(_fn); \
		::QObject::connect(_cfg, &::config::Config::change##SETTING, _subject, std::move(_fn)); \
	} while(0)

// Synchronize and object with the configuration using the given setter to set
// the value in the object and the given signal to update the configuration.
#define CFG_BIND_OBJECT(CFG, SETTING, SUBJECT, SETTER, SIGNAL) \
	do { \
		::config::Config *_cfg = (CFG); \
		auto *_subject = (SUBJECT); \
		std::invoke(SETTER, _subject, _cfg->get##SETTING()); \
		::QObject::connect(_cfg, &::config::Config::change##SETTING, _subject, SETTER); \
		::QObject::connect(_subject, SIGNAL, _cfg, &::config::Config::set##SETTING); \
	} while(0)

// Like CFG_BIND_OBJECT, but the setter is a lambda.
#define CFG_BIND_OBJECT_FN(CFG, SETTING, SUBJECT, FN, SIGNAL) \
	do { \
		::config::Config *_cfg = (CFG); \
		auto *_subject = (SUBJECT); \
		auto _fn = FN; \
		std::invoke(_fn, _cfg->get##SETTING()); \
		::QObject::connect(_cfg, &::config::Config::change##SETTING, _subject, std::move(_fn)); \
		::QObject::connect(_subject, SIGNAL, _cfg, &::config::Config::set##SETTING); \
	} while(0)

#define CFG_BIND_ACTION(CFG, SETTING, SUBJECT) \
	CFG_BIND_OBJECT(CFG, SETTING, SUBJECT, &::QAction::setChecked, &::QAction::toggled)

#define CFG_BIND_BUTTONGROUP_TYPE(CFG, SETTING, SUBJECT, TYPE) \
	do { \
		::config::Config *_cfg = (CFG); \
		::QButtonGroup *_subject = (SUBJECT); \
		auto _setter = [_subject](TYPE _value) { \
			::QAbstractButton *_button = _subject->button(int(_value)); \
			if(_button) { \
				_button->setChecked(true); \
			} else { \
				qWarning() << "Bound invalid value" << _value << "to setting" << #SETTING << "on QButtonGroup" << #SUBJECT; \
			} \
		}; \
		std::invoke(_setter, _cfg->get##SETTING()); \
		::QObject::connect(_cfg, &::config::Config::change##SETTING, _subject, std::move(_setter)); \
		::QObject::connect(_subject, &QButtonGroup::idToggled, _cfg, [_cfg](int _id, bool _checked) { \
			if(_checked) { \
				_cfg->set##SETTING(TYPE(_id)); \
			} \
		}); \
	} while(0)

#define CFG_BIND_BUTTONGROUP(CFG, SETTING, SUBJECT) \
	CFG_BIND_BUTTONGROUP_TYPE(CFG, SETTING, SUBJECT, int)

#define CFG_BIND_CHECKBOX(CFG, SETTING, SUBJECT) \
	CFG_BIND_OBJECT(CFG, SETTING, SUBJECT, &::QCheckBox::setChecked, &::QCheckBox::toggled)

#define CFG_BIND_COMBOBOX_INDEX(CFG, SETTING, SUBJECT) \
	CFG_BIND_OBJECT(CFG, SETTING, SUBJECT, &::QComboBox::setCurrentIndex, ::QOverload<int>::of(&::QComboBox::currentIndexChanged))

#define CFG_BIND_COMBOBOX_VALUE_ROLE(CFG, SETTING, SUBJECT, TYPE_ARG, TO_TYPE, ROLE) \
	do { \
		::config::Config *_cfg = (CFG); \
		::QComboBox *_subject = (SUBJECT); \
		int _role = (ROLE); \
		auto _setter = [_subject, _role](TYPE_ARG _value) { \
			::QVariant _variant = ::QVariant::fromValue(_value); \
			int _index = _subject->findData(_variant, _role); \
			if(_index == -1) { \
				qWarning() << "Bound invalid value" << _variant << "to setting" << #SETTING << "on QComboBox" << #SUBJECT; \
			} else { \
				_subject->setCurrentIndex(_index); \
			} \
		}; \
		std::invoke(_setter, _cfg->get##SETTING()); \
		::QObject::connect(_cfg, &::config::Config::change##SETTING, _subject, std::move(_setter)); \
		::QObject::connect(_subject, QOverload<int>::of(&QComboBox::currentIndexChanged), _cfg, [_cfg, _subject, _role](int _index) { \
			_cfg->set##SETTING(_subject->itemData(_index, _role).TO_TYPE()); \
		}); \
	} while(0)

#define CFG_BIND_COMBOBOX_USER_INT(CFG, SETTING, SUBJECT) \
	CFG_BIND_COMBOBOX_VALUE_ROLE(CFG, SETTING, SUBJECT, int, toInt, Qt::UserRole)

#define CFG_BIND_COMBOBOX_USER_STRING(CFG, SETTING, SUBJECT) \
	CFG_BIND_COMBOBOX_VALUE_ROLE(CFG, SETTING, SUBJECT, const QString &, toString, Qt::UserRole)

#define CFG_BIND_DOUBLESPINBOX(CFG, SETTING, SUBJECT) \
	CFG_BIND_OBJECT(CFG, SETTING, SUBJECT, &::QDoubleSpinBox::setValue, ::QOverload<double>::of(&::QDoubleSpinBox::valueChanged))

#define CFG_BIND_LINEEDIT(CFG, SETTING, SUBJECT) \
	CFG_BIND_OBJECT(CFG, SETTING, SUBJECT, &::QLineEdit::setText, &::QLineEdit::textChanged)

#define CFG_BIND_PLAINTEXTEDIT(CFG, SETTING, SUBJECT) \
	do { \
		::config::Config *_cfg = (CFG); \
		::QPlainTextEdit *_subject = (SUBJECT); \
		_subject->setPlainText(_cfg->get##SETTING()); \
		::QObject::connect(_cfg, &::config::Config::change##SETTING, _subject, [_subject](const QString &_text) { \
			/* Setting the text moves the caret back to the beginning and purges the edit history, so we only set if necessary. */ \
			if(_subject->toPlainText() != _text) { \
				_subject->setPlainText(_text); \
			} \
		}); \
		::QObject::connect(_subject, &::QPlainTextEdit::textChanged, _cfg, [_cfg, _subject]{ \
			_cfg->set##SETTING(_subject->toPlainText()); \
		}); \
	} while(0)

#define CFG_BIND_SLIDERSPINBOX(CFG, SETTING, SUBJECT) \
	CFG_BIND_OBJECT(CFG, SETTING, SUBJECT, &::KisSliderSpinBox::setValue, ::QOverload<int>::of(&::KisSliderSpinBox::valueChanged))

#define CFG_BIND_SPINBOX(CFG, SETTING, SUBJECT) \
	CFG_BIND_OBJECT(CFG, SETTING, SUBJECT, &::QSpinBox::setValue, ::QOverload<int>::of(&::QSpinBox::valueChanged))

namespace config {

class Config : public QObject {
	Q_OBJECT
public:
	explicit Config(QObject *parent = nullptr);

	virtual QString path() const = 0;

	virtual bool submit() = 0;
	void trySubmit();

{% for setting in settings %}

{% if setting.condition %}
#if {{ setting.condition }}
{% endif %}
	virtual {{ setting.getter_signature() }} = 0;
	virtual {{ setting.setter_signature() }} = 0;
	static {{ setting.default_signature() }};
{% if setting.condition %}
#endif
{% endif %}
{% endfor %}

Q_SIGNALS:
{% for setting in settings %}
{% if setting.condition %}
#if {{ setting.condition }}
{% endif %}
	{{ setting.signal_signature() }};
{% if setting.condition %}
#endif
{% endif %}
{% endfor %}
};

}

#endif
