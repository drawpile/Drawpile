/*
 * Copyright (C) 2022 askmeaboutloom
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * --------------------------------------------------------------------
 *
 * This code is auto-generated by generators/protogen/protogen_drawdance.py
 * from generators/protogen/messages.c.jinja. Don't edit it directly.
 */
#include "messages.h"
#include "blend_mode.h"
#include "ids.h"
#include "message.h"
#include "text_reader.h"
#include "text_writer.h"
#include <dpcommon/binary.h>
#include <dpcommon/common.h>
#include <dpcommon/conversions.h>
#include <dpcommon/endianness.h>


bool DP_message_type_control(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        {% if message.message_type == "Control" %}
        case {{ message.enum_name }}:
        {% endif %}
    {% endfor %}
        return true;
    default:
        return false;
    }
}

bool DP_message_type_server_meta(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        {% if message.message_type == "ServerMeta" %}
        case {{ message.enum_name }}:
        {% endif %}
    {% endfor %}
        return true;
    default:
        return false;
    }
}

bool DP_message_type_client_meta(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        {% if message.message_type == "ClientMeta" %}
        case {{ message.enum_name }}:
        {% endif %}
    {% endfor %}
        return true;
    default:
        return false;
    }
}

bool DP_message_type_command(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        {% if message.message_type == "Command" %}
        case {{ message.enum_name }}:
        {% endif %}
    {% endfor %}
        return true;
    default:
        return false;
    }
}
{% if compat_version %}

bool DP_message_type_compatible(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        {% if not message.incompatible %}
        case {{ message.enum_name }}:
        {% endif %}
    {% endfor %}
        return true;
    default:
        return false;
    }
}
{% endif %}

const char *DP_message_type_name(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        case {{ message.enum_name }}:
            return "{{ message.cmd_name }}";
    {% endfor %}
    default:
        return "unknown";
    }
}

const char *DP_message_type_enum_name(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        case {{ message.enum_name }}:
            return "{{ message.enum_name }}";
    {% endfor %}
    default:
        return "DP_MSG_UNKNOWN";
    }
}

const char *DP_message_type_enum_name_unprefixed(DP_MessageType type)
{
    return DP_message_type_enum_name(type) + 7;
}

DP_MessageType DP_message_type_from_name(const char *type_name, DP_MessageType not_found_value)
{
    {% for message in messages %}
        {% if not message.reserved %}
            {% if not loop.first %}else {% endif %}if (DP_str_equal(type_name, "{{ message.cmd_name }}")) {
                return {{ message.enum_name }};
            }
        {% endif %}
    {% endfor %}
    else {
        return not_found_value;
    }
}


bool DP_message_dirties_canvas(DP_Message *msg)
{
    DP_ASSERT(msg);
    switch (DP_message_type(msg)) {
    {% set dirty_chain = namespace(n=0) %}
    {% for message in messages %}
        {% if message.dirties_canvas %}
            {% if message.dirties_canvas is string %}
                {% if dirty_chain.n != 0 %}
                    {% set dirty_chain.n = 0 %}
                    return true;
                {% endif %}
                case {{ message.enum_name }}:
                {{- message.dirties_canvas -}}
            {% else %}
                case {{ message.enum_name }}:
                {% set dirty_chain.n = dirty_chain.n + 1 %}
            {% endif %}
        {% endif %}
    {% endfor %}
    {% if dirty_chain.n != 0 %}
        return true;
    {% endif %}
    default:
        return false;
    }
}

DP_Message *DP_message_deserialize_body(int type, unsigned int context_id, const unsigned char *buf, size_t length, bool decode_opaque)
{
    if (type < DP_MESSAGE_TYPE_RANGE_START_CLIENT || decode_opaque) {
        switch (type) {
        {% for message in messages %}
            case {{ message.enum_name }}:
                {% if message.reserved %}
                    DP_error_set("Can't deserialize reserved message type {{ message.id }} {{ message.enum_name }}");
                    return NULL;
                {% else %}
                    return DP_{{ message.func_name }}_deserialize(context_id, buf, length);
                {% endif %}
        {% endfor %}
        default:
            DP_error_set("Can't deserialize unknown message type %d", type);
            return NULL;
        }
    }
    else {
        return DP_message_new_opaque((DP_MessageType)type, context_id, buf, length);
    }
}
{% if compat_version %}

DP_Message *DP_message_deserialize_body_compat(int type, unsigned int context_id, const unsigned char *buf, size_t length, bool decode_opaque)
{
    if (type < DP_MESSAGE_TYPE_RANGE_START_CLIENT || decode_opaque) {
        switch (type) {
        {% for message in messages %}
            case {{ message.enum_name }}:
                {% if message.reserved %}
                    DP_error_set("Can't deserialize reserved message type {{ message.id }} {{ message.enum_name }}");
                    return NULL;
                {% elif message.incompatible %}
                    DP_error_set("Can't deserialize incompatible message type {{ message.id }} {{ message.enum_name }}");
                    return NULL;
                {% else %}
                    return DP_{{ message.func_name }}_deserialize_compat(context_id, buf, length);
                {% endif %}
        {% endfor %}
        default:
            DP_error_set("Can't deserialize unknown message type %d", type);
            return NULL;
        }
    }
    else {
        return DP_message_new_opaque((DP_MessageType)type, context_id, buf, length);
    }
}
{% endif %}

DP_Message *DP_message_parse_body(DP_MessageType type, unsigned int context_id, DP_TextReader *reader)
{
    switch (type) {
    {% for message in messages %}
        case {{ message.enum_name }}:
            {% if message.reserved %}
                DP_error_set("Can't parse reserved message type {{ message.id }} {{ message.enum_name }}");
                return NULL;
            {% else %}
                return DP_{{ message.func_name }}_parse(context_id, reader);
            {% endif %}
    {% endfor %}
    default:
        DP_error_set("Can't parse unknown message type %d", type);
        return NULL;
    }
}


static size_t zero_length_payload_length(DP_UNUSED DP_Message *msg)
{
    return 0;
}

static size_t zero_length_serialize_payload(DP_UNUSED DP_Message *msg, DP_UNUSED unsigned char *data)
{
    return 0;
}

static bool zero_length_write_payload_text(DP_UNUSED DP_Message *msg, DP_UNUSED DP_TextWriter *writer)
{
    return true;
}

static bool zero_length_equals(DP_UNUSED DP_Message *DP_RESTRICT msg, DP_UNUSED DP_Message *DP_RESTRICT other)
{
    return true;
}

static const DP_MessageMethods zero_length_methods = {
    zero_length_payload_length,
    zero_length_serialize_payload,
    {% if compat_version %}
    zero_length_payload_length,
    zero_length_serialize_payload,
    {% endif %}
    zero_length_write_payload_text,
    zero_length_equals,
};


static void assign_string(char *dst, const char *src, size_t len)
{
    memcpy(dst, src, len);
    dst[len] = '\0';
}

static int8_t read_int8(const unsigned char *buffer, size_t *read)
{
    *read += 1;
    return DP_read_bigendian_int8(buffer);
}

static int32_t read_int32(const unsigned char *buffer, size_t *read)
{
    *read += 4;
    return DP_read_bigendian_int32(buffer);
}

static uint8_t read_uint8(const unsigned char *buffer, size_t *read)
{
    *read += 1;
    return DP_read_bigendian_uint8(buffer);
}

static uint16_t read_uint16(const unsigned char *buffer, size_t *read)
{
    *read += 2;
    return DP_read_bigendian_uint16(buffer);
}

static uint32_t read_uint24(const unsigned char *buffer, size_t *read)
{
    *read += 3;
    return DP_read_bigendian_uint24(buffer);
}

static uint32_t read_uint32(const unsigned char *buffer, size_t *read)
{
    *read += 4;
    return DP_read_bigendian_uint32(buffer);
}

static bool read_bool(const unsigned char *buffer, size_t *read)
{
    return read_uint8(buffer, read) != 0;
}

static const char *read_string_with_length(const unsigned char *buffer, size_t len, size_t *read)
{
    *read += len;
    return (const char *)buffer;
}

static void read_bytes(size_t count, unsigned char *out, void *user)
{
    const unsigned char *buffer = user;
    memcpy(out, buffer, count);
}

static void read_uint8_array(int count, uint8_t *out, void *user)
{
    const unsigned char *buffer = user;
    memcpy(out, buffer, DP_int_to_size(count));
}

static void read_uint16_array(int count, uint16_t *out, void *user)
{
    const unsigned char *buffer = user;
#if defined(DP_BYTE_ORDER_LITTLE_ENDIAN)
    for (int i = 0; i < count; ++i) {
        out[i] = DP_read_bigendian_uint16(buffer + i * 2);
    }
#elif defined(DP_BYTE_ORDER_BIG_ENDIAN)
    memcpy(out, buffer, DP_int_to_size(count) * 2);
#else
#   error "Unknown byte order"
#endif
}

static void read_uint32_array(int count, uint32_t *out, void *user)
{
    const unsigned char *buffer = user;
#if defined(DP_BYTE_ORDER_LITTLE_ENDIAN)
    for (int i = 0; i < count; ++i) {
        out[i] = DP_read_bigendian_uint32(buffer + i * 4);
    }
#elif defined(DP_BYTE_ORDER_BIG_ENDIAN)
    memcpy(out, buffer, DP_int_to_size(count) * 4);
#else
#   error "Unknown byte order"
#endif
}

static void read_int32_array(int count, int32_t *out, void *user)
{
    const unsigned char *buffer = user;
#if defined(DP_BYTE_ORDER_LITTLE_ENDIAN)
    for (int i = 0; i < count; ++i) {
        out[i] = DP_read_bigendian_int32(buffer + i * 4);
    }
#elif defined(DP_BYTE_ORDER_BIG_ENDIAN)
    memcpy(out, buffer, DP_int_to_size(count) * 4);
#else
#   error "Unknown byte order"
#endif
}

static size_t write_bytes(const unsigned char *DP_RESTRICT x, int count, unsigned char *DP_RESTRICT out)
{
    return DP_write_bytes(x, count, 1, out);
}

static size_t write_string_with_length(const char *DP_RESTRICT x, size_t len,
                                       unsigned char *DP_RESTRICT out)
{
    size_t written = DP_write_bigendian_uint8(DP_size_to_uint8(len), out);
    return written + DP_write_bytes(x, 1, len, out + written);
}

static const unsigned char *local_match_data(DP_Message *msg, size_t *out_size)
{
    switch (DP_message_type(msg)) {
    case DP_MSG_LOCAL_MATCH:
        return DP_msg_local_match_data(DP_message_internal(msg), out_size);
    case DP_MSG_PUT_IMAGE:
        return DP_msg_put_image_image(DP_message_internal(msg), out_size);
    default:
        DP_UNREACHABLE();
    }
}

static uint16_t serialize_layer_id_compat(uint32_t layer_id)
{
    return DP_uint32_to_uint16(((layer_id & (uint32_t)0xff00u) >> (uint32_t)8u)
                               | ((layer_id & (uint32_t)0xffu) << (uint32_t)8u));
}

static uint32_t deserialize_layer_id_compat(uint16_t layer_id)
{
    uint32_t u = DP_uint16_to_uint32(layer_id);
    return ((u & (uint32_t)0xffu) << (uint32_t)8u)
         | ((u & (uint32_t)0xff00u) >> (uint32_t)8u);
}

static uint16_t convert_other_id_compat(unsigned int id)
{
    return DP_uint_to_uint16(((id & 0xffu) << 8u) | ((id & 0xff00u) >> 8u));
}

static uint8_t get_draw_dabs_flags_compat(uint32_t color)
{
    if (color & (uint32_t)0xff000000u) {
        return (uint8_t)DP_PAINT_MODE_INDIRECT_SOFT;
    } else {
        return (uint8_t)DP_PAINT_MODE_DIRECT;
    }
}

static void read_track_ids_compat(int count, uint16_t *out, void *user)
{
    const unsigned char *buffer = user;
    for (int i = 0; i < count; ++i) {
        out[i] =
            convert_other_id_compat(DP_read_bigendian_uint16(buffer + i * 2));
    }
}

static size_t write_track_ids_compat(const uint16_t *DP_RESTRICT track_ids,
                                     int count, unsigned char *DP_RESTRICT out)
{
    if (count > 0) {
        size_t written = 0;
        for (int i = 0; i < count; ++i) {
            written += DP_write_bigendian_uint16(
                convert_other_id_compat(track_ids[i]), out + written);
        }
        return written;
    }
    else {
        return 0;
    }
}

static void read_key_frame_layer_flags_compat(int count, uint32_t *out,
                                              void *user)
{
    const unsigned char *buffer = user;
    for (int i = 0; i < count; ++i) {
        uint16_t layer_id = DP_read_bigendian_uint16(buffer + i * 4);
        uint16_t flags = DP_read_bigendian_uint16(buffer + i * 4 + 2);
        out[i] =
            deserialize_layer_id_compat(layer_id)
            | ((DP_uint16_to_uint32(flags) & (uint32_t)0xffu) << (uint32_t)24u);
    }
}

static size_t
write_key_frame_layer_flags_compat(const uint32_t *DP_RESTRICT id_flag_pairs,
                                   int count, unsigned char *DP_RESTRICT out)
{
    if (count > 0) {
        size_t written = 0;
        for (int i = 0; i < count; ++i) {
            written += DP_write_bigendian_uint16(
                serialize_layer_id_compat(id_flag_pairs[i]
                                          & (uint32_t)0xffffffu),
                out + written);
            written += DP_write_bigendian_uint16(
                DP_uint32_to_uint16((id_flag_pairs[i] & (uint32_t)0xff000000u)
                                    >> (uint32_t)24u),
                out + written);
        }
        return written;
    }
    else {
        return 0;
    }
}

{% for message in messages if not message.reserved %}

/* {{ message.enum_name }} */
    {% for f in message.fields %}
        {% if f.flags %}

            const char *DP_{{ message.func_name }}_{{ f.func_name }}_flag_name(unsigned int value)
            {
                switch (value) {
                {% for flag in f.flags %}
                case {{ flag.define_name }}:
                    return "{{ flag.name }}";
                {% endfor %}
                default:
                    return NULL;
                }
            }
        {% endif %}
        {% if f.variants %}

            const char *DP_{{ message.func_name }}_{{ f.func_name }}_variant_name(unsigned int value)
            {
                switch (value) {
                {% for variant in f.variants %}
                case {{ variant.define_name }}:
                    return "{{ variant.name }}";
                {% endfor %}
                default:
                    return NULL;
                }
            }
        {% endif %}
    {% endfor %}
    {% for f in message.fields %}
        {% if f.sub %}

            struct {{ f.sub.struct_name }} {
                {% for sf in f.sub.fields %}
                    {{ sf.struct_declaration }};
                {% endfor %}
            };

            static size_t {{ f.sub.func_name }}_serialize_payload({{ f.sub.param }}, unsigned char *data)
            {
                size_t written = 0;
                {% for sf in f.sub.fields %}
                    written += {{ sf.serialize_payload(f.sub.param_name, "data + written") }};
                {% endfor %}
                return written;
            }

            static size_t {{ f.sub.func_name }}_serialize_payloads({{ f.sub.param }}, int count, unsigned char *data)
            {
                size_t written = 0;
                for (int i = 0; i < count; ++i) {
                    written += {{ f.sub.func_name }}_serialize_payload(&{{ f.sub.param_name }}[i], data + written);
                }
                return written;
            }

            static bool {{ f.sub.func_name }}_write_payload_text({{ f.sub.param }}, DP_TextWriter *writer)
            {
                return DP_text_writer_start_subobject(writer) &&
                    {% for sf in f.sub.fields %}
                        {{ sf.write_subfield_payload_text(f.sub.param_name) }} &&
                    {% endfor %}
                    DP_text_writer_finish_subobject(writer);
            }

            static size_t {{ f.sub.func_name }}_write_payload_texts({{ f.sub.param }}, int count, DP_TextWriter *writer)
            {
                if (count != 0) {
                    if (!DP_text_writer_start_subs(writer)) {
                        return false;
                    }
                    for (int i = 0; i < count; ++i) {
                        if (!{{ f.sub.func_name }}_write_payload_text(&{{ f.sub.param_name }}[i], writer)) {
                            return false;
                        }
                    }
                    if (!DP_text_writer_finish_subs(writer)) {
                        return false;
                    }
                }
                return true;
            }

            static bool {{ f.sub.func_name }}_equals({{ f.sub.struct_name }} *DP_RESTRICT a, {{ f.sub.struct_name }} *DP_RESTRICT b)
            {
                return {% for sf in f.sub.fields %}
                        {{ sf.equals }}
                        {%- if not loop.last %} && {% endif -%}
                    {% endfor %};
            }

            static bool {{ f.sub.func_name }}s_equal({{ f.sub.struct_name }} *DP_RESTRICT a, {{ f.sub.struct_name }} *DP_RESTRICT b, int count)
            {
                for (int i = 0; i < count; ++i) {
                    if (!{{ f.sub.func_name }}_equals(&a[i], &b[i])) {
                        return false;
                    }
                }
                return true;
            }

            void DP_{{ f.sub.func_name }}_init({{ f.sub.param }}s, int i
                {%- for sf in f.sub.fields %}
                    , {{ sf.constructor_param }}
                {% endfor -%}
            )
            {
                DP_ASSERT({{ f.sub.param_name }}s);
                {{ f.sub.param }} = &{{ f.sub.param_name }}s[i];
                {% for sf in f.sub.fields %}
                    {{ sf.assign(f.sub.param_name) }};
                {% endfor %}
            }

            static void {{ f.sub.func_name }}_deserialize(int count, {{ f.sub.param }}s, void *user)
            {
                const unsigned char *buffer = user;
                size_t read = 0;
                for (int i = 0; i < count; ++i) {
                    {% for sf in f.sub.fields %}
                        {{ sf.deserialize_field }}
                    {% endfor %}
                    DP_{{ f.sub.func_name }}_init({{ f.sub.param_name }}s, i
                        {%- for sf in f.sub.fields %}
                            , {{ sf.deserialize_constructor_arg }}
                        {% endfor %});
                }
            }

            static void {{ f.sub.func_name }}_parse(int count, {{ f.sub.param }}s, void *user)
            {
                DP_TextReader *reader = user;
                for (int i = 0; i < count; ++i) {
                    {% for sf in f.sub.fields %}
                        {{ sf.parse_subfield(loop.index - 1) }}
                    {% endfor %}
                    DP_{{ f.sub.func_name }}_init({{ f.sub.param_name }}s, i
                        {%- for sf in f.sub.fields %}
                            , {{ sf.deserialize_constructor_arg }}
                        {% endfor %});
                }
            }
            {% for sf in f.sub.fields %}

                {{ sf.accessor_return_type }} DP_{{ f.sub.func_name }}_{{ sf.func_name }}(
                    const {{ f.sub.param }})
                {
                    DP_ASSERT({{ f.sub.param_name }});
                    return {{ sf.access(f.sub.param_name) }};
                }
            {% endfor %}

            const {{ f.sub.struct_name }} *DP_{{ f.sub.func_name }}_at(const {{ f.sub.param }}, int i)
            {
                DP_ASSERT({{ f.sub.param_name }});
                return &{{ f.sub.param_name }}[i];
            }
        {% endif %}
    {% endfor %}
    {% if compat_version and message.compat and not message.alias %}
        {% for f in message.compat.fields %}
            {% if f.sub %}

                static size_t {{ f.sub.func_name }}_serialize_payload_compat({{ f.sub.param }}, unsigned char *data)
                {
                    size_t written = 0;
                    {% for sf in f.sub.fields %}
                        written += {{ sf.serialize_payload_compat(f.sub.param_name, "data + written") }};
                    {% endfor %}
                    return written;
                }

                static size_t {{ f.sub.func_name }}_serialize_payloads_compat({{ f.sub.param }}, int count, unsigned char *data)
                {
                    size_t written = 0;
                    for (int i = 0; i < count; ++i) {
                        written += {{ f.sub.func_name }}_serialize_payload_compat(&{{ f.sub.param_name }}[i], data + written);
                    }
                    return written;
                }

                static void {{ f.sub.func_name }}_deserialize_compat(int count, {{ f.sub.param }}s, void *user)
                {
                    const unsigned char *buffer = user;
                    size_t read = 0;
                    for (int i = 0; i < count; ++i) {
                        {% for sf in f.sub.fields %}
                            {{ sf.deserialize_field }}
                        {% endfor %}
                        DP_{{ f.sub.func_name }}_init({{ f.sub.param_name }}s, i
                            {%- for sf in f.sub.fields %}
                                , {{ sf.deserialize_constructor_arg }}
                            {% endfor %});
                    }
                }
            {% endif %}
        {% endfor %}
    {% endif %}
    {% if message.fields %}

        struct {{ message.struct_name }} {
            {% for f in message.fields %}
                {{ f.struct_declaration }};
            {% endfor %}
            {% if message.array_field %}
                {{ message.array_declaration }};
            {% endif %}
        };

        {% set spl = message.static_payload_length %}
        {% set dpl = message.dynamic_payload_length %}
        static size_t {{ message.func_name }}_payload_length(
            {%- if not dpl %}DP_UNUSED {% endif -%}
            DP_Message *msg)
        {
            {% if dpl %}
                {{ message.param }} = DP_message_internal(msg);
            {% endif %}
            return {% if spl %}((size_t){{ spl }}){% endif -%}
                   {% if spl and dpl %} + {% endif -%}
                   {% if dpl %}{{ dpl }}{% endif %};
        }
        {% if compat_version and message.compat and message.compat.fields %}

        {% set splc = message.static_payload_length_compat %}
        {% set dplc = message.dynamic_payload_length_compat %}
        static size_t {{ message.func_name }}_payload_length_compat(
            {%- if not dplc %}DP_UNUSED {% endif -%}
            DP_Message *msg)
        {
            {% if dplc %}
                {{ message.param }} = DP_message_internal(msg);
            {% endif %}
            return {% if splc %}((size_t){{ splc }}){% endif -%}
                   {% if splc and dplc %} + {% endif -%}
                   {% if dplc %}{{ dplc }}{% endif %};
        }
        {% endif %}

        static size_t {{ message.func_name }}_serialize_payload(DP_Message *msg, unsigned char *data)
        {
            {{ message.param }} = DP_message_internal(msg);
            size_t written = 0;
            {% for f in message.fields %}
                written += {{ f.serialize_payload(message.param_name, "data + written") }};
            {% endfor %}
            DP_ASSERT(written == {{ message.func_name }}_payload_length(msg));
            return written;
        }
        {% if compat_version and message.compat and message.compat.fields %}

        static size_t {{ message.func_name }}_serialize_payload_compat(DP_Message *msg, unsigned char *data)
        {
            {{ message.param }} = DP_message_internal(msg);
            size_t written = 0;
            {% for f in message.compat.fields %}
                written += {{ f.serialize_payload_compat(message.param_name, "data + written") }};
            {% endfor %}
            DP_ASSERT(written == {{ message.func_name }}_payload_length_compat(msg));
            return written;
        }
        {% endif %}

        static bool {{ message.func_name }}_write_payload_text(DP_Message *msg, DP_TextWriter *writer)
        {
            {{ message.param }} = DP_message_internal(msg);
            return {% for f in message.fields|sort(attribute='name') %}
                {% if not f.sub %}
                    {{ f.write_payload_text(message.param_name) }}
                    {%- if not loop.last or message.field_with_subfields %} && {% endif -%}
                {% endif %}
            {% endfor -%}
            {% if message.field_with_subfields %}
                {{ message.field_with_subfields.write_payload_text(message.param_name) }}
            {% endif %};
        }

        static bool {{ message.func_name }}_equals(DP_Message *DP_RESTRICT msg, DP_Message *DP_RESTRICT other)
        {
            {{ message.struct_name }} *a = DP_message_internal(msg);
            {{ message.struct_name }} *b = DP_message_internal(other);
            return {% for f in message.fields %}
                    {{ f.equals }}
                    {%- if not loop.last %} && {% endif -%}
                {% endfor %};
        }
        {% if message.local_match %}

            void DP_{{ message.func_name }}_local_match_set(DP_UNUSED size_t size, unsigned char *data, void *user)
            {
                DP_ASSERT(size == {{ message.enum_name }}_MATCH_LENGTH);
                const {{ message.param }} = user;
                size_t written = 0;
                {% for f in message.fields %}
                    written += {{ f.serialize_local_match(message.param_name, "data + written") }};
                {% endfor %}
                DP_ASSERT(written == {{ message.enum_name }}_MATCH_LENGTH);
            }

            bool DP_{{ message.func_name }}_local_match_matches(const {{ message.param }}, DP_Message *local_match_msg)
            {
                size_t size;
                const unsigned char *buffer = local_match_data(local_match_msg, &size);
                size_t read = 0;
                return size == {{ message.enum_name }}_MATCH_LENGTH
                {% for f in message.fields %}
                    && {{ f.match_local_match(message.param_name) }}
                {% endfor %};
            }
        {% endif %}

        static const DP_MessageMethods {{ message.func_name }}_methods = {
            {{ message.func_name }}_payload_length,
            {{ message.func_name }}_serialize_payload,
            {% if compat_version %}
                {% if message.compat %}
                    {% if message.compat.fields %}
                        {{ message.func_name }}_payload_length_compat,
                        {{ message.func_name }}_serialize_payload_compat,
                    {% else %}
                        zero_length_payload_length,
                        zero_length_serialize_payload,
                    {% endif %}
                {% else %}
                    {{ message.func_name }}_payload_length,
                    {{ message.func_name }}_serialize_payload,
                {% endif %}
            {% endif %}
            {{ message.func_name }}_write_payload_text,
            {{ message.func_name }}_equals,
        };
    {% endif %}

    DP_Message *DP_{{ message.func_name }}_new(
        unsigned int context_id
        {%- for f in message.effective_fields -%}
            , {{ f.constructor_param }}
        {% endfor %}
    )
    {
        {% if message.effective_fields %}
            DP_Message *msg = DP_message_new(
                {{ message.enum_name }},
                context_id,
                &{% if message.alias -%}
                    {{ message.alias_message.func_name}}
                {%- else -%}
                    {{ message.func_name }}
                {%- endif %}_methods,
                {% if message.array_field %}
                    DP_FLEX_SIZEOF({{ message.struct_name }},
                                   {{ message.array_field_name }},
                                   {{ message.array_field_size }})
                {% else %}
                    sizeof({{ message.struct_name }})
                {% endif %});
            {{ message.param }} = DP_message_internal(msg);
            {% for f in message.effective_fields %}
                {{ f.assign(message.param_name) }};
                {% set array_assign = f.array_assign(message.param_name) %}
                {% if array_assign %}
                    {% set array_check = f.array_check(message.param_name) %}
                    {% if array_check %}
                        if ({{ array_check }}) {
                            {{ array_assign }};
                        }
                    {% else %}
                        {{ array_assign }};
                    {% endif %}
                {% endif %}
            {% endfor %}
            return msg;
        {% else %}
            return DP_message_new({{ message.enum_name }}, context_id, &zero_length_methods, 0);
        {% endif %}
    }

    DP_Message *DP_{{ message.func_name }}_deserialize(
        unsigned int context_id,
        {% if not message.effective_fields %}DP_UNUSED {% endif %}const unsigned char *buffer,
        size_t length)
    {
        {% if message.min_length == message.max_length %}
            if (length != {{ message.min_length }}) {
                DP_error_set("Wrong length for {{ message.cmd_name }} message; "
                             "expected {{ message.min_length }}, got %zu", length);
                return NULL;
            }
        {% else %}
            if ({% if message.min_length > 0 %}length < {{ message.min_length }} || {% endif %}
                    length > {{ message.max_length }}) {
                DP_error_set("Wrong length for {{ message.cmd_name }} message; "
                             "expected between {{ message.min_length }} and {{ message.max_length }}, got %zu", length);
                return NULL;
            }
        {% endif %}
        {% if message.effective_fields %}
            size_t read = 0;
            {% for f in message.effective_fields %}
                {% set deserialize_field_size = f.deserialize_field_size %}
                {% if deserialize_field_size %}
                    size_t {{ f.name }}_bytes = {{ deserialize_field_size }};
                {% endif %}
                {% set deserialize_field_divisor = f.deserialize_field_divisor %}
                {% if deserialize_field_divisor > 1 %}
                    if (({{ f.name }}_bytes % {{ deserialize_field_divisor }}) != 0) {
                        DP_error_set("Wrong length for {{ f.name }} field in {{ message.cmd_name }} message; "
                                     "%zu not divisible by {{ deserialize_field_divisor }}",
                                     {{ f.name }}_bytes);
                        return NULL;
                    }
                {% endif %}
                {% if f.deserialize_field_check_remaining %}
                    if (read + {{ f.name }}_bytes > length) {
                        DP_error_set("Wrong length for {{ f.name }} field in {{ message.cmd_name }} message; "
                                     "field length %zu exceeds total length %zu",
                                     {{ f.name }}_bytes, length);
                        return NULL;
                    }
                {% endif %}
                {% set deserialize_field_count = f.deserialize_field_count %}
                {% if deserialize_field_count %}
                    {{ deserialize_field_count }}
                {% endif %}
                {{ f.deserialize_field }}
            {% endfor %}
        {% endif %}
        return DP_{{ message.func_name }}_new(context_id
            {%- for f in message.effective_fields %}
                , {{ f.deserialize_constructor_arg }}
            {% endfor %});
    }
    {% if compat_version and not message.incompatible %}

    {% set mc = message.compat %}
    DP_Message *DP_{{ message.func_name }}_deserialize_compat(
        unsigned int context_id,
        {% if mc and not mc.fields %}DP_UNUSED {% endif %}const unsigned char *buffer,
        size_t length)
    {
        {% if mc %}
            {% if mc.min_length == mc.max_length %}
                if (length != {{ mc.min_length }}) {
                    DP_error_set("Wrong length for {{ message.cmd_name }} compat message; "
                                "expected {{ mc.min_length }}, got %zu", length);
                    return NULL;
                }
            {% else %}
                if ({% if mc.min_length > 0 %}length < {{ mc.min_length }} || {% endif %}
                        length > {{ mc.max_length }}) {
                    DP_error_set("Wrong length for {{ message.cmd_name }} compat message; "
                                "expected between {{ mc.min_length }} and {{ mc.max_length }}, got %zu", length);
                    return NULL;
                }
            {% endif %}
            {% if mc.fields %}
                size_t read = 0;
                {% for f in mc.fields %}
                    {% set deserialize_field_size = f.deserialize_field_size %}
                    {% if deserialize_field_size %}
                        size_t {{ f.name }}_bytes = {{ deserialize_field_size }};
                    {% endif %}
                    {% set deserialize_field_divisor = f.deserialize_field_divisor %}
                    {% if deserialize_field_divisor > 1 %}
                        if (({{ f.name }}_bytes % {{ deserialize_field_divisor }}) != 0) {
                            DP_error_set("Wrong length for {{ f.name }} field in {{ message.cmd_name }} message; "
                                        "%zu not divisible by {{ deserialize_field_divisor }}",
                                        {{ f.name }}_bytes);
                            return NULL;
                        }
                    {% endif %}
                    {% if f.deserialize_field_check_remaining %}
                        if (read + {{ f.name }}_bytes > length) {
                            DP_error_set("Wrong length for {{ f.name }} field in {{ message.cmd_name }} message; "
                                        "field length %zu exceeds total length %zu",
                                        {{ f.name }}_bytes, length);
                            return NULL;
                        }
                    {% endif %}
                    {% set deserialize_field_count = f.deserialize_field_count %}
                    {% if deserialize_field_count %}
                        {{ deserialize_field_count }}
                    {% endif %}
                    {{ f.deserialize_field }}
                {% endfor %}
            {% endif %}
            DP_Message *msg = DP_{{ message.func_name }}_new(context_id
                {% if mc.deserialize_fields %}
                    {%- for df in mc.deserialize_fields %}
                        {% if df is string %}
                            {%- for f in mc.fields %}
                                {% if f.name == df %}
                                    , {{ f.deserialize_constructor_arg }}
                                {% endif %}
                            {% endfor %}
                        {% else %}
                            , {{ df.literal }}
                        {% endif %}
                    {% endfor %}
                {% else %}
                    {%- for f in mc.fields %}
                        , {{ f.deserialize_constructor_arg }}
                    {% endfor %}
                {% endif %});
        {% else %}
            DP_Message *msg = DP_{{ message.func_name }}_deserialize(context_id, buffer, length);
        {% endif %}
            DP_message_compat_set(msg);
            return msg;
    }
    {% endif %}

    DP_Message *DP_{{ message.func_name }}_parse(unsigned int context_id, {% if not message.effective_fields %}DP_UNUSED {% endif %}DP_TextReader *reader)
    {
        {% if message.effective_fields %}
            {% for f in message.effective_fields %}
                {% set parse_field_count = f.parse_field_count %}
                {% if parse_field_count %}
                    {{ parse_field_count }}
                {% endif %}
                {{ f.parse_field }}
            {% endfor %}
        {% endif %}
        return DP_{{ message.func_name }}_new(context_id
            {%- for f in message.effective_fields %}
                , {{ f.parse_constructor_arg }}
            {% endfor %});
    }
    {% if message.fields or message.alias %}

        {{ message.struct_name }} *DP_{{ message.func_name }}_cast(DP_Message *msg)
        {
            return DP_message_cast(msg, {{ message.enum_name }});
        }
    {% endif %}
    {% for f in message.fields %}

        {{ f.accessor_return_type }} DP_{{ message.func_name }}_{{ f.func_name }}(
            const {{ message.param }}
            {%- if f.accessor_out_param %}, {{ f.accessor_out_param }}{% endif -%}
        )
        {
            DP_ASSERT({{ message.param_name }});
            {% if f.accessor_out_param %}
                if ({{ f.accessor_out_param_condition }}) {
                    {{ f.accessor_out_param_assign(message.param_name) }};
                }
            {% endif %}
            return {{ f.access(message.param_name) }};
        }
        {% set array_size_type = f.array_size_type %}
        {% if array_size_type %}

            {{ array_size_type }} DP_{{ message.func_name }}_{{ f.func_name }}_{{ f.array_size_name }}(const {{message.param}})
            {
                return {{ f.access_size(message.param_name) }};
            }
        {% endif %}
    {% endfor %}

{% endfor %}

static bool local_layer_id(uint32_t layer_id)
{
    return DP_layer_id_local(DP_protocol_to_layer_id(layer_id));
}

static bool local_selection_id(uint8_t selection_id)
{
    return DP_selection_id_local(selection_id);
}

static DP_Message *make_local_match(bool disguise_as_put_image, uint8_t type,
                                    unsigned int context_id,
                                    DP_MessageLocalMatchSetFn set, size_t size,
                                    void *user)
{
    if (disguise_as_put_image) {
        return DP_msg_put_image_new(context_id, type,
                                    DP_BLEND_MODE_COMPAT_LOCAL_MATCH, 0, 0, 0,
                                    0, set, size, user);
    }
    else {
        return DP_msg_local_match_new(context_id, type, set, size, user);
    }
}

DP_Message *DP_msg_local_match_make(DP_Message *msg, bool disguise_as_put_image)
{
    DP_ASSERT(msg);
    DP_MessageType type = DP_message_type(msg);
    switch(type) {
    {% for message in messages %}
        {% if message.local_match and not message.alias %}
            case {{ message.enum_name }}:
            {% for alias_message in messages %}
                {% if alias_message.alias == message.name %}
                    case {{ alias_message.enum_name }}:
                {% endif %}
            {% endfor %} {
                {{ message.param }} = DP_message_internal(msg);
                if ({{ message.local_match_condition(message.param_name) }}) {
                    return make_local_match(
                        disguise_as_put_image, (uint8_t)type,
                        DP_message_context_id(msg),
                        DP_{{ message.func_name }}_local_match_set,
                        {{ message.enum_name }}_MATCH_LENGTH,
                        {{ message.param_name }});
                    break;
                }
                else {
                    return NULL;
                }
            }
        {% endif %}
    {% endfor %}
    default:
        return NULL;
    }
}

bool DP_msg_local_match_is_local_match(DP_Message *msg)
{
    switch (DP_message_type(msg)) {
    case DP_MSG_LOCAL_MATCH:
        return true;
    case DP_MSG_PUT_IMAGE:
        return DP_msg_put_image_mode(DP_message_internal(msg))
            == DP_BLEND_MODE_COMPAT_LOCAL_MATCH;
    default:
        return false;
    }
}

bool DP_msg_local_match_matches(DP_Message *msg, DP_Message *local_match_msg)
{
    DP_ASSERT(msg);
    DP_MessageType type = DP_message_type(msg);
    switch(type) {
    {% for message in messages %}
        {% if message.local_match and not message.alias %}
            case {{ message.enum_name }}:
            {% for alias_message in messages %}
                {% if alias_message.alias == message.name %}
                    case {{ alias_message.enum_name }}:
                {% endif %}
            {% endfor %} {
                {{ message.param }} = DP_message_internal(msg);
                return ({{ message.local_match_condition(message.param_name) }})
                    && DP_{{ message.func_name }}_local_match_matches({{ message.param_name }}, local_match_msg);
            }
        {% endif %}
    {% endfor %}
    default:
        return false;
    }
}
