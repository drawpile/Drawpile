/*
 * Copyright (C) 2022 askmeaboutloom
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * --------------------------------------------------------------------
 *
 * This code is auto-generated by generators/protogen/protogen_drawdance.py
 * from generators/protogen/messages.c.jinja. Don't edit it directly.
 */
#include "messages.h"
#include "message.h"
#include "text_reader.h"
#include "text_writer.h"
#include <dpcommon/binary.h>
#include <dpcommon/common.h>
#include <dpcommon/conversions.h>
#include <dpcommon/endianness.h>


bool DP_message_type_control(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        {% if message.message_type == "Control" %}
        case {{ message.enum_name }}:
        {% endif %}
    {% endfor %}
        return true;
    default:
        return false;
    }
}

bool DP_message_type_server_meta(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        {% if message.message_type == "ServerMeta" %}
        case {{ message.enum_name }}:
        {% endif %}
    {% endfor %}
        return true;
    default:
        return false;
    }
}

bool DP_message_type_client_meta(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        {% if message.message_type == "ClientMeta" %}
        case {{ message.enum_name }}:
        {% endif %}
    {% endfor %}
        return true;
    default:
        return false;
    }
}

bool DP_message_type_command(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        {% if message.message_type == "Command" %}
        case {{ message.enum_name }}:
        {% endif %}
    {% endfor %}
        return true;
    default:
        return false;
    }
}

const char *DP_message_type_name(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        case {{ message.enum_name }}:
            return "{{ message.cmd_name }}";
    {% endfor %}
    default:
        return "unknown";
    }
}

const char *DP_message_type_enum_name(DP_MessageType type)
{
    switch (type) {
    {% for message in messages %}
        case {{ message.enum_name }}:
            return "{{ message.enum_name }}";
    {% endfor %}
    default:
        return "DP_MSG_UNKNOWN";
    }
}

const char *DP_message_type_enum_name_unprefixed(DP_MessageType type)
{
    return DP_message_type_enum_name(type) + 7;
}

DP_MessageType DP_message_type_from_name(const char *type_name, DP_MessageType not_found_value)
{
    {% for message in messages %}
        {% if not message.reserved %}
            {% if not loop.first %}else {% endif %}if (DP_str_equal(type_name, "{{ message.cmd_name }}")) {
                return {{ message.enum_name }};
            }
        {% endif %}
    {% endfor %}
    else {
        return not_found_value;
    }
}

bool DP_message_type_parse_multiline_tuples(DP_MessageType type)
{
    switch (type) {
        {% for message in messages %}
            {% if message.field_with_subfields %}
                case {{ message.enum_name }}:
            {% endif %}
        {% endfor %}
        return true;
    default:
        return false;
    }
}


DP_Message *DP_message_deserialize_body(int type, unsigned int context_id, const unsigned char *buf, size_t length, bool decode_opaque)
{
    if (type < DP_MESSAGE_TYPE_RANGE_START_CLIENT || decode_opaque) {
        switch (type) {
        {% for message in messages %}
            case {{ message.enum_name }}:
                {% if message.reserved %}
                    DP_error_set("Can't deserialize reserved message type {{ message.id }} {{ message.enum_name }}");
                    return NULL;
                {% else %}
                    return DP_{{ message.func_name }}_deserialize(context_id, buf, length);
                {% endif %}
        {% endfor %}
        default:
            DP_error_set("Can't deserialize unknown message type %d", type);
            return NULL;
        }
    } else {
        return DP_message_new_opaque((DP_MessageType)type, context_id, buf, length);
    }
}

DP_Message *DP_message_parse_body(DP_MessageType type, unsigned int context_id, DP_TextReader *reader)
{
    switch (type) {
    {% for message in messages %}
        case {{ message.enum_name }}:
            {% if message.reserved %}
                DP_error_set("Can't parse reserved message type {{ message.id }} {{ message.enum_name }}");
                return NULL;
            {% else %}
                return DP_{{ message.func_name }}_parse(context_id, reader);
            {% endif %}
    {% endfor %}
    default:
        DP_error_set("Can't parse unknown message type %d", type);
        return NULL;
    }
}


static size_t zero_length_payload_length(DP_UNUSED DP_Message *msg)
{
    return 0;
}

static size_t zero_length_serialize_payload(DP_UNUSED DP_Message *msg, DP_UNUSED unsigned char *data)
{
    return 0;
}

static bool zero_length_write_payload_text(DP_UNUSED DP_Message *msg, DP_UNUSED DP_TextWriter *writer)
{
    return true;
}

static bool zero_length_equals(DP_UNUSED DP_Message *DP_RESTRICT msg, DP_UNUSED DP_Message *DP_RESTRICT other)
{
    return true;
}

static const DP_MessageMethods zero_length_methods = {
    zero_length_payload_length,
    zero_length_serialize_payload,
    zero_length_write_payload_text,
    zero_length_equals,
};


static void assign_string(char *dst, const char *src, size_t len)
{
    memcpy(dst, src, len);
    dst[len] = '\0';
}

static int8_t read_int8(const unsigned char *buffer, size_t *read)
{
    *read += 1;
    return DP_read_bigendian_int8(buffer);
}

static int32_t read_int32(const unsigned char *buffer, size_t *read)
{
    *read += 4;
    return DP_read_bigendian_int32(buffer);
}

static uint8_t read_uint8(const unsigned char *buffer, size_t *read)
{
    *read += 1;
    return DP_read_bigendian_uint8(buffer);
}

static uint16_t read_uint16(const unsigned char *buffer, size_t *read)
{
    *read += 2;
    return DP_read_bigendian_uint16(buffer);
}

static uint32_t read_uint24(const unsigned char *buffer, size_t *read)
{
    *read += 3;
    return DP_read_bigendian_uint24(buffer);
}

static uint32_t read_uint32(const unsigned char *buffer, size_t *read)
{
    *read += 4;
    return DP_read_bigendian_uint32(buffer);
}

static bool read_bool(const unsigned char *buffer, size_t *read)
{
    return read_uint8(buffer, read) != 0;
}

static const char *read_string_with_length(const unsigned char *buffer, size_t len, size_t *read)
{
    *read += len;
    return (const char *)buffer;
}

static void read_bytes(size_t count, unsigned char *out, void *user)
{
    const unsigned char *buffer = user;
    memcpy(out, buffer, count);
}

static void read_uint8_array(int count, uint8_t *out, void *user)
{
    const unsigned char *buffer = user;
    memcpy(out, buffer, DP_int_to_size(count));
}

static void read_uint16_array(int count, uint16_t *out, void *user)
{
    const unsigned char *buffer = user;
#if defined(DP_BYTE_ORDER_LITTLE_ENDIAN)
    for (int i = 0; i < count; ++i) {
        out[i] = DP_read_bigendian_uint16(buffer + i * 2);
    }
#elif defined(DP_BYTE_ORDER_BIG_ENDIAN)
    memcpy(out, buffer, DP_int_to_size(count) * 2);
#else
#   error "Unknown byte order"
#endif
}

static size_t write_bytes(const unsigned char *DP_RESTRICT x, int count, unsigned char *DP_RESTRICT out)
{
    return DP_write_bytes(x, count, 1, out);
}

static size_t write_string_with_length(const char *DP_RESTRICT x, size_t len,
                                       unsigned char *DP_RESTRICT out)
{
    size_t written = DP_write_bigendian_uint8(DP_size_to_uint8(len), out);
    return written + DP_write_bytes(x, 1, len, out + written);
}

{% for message in messages if not message.reserved %}

/* {{ message.enum_name }} */
    {% for f in message.fields %}
        {% if f.flags %}

            const char *DP_{{ message.func_name }}_{{ f.func_name }}_flag_name(unsigned int value)
            {
                switch (value) {
                {% for flag in f.flags %}
                case {{ flag.define_name }}:
                    return "{{ flag.name }}";
                {% endfor %}
                default:
                    return NULL;
                }
            }
        {% endif %}
        {% if f.variants %}

            const char *DP_{{ message.func_name }}_{{ f.func_name }}_variant_name(unsigned int value)
            {
                switch (value) {
                {% for variant in f.variants %}
                case {{ variant.define_name }}:
                    return "{{ variant.name }}";
                {% endfor %}
                default:
                    return NULL;
                }
            }
        {% endif %}
    {% endfor %}
    {% for f in message.fields %}
        {% if f.sub %}

            struct {{ f.sub.struct_name }} {
                {% for sf in f.sub.fields %}
                    {{ sf.struct_declaration }};
                {% endfor %}
            };

            static size_t {{ f.sub.func_name }}_serialize_payload({{ f.sub.param }}, unsigned char *data)
            {
                size_t written = 0;
                {% for sf in f.sub.fields %}
                    written += {{ sf.serialize_payload(f.sub.param_name, "data + written") }};
                {% endfor %}
                return written;
            }

            static size_t {{ f.sub.func_name }}_serialize_payloads({{ f.sub.param }}, int count, unsigned char *data)
            {
                size_t written = 0;
                for (int i = 0; i < count; ++i) {
                    written += {{ f.sub.func_name }}_serialize_payload(&{{ f.sub.param_name }}[i], data + written);
                }
                return written;
            }

            static bool {{ f.sub.func_name }}_write_payload_text({{ f.sub.param }}, DP_TextWriter *writer)
            {
                return DP_text_writer_start_subobject(writer) &&
                    {% for sf in f.sub.fields %}
                        {{ sf.write_subfield_payload_text(f.sub.param_name) }} &&
                    {% endfor %}
                    DP_text_writer_finish_subobject(writer);
            }

            static size_t {{ f.sub.func_name }}_write_payload_texts({{ f.sub.param }}, int count, DP_TextWriter *writer)
            {
                if (count != 0) {
                    if (!DP_text_writer_start_subs(writer)) {
                        return false;
                    }
                    for (int i = 0; i < count; ++i) {
                        if (!{{ f.sub.func_name }}_write_payload_text(&{{ f.sub.param_name }}[i], writer)) {
                            return false;
                        }
                    }
                    if (!DP_text_writer_finish_subs(writer)) {
                        return false;
                    }
                }
                return true;
            }

            static bool {{ f.sub.func_name }}_equals({{ f.sub.struct_name }} *DP_RESTRICT a, {{ f.sub.struct_name }} *DP_RESTRICT b)
            {
                return {% for sf in f.sub.fields %}
                        {{ sf.equals }}
                        {%- if not loop.last %} && {% endif -%}
                    {% endfor %};
            }

            static bool {{ f.sub.func_name }}s_equal({{ f.sub.struct_name }} *DP_RESTRICT a, {{ f.sub.struct_name }} *DP_RESTRICT b, int count)
            {
                for (int i = 0; i < count; ++i) {
                    if (!{{ f.sub.func_name }}_equals(&a[i], &b[i])) {
                        return false;
                    }
                }
                return true;
            }

            void DP_{{ f.sub.func_name }}_init({{ f.sub.param }}s, int i
                {%- for sf in f.sub.fields %}
                    , {{ sf.constructor_param }}
                {% endfor -%}
            )
            {
                DP_ASSERT({{ f.sub.param_name }}s);
                {{ f.sub.param }} = &{{ f.sub.param_name }}s[i];
                {% for sf in f.sub.fields %}
                    {{ sf.assign(f.sub.param_name) }};
                {% endfor %}
            }

            static void {{ f.sub.func_name }}_deserialize(int count, {{ f.sub.param }}s, void *user)
            {
                const unsigned char *buffer = user;
                size_t read = 0;
                for (int i = 0; i < count; ++i) {
                    {% for sf in f.sub.fields %}
                        {{ sf.deserialize_field }}
                    {% endfor %}
                    DP_{{ f.sub.func_name }}_init({{ f.sub.param_name }}s, i
                        {%- for sf in f.sub.fields %}
                            , {{ sf.deserialize_constructor_arg }}
                        {% endfor %});
                }
            }

            static void {{ f.sub.func_name }}_parse(int count, {{ f.sub.param }}s, void *user)
            {
                DP_TextReader *reader = user;
                for (int i = 0; i < count; ++i) {
                    {% for sf in f.sub.fields %}
                        {{ sf.parse_subfield(loop.index - 1) }}
                    {% endfor %}
                    DP_{{ f.sub.func_name }}_init({{ f.sub.param_name }}s, i
                        {%- for sf in f.sub.fields %}
                            , {{ sf.deserialize_constructor_arg }}
                        {% endfor %});
                }
            }
            {% for sf in f.sub.fields %}

                {{ sf.accessor_return_type }} DP_{{ f.sub.func_name }}_{{ sf.func_name }}(
                    const {{ f.sub.param }})
                {
                    DP_ASSERT({{ f.sub.param_name }});
                    return {{ sf.access(f.sub.param_name) }};
                }
            {% endfor %}

            const {{ f.sub.struct_name }} *DP_{{ f.sub.func_name }}_at(const {{ f.sub.param }}, int i)
            {
                DP_ASSERT({{ f.sub.param_name }});
                return &{{ f.sub.param_name }}[i];
            }
        {% endif %}
    {% endfor %}
    {% if message.fields %}

        struct {{ message.struct_name }} {
            {% for f in message.fields %}
                {{ f.struct_declaration }};
            {% endfor %}
            {% if message.array_field %}
                {{ message.array_declaration }};
            {% endif %}
        };

        {% set spl = message.static_payload_length %}
        {% set dpl = message.dynamic_payload_length %}
        static size_t {{ message.func_name }}_payload_length(
            {%- if not dpl %}DP_UNUSED {% endif -%}
            DP_Message *msg)
        {
            {% if dpl %}
                {{ message.param }} = DP_message_internal(msg);
            {% endif %}
            return {% if spl %}((size_t){{ spl }}){% endif -%}
                   {% if spl and dpl %} + {% endif -%}
                   {% if dpl %}{{ dpl }}{% endif %};
        }

        static size_t {{ message.func_name }}_serialize_payload(DP_Message *msg, unsigned char *data)
        {
            {{ message.param }} = DP_message_internal(msg);
            size_t written = 0;
            {% for f in message.fields %}
                written += {{ f.serialize_payload(message.param_name, "data + written") }};
            {% endfor %}
            DP_ASSERT(written == {{ message.func_name }}_payload_length(msg));
            return written;
        }

        static bool {{ message.func_name }}_write_payload_text(DP_Message *msg, DP_TextWriter *writer)
        {
            {{ message.param }} = DP_message_internal(msg);
            return {% for f in message.fields|sort(attribute='name') %}
                {% if not f.sub %}
                    {{ f.write_payload_text(message.param_name) }}
                    {%- if not loop.last or message.field_with_subfields %} && {% endif -%}
                {% endif %}
            {% endfor -%}
            {% if message.field_with_subfields %}
                {{ message.field_with_subfields.write_payload_text(message.param_name) }}
            {% endif %};
        }

        static bool {{ message.func_name }}_equals(DP_Message *DP_RESTRICT msg, DP_Message *DP_RESTRICT other)
        {
            {{ message.struct_name }} *a = DP_message_internal(msg);
            {{ message.struct_name }} *b = DP_message_internal(other);
            return {% for f in message.fields %}
                    {{ f.equals }}
                    {%- if not loop.last %} && {% endif -%}
                {% endfor %};
        }
    {% endif %}
    {% if message.fields %}

        static const DP_MessageMethods {{ message.func_name }}_methods = {
            {{ message.func_name }}_payload_length,
            {{ message.func_name }}_serialize_payload,
            {{ message.func_name }}_write_payload_text,
            {{ message.func_name }}_equals,
        };
    {% endif %}

    DP_Message *DP_{{ message.func_name }}_new(
        unsigned int context_id
        {%- for f in message.effective_fields -%}
            , {{ f.constructor_param }}
        {% endfor %}
    )
    {
        {% if message.effective_fields %}
            DP_Message *msg = DP_message_new(
                {{ message.enum_name }},
                context_id,
                &{% if message.alias -%}
                    {{ message.alias_message.func_name}}
                {%- else -%}
                    {{ message.func_name }}
                {%- endif %}_methods,
                {% if message.array_field %}
                    DP_FLEX_SIZEOF({{ message.struct_name }},
                                   {{ message.array_field_name }},
                                   {{ message.array_field_size }})
                {% else %}
                    sizeof({{ message.struct_name }})
                {% endif %});
            {{ message.param }} = DP_message_internal(msg);
            {% for f in message.effective_fields %}
                {{ f.assign(message.param_name) }};
                {% set array_assign = f.array_assign(message.param_name) %}
                {% if array_assign %}
                    {% set array_check = f.array_check(message.param_name) %}
                    {% if array_check %}
                        if ({{ array_check }}) {
                            {{ array_assign }};
                        }
                    {% else %}
                        {{ array_assign }};
                    {% endif %}
                {% endif %}
            {% endfor %}
            return msg;
        {% else %}
            return DP_message_new({{ message.enum_name }}, context_id, &zero_length_methods, 0);
        {% endif %}
    }

    DP_Message *DP_{{ message.func_name }}_deserialize(
        unsigned int context_id,
        {% if not message.effective_fields %}DP_UNUSED {% endif %}const unsigned char *buffer,
        size_t length)
    {
        {% if message.min_length == message.max_length %}
            if (length != {{ message.min_length }}) {
                DP_error_set("Wrong length for {{ message.cmd_name }} message; "
                             "expected {{ message.min_length }}, got %zu", length);
                return NULL;
            }
        {% else %}
            if ({% if message.min_length > 0 %}length < {{ message.min_length }} || {% endif %}
                    length > {{ message.max_length }}) {
                DP_error_set("Wrong length for {{ message.cmd_name }} message; "
                             "expected between {{ message.min_length }} and {{ message.max_length }}, got %zu", length);
                return NULL;
            }
        {% endif %}
        {% if message.effective_fields %}
            size_t read = 0;
            {% for f in message.effective_fields %}
                {% set deserialize_field_size = f.deserialize_field_size %}
                {% if deserialize_field_size %}
                    size_t {{ f.name }}_bytes = {{ deserialize_field_size }};
                {% endif %}
                {% set deserialize_field_divisor = f.deserialize_field_divisor %}
                {% if deserialize_field_divisor > 1 %}
                    if (({{ f.name }}_bytes % {{ deserialize_field_divisor }}) != 0) {
                        DP_error_set("Wrong length for {{ f.name }} field in {{ message.cmd_name }} message; "
                                     "%zu not divisible by {{ deserialize_field_divisor }}",
                                     {{ f.name }}_bytes);
                        return NULL;
                    }
                {% endif %}
                {% if f.deserialize_field_check_remaining %}
                    if (read + {{ f.name }}_bytes > length) {
                        DP_error_set("Wrong length for {{ f.name }} field in {{ message.cmd_name }} message; "
                                     "field length %zu exceeds total length %zu",
                                     {{ f.name }}_bytes, length);
                        return NULL;
                    }
                {% endif %}
                {% set deserialize_field_count = f.deserialize_field_count %}
                {% if deserialize_field_count %}
                    {{ deserialize_field_count }}
                {% endif %}
                {{ f.deserialize_field }}
            {% endfor %}
        {% endif %}
        return DP_{{ message.func_name }}_new(context_id
            {%- for f in message.effective_fields %}
                , {{ f.deserialize_constructor_arg }}
            {% endfor %});
    }

    DP_Message *DP_{{ message.func_name }}_parse(unsigned int context_id, {% if not message.effective_fields %}DP_UNUSED {% endif %}DP_TextReader *reader)
    {
        {% if message.effective_fields %}
            {% for f in message.effective_fields %}
                {% set parse_field_count = f.parse_field_count %}
                {% if parse_field_count %}
                    {{ parse_field_count }}
                {% endif %}
                {{ f.parse_field }}
            {% endfor %}
        {% endif %}
        return DP_{{ message.func_name }}_new(context_id
            {%- for f in message.effective_fields %}
                , {{ f.parse_constructor_arg }}
            {% endfor %});
    }
    {% if message.fields or message.alias %}

        {{ message.struct_name }} *DP_{{ message.func_name }}_cast(DP_Message *msg)
        {
            return DP_message_cast(msg, {{ message.enum_name }});
        }
    {% endif %}
    {% for f in message.fields %}

        {{ f.accessor_return_type }} DP_{{ message.func_name }}_{{ f.func_name }}(
            const {{ message.param }}
            {%- if f.accessor_out_param %}, {{ f.accessor_out_param }}{% endif -%}
        )
        {
            DP_ASSERT({{ message.param_name }});
            {% if f.accessor_out_param %}
                if ({{ f.accessor_out_param_condition }}) {
                    {{ f.accessor_out_param_assign(message.param_name) }};
                }
            {% endif %}
            return {{ f.access(message.param_name) }};
        }
        {% set array_size_type = f.array_size_type %}
        {% if array_size_type %}

            {{ array_size_type }} DP_{{ message.func_name }}_{{ f.func_name }}_{{ f.array_size_name }}(const {{message.param}})
            {
                return {{ f.access_size(message.param_name) }};
            }
        {% endif %}
    {% endfor %}

{% endfor %}
