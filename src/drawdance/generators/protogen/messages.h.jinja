/*
 * Copyright (C) 2022 askmeaboutloom
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * --------------------------------------------------------------------
 *
 * This code is auto-generated by generators/protogen/protogen_drawdance.py
 * from generators/protogen/messages.h.jinja. Don't edit it directly.
 */
#ifndef DPMSG_MESSAGES_H
#define DPMSG_MESSAGES_H
#include <dpcommon/common.h>

typedef struct DP_Message DP_Message;
typedef struct DP_TextReader DP_TextReader;
typedef struct DP_TextWriter DP_TextWriter;

typedef void (*DP_MessageLocalMatchSetFn)(size_t, unsigned char *, void *);

#define DP_PROTOCOL_VERSION_NAMESPACE "{{ version.namespace }}"
#define DP_PROTOCOL_VERSION_SERVER    {{ version.server }}
#define DP_PROTOCOL_VERSION_MAJOR     {{ version.major }}
#define DP_PROTOCOL_VERSION_MINOR     {{ version.minor }}
#define DP_PROTOCOL_VERSION           "{{ version.string }}"
#define DP_UNDO_DEPTH_DEFAULT         {{ undo_depth }}

typedef struct DP_MessageMethods {
    size_t (*payload_length)(DP_Message *msg);
    size_t (*serialize_payload)(DP_Message *msg, unsigned char *data);
    bool (*write_payload_text)(DP_Message *msg, DP_TextWriter *writer);
    bool (*equals)(DP_Message *DP_RESTRICT msg, DP_Message *DP_RESTRICT other);
} DP_MessageMethods;

typedef enum DP_MessageType {
    {% for message in messages %}
        {{ message.enum_name }} = {{ message.id }},
    {% endfor %}
    DP_MSG_TYPE_COUNT,
} DP_MessageType;

bool DP_message_type_control(DP_MessageType type);

bool DP_message_type_client_meta(DP_MessageType type);

bool DP_message_type_server_meta(DP_MessageType type);

bool DP_message_type_command(DP_MessageType type);

const char *DP_message_type_name(DP_MessageType type);

const char *DP_message_type_enum_name(DP_MessageType type);

const char *DP_message_type_enum_name_unprefixed(DP_MessageType type);

DP_MessageType DP_message_type_from_name(const char *type_name, DP_MessageType not_found_value);

// Returns if the given type's text format has a body of value tuples, rather
// than a body of multiline fields. This is the case for draw dabs messages.
bool DP_message_type_parse_multiline_tuples(DP_MessageType type);


DP_Message *DP_message_deserialize_body(int type, unsigned int context_id, const unsigned char *buf, size_t length, bool decode_opaque);

DP_Message *DP_message_parse_body(DP_MessageType type, unsigned int context_id, DP_TextReader *reader);

{% for message in messages %}

/*
 * {{ message.enum_name }}
 *
{{ message.comment }}
 */
    {% if not message.reserved %}

        #define {{ message.enum_name }}_STATIC_LENGTH {{ message.static_payload_length }}
        {% if message.local_match %}
            #define {{ message.enum_name }}_MATCH_LENGTH {{ message.local_match_length }}
        {% endif %}
        {% for f in message.fields %}
            {% if f.min != f.max %}

                #define {{ message.enum_name }}_{{ f.func_name|upper }}_MIN_{{ f.array_size_name|upper }} {{ f.min }}
                #define {{ message.enum_name }}_{{ f.func_name|upper }}_MAX_{{ f.array_size_name|upper }} {{ f.max }}
            {% endif %}
            {% if f.flags %}

                {% for flag in f.flags %}
                    #define {{ flag.define_name }} 0x{{ '%.x'|format(flag.value) }}
                {% endfor %}

                #define DP_{{ message.func_name|upper }}_NUM_{{ f.func_name|upper }} {{ f.flags|length }}
                #define DP_{{ message.func_name|upper }}_ALL_{{ f.func_name|upper }} \
                {% for flag in f.flags %}
                    {{ flag.define_name }}{% if not loop.last %}, \{% endif %}

                {% endfor %}

                const char *DP_{{ message.func_name }}_{{ f.func_name }}_flag_name(unsigned int value);
            {% endif %}
            {% if f.variants %}

                {% for variant in f.variants %}
                    #define {{ variant.define_name }} {{ variant.value }}
                {% endfor %}

                #define DP_{{ message.func_name|upper }}_NUM_{{ f.func_name|upper }} {{ f.variants|length }}
                #define DP_{{ message.func_name|upper }}_ALL_{{ f.func_name|upper }} \
                {% for variant in f.variants %}
                    {{ variant.define_name }}{% if not loop.last %}, \{% endif %}

                {% endfor %}

                const char *DP_{{ message.func_name }}_{{ f.func_name }}_variant_name(unsigned int value);
            {% endif %}
        {% endfor %}
        {% for f in message.fields %}
            {% if f.sub %}

                #define {{ message.enum_name }}_{{ f.func_name|upper }}_MAX {{ f.sub.max_items }}

                typedef struct {{ f.sub.struct_name }} {{ f.sub.struct_name }};

                void DP_{{ f.sub.func_name }}_init({{ f.sub.param }}s, int i
                    {%- for sf in f.sub.fields %}
                        , {{ sf.constructor_param }}
                    {% endfor -%}
                );
                {% for sf in f.sub.fields %}

                    {{ sf.accessor_return_type }} DP_{{ f.sub.func_name }}_{{ sf.func_name }}(
                        const {{ f.sub.param }});
                {% endfor %}

                const {{ f.sub.struct_name }} *DP_{{ f.sub.func_name }}_at(const {{ f.sub.param }}, int i);

            {% endif %}
        {% endfor %}
        {% if message.fields %}

            typedef struct {{ message.struct_name }} {{ message.struct_name }};
        {% endif %}

        DP_Message *DP_{{ message.func_name }}_new(
            unsigned int context_id
            {%- for f in message.effective_fields -%}
                , {{ f.constructor_param }}
            {% endfor %}
        );

        DP_Message *DP_{{ message.func_name }}_deserialize(unsigned int context_id, const unsigned char *buffer, size_t length);

        DP_Message *DP_{{ message.func_name }}_parse(unsigned int context_id, DP_TextReader *reader);
        {% if message.local_match %}

            void DP_{{ message.func_name }}_local_match_set(size_t size, unsigned char *data, void *user);

            bool DP_{{ message.func_name }}_local_match_matches(const {{ message.param }}, DP_Message *local_match_msg);
        {% endif %}
        {% if message.fields or message.alias %}

            {{ message.struct_name }} *DP_{{ message.func_name }}_cast(DP_Message *msg);
        {% endif %}
        {% for f in message.fields %}

            {{ f.accessor_return_type }} DP_{{ message.func_name }}_{{ f.func_name }}(
                const {{ message.param }}
                {%- if f.accessor_out_param %}, {{ f.accessor_out_param }}{% endif -%}
            );
            {% set array_size_type = f.array_size_type %}
            {% if array_size_type %}

                {{ array_size_type }} DP_{{ message.func_name }}_{{ f.func_name }}_{{ f.array_size_name }}(const {{message.param}});
            {% endif %}
        {% endfor %}
    {% endif %}

{% endfor %}

DP_Message *DP_msg_local_match_make(DP_Message *msg, bool disguise_as_put_image);

bool DP_msg_local_match_is_local_match(DP_Message *msg);

bool DP_msg_local_match_matches(DP_Message *msg, DP_Message *local_match_msg);

#endif
