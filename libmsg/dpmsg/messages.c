/*
 * Copyright (C) 2022 askmeaboutloom
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * --------------------------------------------------------------------
 *
 * This code is auto-generated by generators/protogen/protogen_drawdance.py
 * from generators/protogen/messages.c.jinja. Don't edit it directly.
 */
#include "messages.h"
#include "message.h"
#include "text_writer.h"
#include <dpcommon/binary.h>
#include <dpcommon/common.h>
#include <dpcommon/conversions.h>
#include <dpcommon/endianness.h>


bool DP_message_type_control(DP_MessageType type)
{
    switch (type) {
    case DP_MSG_SERVER_COMMAND:
    case DP_MSG_DISCONNECT:
    case DP_MSG_PING:
    case DP_MSG_INTERNAL:
        return true;
    default:
        return false;
    }
}

bool DP_message_type_server_meta(DP_MessageType type)
{
    switch (type) {
    case DP_MSG_JOIN:
    case DP_MSG_LEAVE:
    case DP_MSG_SESSION_OWNER:
    case DP_MSG_CHAT:
    case DP_MSG_TRUSTED_USERS:
    case DP_MSG_SOFT_RESET:
    case DP_MSG_PRIVATE_CHAT:
        return true;
    default:
        return false;
    }
}

bool DP_message_type_client_meta(DP_MessageType type)
{
    switch (type) {
    case DP_MSG_INTERVAL:
    case DP_MSG_LASER_TRAIL:
    case DP_MSG_MOVE_POINTER:
    case DP_MSG_MARKER:
    case DP_MSG_USER_ACL:
    case DP_MSG_LAYER_ACL:
    case DP_MSG_FEATURE_ACCESS_LEVELS:
    case DP_MSG_DEFAULT_LAYER:
    case DP_MSG_FILTERED:
    case DP_MSG_EXTENSION:
        return true;
    default:
        return false;
    }
}

bool DP_message_type_command(DP_MessageType type)
{
    switch (type) {
    case DP_MSG_UNDO_POINT:
    case DP_MSG_CANVAS_RESIZE:
    case DP_MSG_LAYER_CREATE:
    case DP_MSG_LAYER_ATTRIBUTES:
    case DP_MSG_LAYER_RETITLE:
    case DP_MSG_LAYER_ORDER:
    case DP_MSG_LAYER_DELETE:
    case DP_MSG_LAYER_VISIBILITY:
    case DP_MSG_PUT_IMAGE:
    case DP_MSG_FILL_RECT:
    case DP_MSG_TOOL_CHANGE:
    case DP_MSG_PEN_MOVE:
    case DP_MSG_PEN_UP:
    case DP_MSG_ANNOTATION_CREATE:
    case DP_MSG_ANNOTATION_RESHAPE:
    case DP_MSG_ANNOTATION_EDIT:
    case DP_MSG_ANNOTATION_DELETE:
    case DP_MSG_MOVE_REGION:
    case DP_MSG_PUT_TILE:
    case DP_MSG_CANVAS_BACKGROUND:
    case DP_MSG_DRAW_DABS_CLASSIC:
    case DP_MSG_DRAW_DABS_PIXEL:
    case DP_MSG_DRAW_DABS_PIXEL_SQUARE:
    case DP_MSG_DRAW_DABS_MYPAINT:
    case DP_MSG_MOVE_RECT:
    case DP_MSG_SET_METADATA_INT:
    case DP_MSG_SET_METADATA_STR:
    case DP_MSG_SET_TIMELINE_FRAME:
    case DP_MSG_REMOVE_TIMELINE_FRAME:
    case DP_MSG_UNDO:
        return true;
    default:
        return false;
    }
}

const char *DP_message_type_name(DP_MessageType type)
{
    switch (type) {
    case DP_MSG_SERVER_COMMAND:
        return "servercommand";
    case DP_MSG_DISCONNECT:
        return "disconnect";
    case DP_MSG_PING:
        return "ping";
    case DP_MSG_INTERNAL:
        return "internal";
    case DP_MSG_JOIN:
        return "join";
    case DP_MSG_LEAVE:
        return "leave";
    case DP_MSG_SESSION_OWNER:
        return "sessionowner";
    case DP_MSG_CHAT:
        return "chat";
    case DP_MSG_TRUSTED_USERS:
        return "trusted";
    case DP_MSG_SOFT_RESET:
        return "softreset";
    case DP_MSG_PRIVATE_CHAT:
        return "privatechat";
    case DP_MSG_INTERVAL:
        return "interval";
    case DP_MSG_LASER_TRAIL:
        return "lasertrail";
    case DP_MSG_MOVE_POINTER:
        return "movepointer";
    case DP_MSG_MARKER:
        return "marker";
    case DP_MSG_USER_ACL:
        return "useracl";
    case DP_MSG_LAYER_ACL:
        return "layeracl";
    case DP_MSG_FEATURE_ACCESS_LEVELS:
        return "featureaccess";
    case DP_MSG_DEFAULT_LAYER:
        return "defaultlayer";
    case DP_MSG_FILTERED:
        return "filtered";
    case DP_MSG_EXTENSION:
        return "extension";
    case DP_MSG_UNDO_POINT:
        return "undopoint";
    case DP_MSG_CANVAS_RESIZE:
        return "resize";
    case DP_MSG_LAYER_CREATE:
        return "newlayer";
    case DP_MSG_LAYER_ATTRIBUTES:
        return "layerattr";
    case DP_MSG_LAYER_RETITLE:
        return "retitlelayer";
    case DP_MSG_LAYER_ORDER:
        return "layerorder";
    case DP_MSG_LAYER_DELETE:
        return "deletelayer";
    case DP_MSG_LAYER_VISIBILITY:
        return "layervisibility";
    case DP_MSG_PUT_IMAGE:
        return "putimage";
    case DP_MSG_FILL_RECT:
        return "fillrect";
    case DP_MSG_TOOL_CHANGE:
        return "toolchange";
    case DP_MSG_PEN_MOVE:
        return "penmove";
    case DP_MSG_PEN_UP:
        return "penup";
    case DP_MSG_ANNOTATION_CREATE:
        return "newannotation";
    case DP_MSG_ANNOTATION_RESHAPE:
        return "reshapeannotation";
    case DP_MSG_ANNOTATION_EDIT:
        return "editannotation";
    case DP_MSG_ANNOTATION_DELETE:
        return "deleteannotation";
    case DP_MSG_MOVE_REGION:
        return "moveregion";
    case DP_MSG_PUT_TILE:
        return "puttile";
    case DP_MSG_CANVAS_BACKGROUND:
        return "background";
    case DP_MSG_DRAW_DABS_CLASSIC:
        return "classicdabs";
    case DP_MSG_DRAW_DABS_PIXEL:
        return "pixeldabs";
    case DP_MSG_DRAW_DABS_PIXEL_SQUARE:
        return "squarepixeldabs";
    case DP_MSG_DRAW_DABS_MYPAINT:
        return "mypaintdabs";
    case DP_MSG_MOVE_RECT:
        return "moverect";
    case DP_MSG_SET_METADATA_INT:
        return "setmetadataint";
    case DP_MSG_SET_METADATA_STR:
        return "setmetadatastr";
    case DP_MSG_SET_TIMELINE_FRAME:
        return "settimelineframe";
    case DP_MSG_REMOVE_TIMELINE_FRAME:
        return "removetimelineframe";
    case DP_MSG_UNDO:
        return "undo";
    default:
        return "unknown";
    }
}

const char *DP_message_type_enum_name(DP_MessageType type)
{
    switch (type) {
    case DP_MSG_SERVER_COMMAND:
        return "DP_MSG_SERVER_COMMAND";
    case DP_MSG_DISCONNECT:
        return "DP_MSG_DISCONNECT";
    case DP_MSG_PING:
        return "DP_MSG_PING";
    case DP_MSG_INTERNAL:
        return "DP_MSG_INTERNAL";
    case DP_MSG_JOIN:
        return "DP_MSG_JOIN";
    case DP_MSG_LEAVE:
        return "DP_MSG_LEAVE";
    case DP_MSG_SESSION_OWNER:
        return "DP_MSG_SESSION_OWNER";
    case DP_MSG_CHAT:
        return "DP_MSG_CHAT";
    case DP_MSG_TRUSTED_USERS:
        return "DP_MSG_TRUSTED_USERS";
    case DP_MSG_SOFT_RESET:
        return "DP_MSG_SOFT_RESET";
    case DP_MSG_PRIVATE_CHAT:
        return "DP_MSG_PRIVATE_CHAT";
    case DP_MSG_INTERVAL:
        return "DP_MSG_INTERVAL";
    case DP_MSG_LASER_TRAIL:
        return "DP_MSG_LASER_TRAIL";
    case DP_MSG_MOVE_POINTER:
        return "DP_MSG_MOVE_POINTER";
    case DP_MSG_MARKER:
        return "DP_MSG_MARKER";
    case DP_MSG_USER_ACL:
        return "DP_MSG_USER_ACL";
    case DP_MSG_LAYER_ACL:
        return "DP_MSG_LAYER_ACL";
    case DP_MSG_FEATURE_ACCESS_LEVELS:
        return "DP_MSG_FEATURE_ACCESS_LEVELS";
    case DP_MSG_DEFAULT_LAYER:
        return "DP_MSG_DEFAULT_LAYER";
    case DP_MSG_FILTERED:
        return "DP_MSG_FILTERED";
    case DP_MSG_EXTENSION:
        return "DP_MSG_EXTENSION";
    case DP_MSG_UNDO_POINT:
        return "DP_MSG_UNDO_POINT";
    case DP_MSG_CANVAS_RESIZE:
        return "DP_MSG_CANVAS_RESIZE";
    case DP_MSG_LAYER_CREATE:
        return "DP_MSG_LAYER_CREATE";
    case DP_MSG_LAYER_ATTRIBUTES:
        return "DP_MSG_LAYER_ATTRIBUTES";
    case DP_MSG_LAYER_RETITLE:
        return "DP_MSG_LAYER_RETITLE";
    case DP_MSG_LAYER_ORDER:
        return "DP_MSG_LAYER_ORDER";
    case DP_MSG_LAYER_DELETE:
        return "DP_MSG_LAYER_DELETE";
    case DP_MSG_LAYER_VISIBILITY:
        return "DP_MSG_LAYER_VISIBILITY";
    case DP_MSG_PUT_IMAGE:
        return "DP_MSG_PUT_IMAGE";
    case DP_MSG_FILL_RECT:
        return "DP_MSG_FILL_RECT";
    case DP_MSG_TOOL_CHANGE:
        return "DP_MSG_TOOL_CHANGE";
    case DP_MSG_PEN_MOVE:
        return "DP_MSG_PEN_MOVE";
    case DP_MSG_PEN_UP:
        return "DP_MSG_PEN_UP";
    case DP_MSG_ANNOTATION_CREATE:
        return "DP_MSG_ANNOTATION_CREATE";
    case DP_MSG_ANNOTATION_RESHAPE:
        return "DP_MSG_ANNOTATION_RESHAPE";
    case DP_MSG_ANNOTATION_EDIT:
        return "DP_MSG_ANNOTATION_EDIT";
    case DP_MSG_ANNOTATION_DELETE:
        return "DP_MSG_ANNOTATION_DELETE";
    case DP_MSG_MOVE_REGION:
        return "DP_MSG_MOVE_REGION";
    case DP_MSG_PUT_TILE:
        return "DP_MSG_PUT_TILE";
    case DP_MSG_CANVAS_BACKGROUND:
        return "DP_MSG_CANVAS_BACKGROUND";
    case DP_MSG_DRAW_DABS_CLASSIC:
        return "DP_MSG_DRAW_DABS_CLASSIC";
    case DP_MSG_DRAW_DABS_PIXEL:
        return "DP_MSG_DRAW_DABS_PIXEL";
    case DP_MSG_DRAW_DABS_PIXEL_SQUARE:
        return "DP_MSG_DRAW_DABS_PIXEL_SQUARE";
    case DP_MSG_DRAW_DABS_MYPAINT:
        return "DP_MSG_DRAW_DABS_MYPAINT";
    case DP_MSG_MOVE_RECT:
        return "DP_MSG_MOVE_RECT";
    case DP_MSG_SET_METADATA_INT:
        return "DP_MSG_SET_METADATA_INT";
    case DP_MSG_SET_METADATA_STR:
        return "DP_MSG_SET_METADATA_STR";
    case DP_MSG_SET_TIMELINE_FRAME:
        return "DP_MSG_SET_TIMELINE_FRAME";
    case DP_MSG_REMOVE_TIMELINE_FRAME:
        return "DP_MSG_REMOVE_TIMELINE_FRAME";
    case DP_MSG_UNDO:
        return "DP_MSG_UNDO";
    default:
        return "DP_MSG_UNKNOWN";
    }
}

const char *DP_message_type_enum_name_unprefixed(DP_MessageType type)
{
    return DP_message_type_enum_name(type) + 7;
}


DP_Message *DP_message_deserialize_body(int type, unsigned int context_id,
                                        const unsigned char *buf, size_t length)
{
    switch (type) {
    case DP_MSG_SERVER_COMMAND:
        return DP_msg_server_command_deserialize(context_id, buf, length);
    case DP_MSG_DISCONNECT:
        return DP_msg_disconnect_deserialize(context_id, buf, length);
    case DP_MSG_PING:
        return DP_msg_ping_deserialize(context_id, buf, length);
    case DP_MSG_INTERNAL:
        DP_error_set(
            "Can't deserialize reserved message type 31 DP_MSG_INTERNAL");
        return NULL;
    case DP_MSG_JOIN:
        return DP_msg_join_deserialize(context_id, buf, length);
    case DP_MSG_LEAVE:
        return DP_msg_leave_deserialize(context_id, buf, length);
    case DP_MSG_SESSION_OWNER:
        return DP_msg_session_owner_deserialize(context_id, buf, length);
    case DP_MSG_CHAT:
        return DP_msg_chat_deserialize(context_id, buf, length);
    case DP_MSG_TRUSTED_USERS:
        return DP_msg_trusted_users_deserialize(context_id, buf, length);
    case DP_MSG_SOFT_RESET:
        return DP_msg_soft_reset_deserialize(context_id, buf, length);
    case DP_MSG_PRIVATE_CHAT:
        return DP_msg_private_chat_deserialize(context_id, buf, length);
    case DP_MSG_INTERVAL:
        return DP_msg_interval_deserialize(context_id, buf, length);
    case DP_MSG_LASER_TRAIL:
        return DP_msg_laser_trail_deserialize(context_id, buf, length);
    case DP_MSG_MOVE_POINTER:
        return DP_msg_move_pointer_deserialize(context_id, buf, length);
    case DP_MSG_MARKER:
        return DP_msg_marker_deserialize(context_id, buf, length);
    case DP_MSG_USER_ACL:
        return DP_msg_user_acl_deserialize(context_id, buf, length);
    case DP_MSG_LAYER_ACL:
        return DP_msg_layer_acl_deserialize(context_id, buf, length);
    case DP_MSG_FEATURE_ACCESS_LEVELS:
        return DP_msg_feature_access_levels_deserialize(context_id, buf,
                                                        length);
    case DP_MSG_DEFAULT_LAYER:
        return DP_msg_default_layer_deserialize(context_id, buf, length);
    case DP_MSG_FILTERED:
        return DP_msg_filtered_deserialize(context_id, buf, length);
    case DP_MSG_EXTENSION:
        DP_error_set(
            "Can't deserialize reserved message type 73 DP_MSG_EXTENSION");
        return NULL;
    case DP_MSG_UNDO_POINT:
        return DP_msg_undo_point_deserialize(context_id, buf, length);
    case DP_MSG_CANVAS_RESIZE:
        return DP_msg_canvas_resize_deserialize(context_id, buf, length);
    case DP_MSG_LAYER_CREATE:
        return DP_msg_layer_create_deserialize(context_id, buf, length);
    case DP_MSG_LAYER_ATTRIBUTES:
        return DP_msg_layer_attributes_deserialize(context_id, buf, length);
    case DP_MSG_LAYER_RETITLE:
        return DP_msg_layer_retitle_deserialize(context_id, buf, length);
    case DP_MSG_LAYER_ORDER:
        return DP_msg_layer_order_deserialize(context_id, buf, length);
    case DP_MSG_LAYER_DELETE:
        return DP_msg_layer_delete_deserialize(context_id, buf, length);
    case DP_MSG_LAYER_VISIBILITY:
        return DP_msg_layer_visibility_deserialize(context_id, buf, length);
    case DP_MSG_PUT_IMAGE:
        return DP_msg_put_image_deserialize(context_id, buf, length);
    case DP_MSG_FILL_RECT:
        return DP_msg_fill_rect_deserialize(context_id, buf, length);
    case DP_MSG_TOOL_CHANGE:
        DP_error_set(
            "Can't deserialize reserved message type 138 DP_MSG_TOOL_CHANGE");
        return NULL;
    case DP_MSG_PEN_MOVE:
        DP_error_set(
            "Can't deserialize reserved message type 139 DP_MSG_PEN_MOVE");
        return NULL;
    case DP_MSG_PEN_UP:
        return DP_msg_pen_up_deserialize(context_id, buf, length);
    case DP_MSG_ANNOTATION_CREATE:
        return DP_msg_annotation_create_deserialize(context_id, buf, length);
    case DP_MSG_ANNOTATION_RESHAPE:
        return DP_msg_annotation_reshape_deserialize(context_id, buf, length);
    case DP_MSG_ANNOTATION_EDIT:
        return DP_msg_annotation_edit_deserialize(context_id, buf, length);
    case DP_MSG_ANNOTATION_DELETE:
        return DP_msg_annotation_delete_deserialize(context_id, buf, length);
    case DP_MSG_MOVE_REGION:
        return DP_msg_move_region_deserialize(context_id, buf, length);
    case DP_MSG_PUT_TILE:
        return DP_msg_put_tile_deserialize(context_id, buf, length);
    case DP_MSG_CANVAS_BACKGROUND:
        return DP_msg_canvas_background_deserialize(context_id, buf, length);
    case DP_MSG_DRAW_DABS_CLASSIC:
        return DP_msg_draw_dabs_classic_deserialize(context_id, buf, length);
    case DP_MSG_DRAW_DABS_PIXEL:
        return DP_msg_draw_dabs_pixel_deserialize(context_id, buf, length);
    case DP_MSG_DRAW_DABS_PIXEL_SQUARE:
        return DP_msg_draw_dabs_pixel_square_deserialize(context_id, buf,
                                                         length);
    case DP_MSG_DRAW_DABS_MYPAINT:
        return DP_msg_draw_dabs_mypaint_deserialize(context_id, buf, length);
    case DP_MSG_MOVE_RECT:
        return DP_msg_move_rect_deserialize(context_id, buf, length);
    case DP_MSG_SET_METADATA_INT:
        return DP_msg_set_metadata_int_deserialize(context_id, buf, length);
    case DP_MSG_SET_METADATA_STR:
        return DP_msg_set_metadata_str_deserialize(context_id, buf, length);
    case DP_MSG_SET_TIMELINE_FRAME:
        return DP_msg_set_timeline_frame_deserialize(context_id, buf, length);
    case DP_MSG_REMOVE_TIMELINE_FRAME:
        return DP_msg_remove_timeline_frame_deserialize(context_id, buf,
                                                        length);
    case DP_MSG_UNDO:
        return DP_msg_undo_deserialize(context_id, buf, length);
    default:
        DP_error_set("Can't deserialize unknown message type %d", type);
        return NULL;
    }
}


static size_t zero_length_payload_length(DP_UNUSED DP_Message *msg)
{
    return 0;
}

static size_t zero_length_serialize_payload(DP_UNUSED DP_Message *msg,
                                            DP_UNUSED unsigned char *data)
{
    return 0;
}

static bool zero_length_write_payload_text(DP_UNUSED DP_Message *msg,
                                           DP_UNUSED DP_TextWriter *writer)
{
    return true;
}

static bool zero_length_equals(DP_UNUSED DP_Message *DP_RESTRICT msg,
                               DP_UNUSED DP_Message *DP_RESTRICT other)
{
    return true;
}

static const DP_MessageMethods zero_length_methods = {
    zero_length_payload_length,
    zero_length_serialize_payload,
    zero_length_write_payload_text,
    zero_length_equals,
};


static void assign_string(char *dst, const char *src, size_t len)
{
    memcpy(dst, src, len);
    dst[len] = '\0';
}

static int8_t read_int8(const unsigned char *buffer, size_t *read)
{
    *read += 1;
    return DP_read_bigendian_int8(buffer);
}

static int32_t read_int32(const unsigned char *buffer, size_t *read)
{
    *read += 4;
    return DP_read_bigendian_int32(buffer);
}

static uint8_t read_uint8(const unsigned char *buffer, size_t *read)
{
    *read += 1;
    return DP_read_bigendian_uint8(buffer);
}

static uint16_t read_uint16(const unsigned char *buffer, size_t *read)
{
    *read += 2;
    return DP_read_bigendian_uint16(buffer);
}

static uint32_t read_uint32(const unsigned char *buffer, size_t *read)
{
    *read += 4;
    return DP_read_bigendian_uint32(buffer);
}

static bool read_bool(const unsigned char *buffer, size_t *read)
{
    return read_uint8(buffer, read) != 0;
}

static const char *read_string_with_length(const unsigned char *buffer,
                                           size_t len, size_t *read)
{
    *read += len;
    return (const char *)buffer;
}

static void read_bytes(size_t count, unsigned char *out, void *user)
{
    const unsigned char *buffer = user;
    memcpy(out, buffer, count);
}

static void read_uint8_array(int count, uint8_t *out, void *user)
{
    const unsigned char *buffer = user;
    memcpy(out, buffer, DP_int_to_size(count));
}

static void read_uint16_array(int count, uint16_t *out, void *user)
{
    const unsigned char *buffer = user;
#if defined(DP_BYTE_ORDER_LITTLE_ENDIAN)
    for (int i = 0; i < count; ++i) {
        out[i] = DP_read_bigendian_uint16(buffer + i * 2);
    }
#elif defined(DP_BYTE_ORDER_BIG_ENDIAN)
    memcpy(out, buffer, DP_int_to_size(count) * 2);
#else
#    error "Unknown byte order"
#endif
}

static size_t write_bytes(const unsigned char *DP_RESTRICT x, int count,
                          unsigned char *DP_RESTRICT out)
{
    return DP_write_bytes(x, count, 1, out);
}

static size_t write_string_with_length(const char *DP_RESTRICT x, size_t len,
                                       unsigned char *DP_RESTRICT out)
{
    size_t written = DP_write_bigendian_uint8(DP_size_to_uint8(len), out);
    return written + DP_write_bytes(x, 1, len, out + written);
}


/* DP_MSG_SERVER_COMMAND */

struct DP_MsgServerCommand {
    uint16_t msg_len;
    char msg[];
};

static size_t msg_server_command_payload_length(DP_Message *msg)
{
    DP_MsgServerCommand *msc = DP_message_internal(msg);
    return DP_uint16_to_size(msc->msg_len);
}

static size_t msg_server_command_serialize_payload(DP_Message *msg,
                                                   unsigned char *data)
{
    DP_MsgServerCommand *msc = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bytes(msc->msg, 1, msc->msg_len, data + written);
    DP_ASSERT(written == msg_server_command_payload_length(msg));
    return written;
}

static bool msg_server_command_write_payload_text(DP_Message *msg,
                                                  DP_TextWriter *writer)
{
    DP_MsgServerCommand *msc = DP_message_internal(msg);
    return DP_text_writer_write_string(writer, "msg", msc->msg);
}

static bool msg_server_command_equals(DP_Message *DP_RESTRICT msg,
                                      DP_Message *DP_RESTRICT other)
{
    DP_MsgServerCommand *a = DP_message_internal(msg);
    DP_MsgServerCommand *b = DP_message_internal(other);
    return a->msg_len == b->msg_len && memcmp(a->msg, b->msg, a->msg_len) == 0;
}

static const DP_MessageMethods msg_server_command_methods = {
    msg_server_command_payload_length,
    msg_server_command_serialize_payload,
    msg_server_command_write_payload_text,
    msg_server_command_equals,
};

DP_Message *DP_msg_server_command_new(unsigned int context_id,
                                      const char *msg_value, size_t msg_len)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_SERVER_COMMAND, context_id, &msg_server_command_methods,
        DP_FLEX_SIZEOF(DP_MsgServerCommand, msg, msg_len + 1));
    DP_MsgServerCommand *msc = DP_message_internal(msg);
    msc->msg_len = DP_size_to_uint16(msg_len);
    assign_string(msc->msg, msg_value, msc->msg_len);
    return msg;
}

DP_Message *DP_msg_server_command_deserialize(unsigned int context_id,
                                              const unsigned char *buffer,
                                              size_t length)
{
    if (length > 65535) {
        DP_error_set("Wrong length for servercommand message; "
                     "expected between 0 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    size_t msg_bytes = length - read;
    uint16_t msg_len = DP_size_to_uint16(msg_bytes);
    const char *msg = (const char *)buffer + read;
    return DP_msg_server_command_new(context_id, msg, msg_len);
}

DP_MsgServerCommand *DP_msg_server_command_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_SERVER_COMMAND);
}

const char *DP_msg_server_command_msg(const DP_MsgServerCommand *msc,
                                      size_t *out_len)
{
    DP_ASSERT(msc);
    if (out_len) {
        *out_len = msc->msg_len;
    }
    return msc->msg;
}

size_t DP_msg_server_command_msg_len(const DP_MsgServerCommand *msc)
{
    return msc->msg_len;
}


/* DP_MSG_DISCONNECT */

struct DP_MsgDisconnect {
    uint8_t reason;
    uint16_t message_len;
    char message[];
};

static size_t msg_disconnect_payload_length(DP_Message *msg)
{
    DP_MsgDisconnect *md = DP_message_internal(msg);
    return ((size_t)1) + DP_uint16_to_size(md->message_len);
}

static size_t msg_disconnect_serialize_payload(DP_Message *msg,
                                               unsigned char *data)
{
    DP_MsgDisconnect *md = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint8(md->reason, data + written);
    written += DP_write_bytes(md->message, 1, md->message_len, data + written);
    DP_ASSERT(written == msg_disconnect_payload_length(msg));
    return written;
}

static bool msg_disconnect_write_payload_text(DP_Message *msg,
                                              DP_TextWriter *writer)
{
    DP_MsgDisconnect *md = DP_message_internal(msg);
    return DP_text_writer_write_string(writer, "message", md->message)
        && DP_text_writer_write_uint(writer, "reason", md->reason, false);
}

static bool msg_disconnect_equals(DP_Message *DP_RESTRICT msg,
                                  DP_Message *DP_RESTRICT other)
{
    DP_MsgDisconnect *a = DP_message_internal(msg);
    DP_MsgDisconnect *b = DP_message_internal(other);
    return a->reason == b->reason && a->message_len == b->message_len
        && memcmp(a->message, b->message, a->message_len) == 0;
}

static const DP_MessageMethods msg_disconnect_methods = {
    msg_disconnect_payload_length,
    msg_disconnect_serialize_payload,
    msg_disconnect_write_payload_text,
    msg_disconnect_equals,
};

DP_Message *DP_msg_disconnect_new(unsigned int context_id, uint8_t reason,
                                  const char *message_value, size_t message_len)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_DISCONNECT, context_id, &msg_disconnect_methods,
        DP_FLEX_SIZEOF(DP_MsgDisconnect, message, message_len + 1));
    DP_MsgDisconnect *md = DP_message_internal(msg);
    md->reason = reason;
    md->message_len = DP_size_to_uint16(message_len);
    assign_string(md->message, message_value, md->message_len);
    return msg;
}

DP_Message *DP_msg_disconnect_deserialize(unsigned int context_id,
                                          const unsigned char *buffer,
                                          size_t length)
{
    if (length < 1 || length > 65535) {
        DP_error_set("Wrong length for disconnect message; "
                     "expected between 1 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint8_t reason = read_uint8(buffer + read, &read);
    size_t message_bytes = length - read;
    uint16_t message_len = DP_size_to_uint16(message_bytes);
    const char *message = (const char *)buffer + read;
    return DP_msg_disconnect_new(context_id, reason, message, message_len);
}

DP_MsgDisconnect *DP_msg_disconnect_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_DISCONNECT);
}

uint8_t DP_msg_disconnect_reason(const DP_MsgDisconnect *md)
{
    DP_ASSERT(md);
    return md->reason;
}

const char *DP_msg_disconnect_message(const DP_MsgDisconnect *md,
                                      size_t *out_len)
{
    DP_ASSERT(md);
    if (out_len) {
        *out_len = md->message_len;
    }
    return md->message;
}

size_t DP_msg_disconnect_message_len(const DP_MsgDisconnect *md)
{
    return md->message_len;
}


/* DP_MSG_PING */

struct DP_MsgPing {
    bool is_pong;
};

static size_t msg_ping_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)1);
}

static size_t msg_ping_serialize_payload(DP_Message *msg, unsigned char *data)
{
    DP_MsgPing *mp = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint8(mp->is_pong, data + written);
    DP_ASSERT(written == msg_ping_payload_length(msg));
    return written;
}

static bool msg_ping_write_payload_text(DP_Message *msg, DP_TextWriter *writer)
{
    DP_MsgPing *mp = DP_message_internal(msg);
    return DP_text_writer_write_bool(writer, "is_pong", mp->is_pong);
}

static bool msg_ping_equals(DP_Message *DP_RESTRICT msg,
                            DP_Message *DP_RESTRICT other)
{
    DP_MsgPing *a = DP_message_internal(msg);
    DP_MsgPing *b = DP_message_internal(other);
    return a->is_pong == b->is_pong;
}

static const DP_MessageMethods msg_ping_methods = {
    msg_ping_payload_length,
    msg_ping_serialize_payload,
    msg_ping_write_payload_text,
    msg_ping_equals,
};

DP_Message *DP_msg_ping_new(unsigned int context_id, bool is_pong)
{
    DP_Message *msg = DP_message_new(DP_MSG_PING, context_id, &msg_ping_methods,
                                     sizeof(DP_MsgPing));
    DP_MsgPing *mp = DP_message_internal(msg);
    mp->is_pong = is_pong;
    return msg;
}

DP_Message *DP_msg_ping_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length)
{
    if (length != 1) {
        DP_error_set("Wrong length for ping message; "
                     "expected 1, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    bool is_pong = read_bool(buffer + read, &read);
    return DP_msg_ping_new(context_id, is_pong);
}

DP_MsgPing *DP_msg_ping_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_PING);
}

bool DP_msg_ping_is_pong(const DP_MsgPing *mp)
{
    DP_ASSERT(mp);
    return mp->is_pong;
}


/* DP_MSG_JOIN */

const char *DP_msg_join_flags_flag_name(unsigned int value)
{
    switch (value) {
    case DP_MSG_JOIN_FLAGS_AUTH:
        return "auth";
    case DP_MSG_JOIN_FLAGS_MOD:
        return "mod";
    case DP_MSG_JOIN_FLAGS_BOT:
        return "bot";
    default:
        return NULL;
    }
}

struct DP_MsgJoin {
    uint8_t flags;
    uint16_t name_len;
    uint16_t avatar_size;
    unsigned char name_avatar[];
};

static size_t msg_join_payload_length(DP_Message *msg)
{
    DP_MsgJoin *mj = DP_message_internal(msg);
    return ((size_t)2) + DP_uint16_to_size(mj->name_len) + mj->avatar_size;
}

static size_t msg_join_serialize_payload(DP_Message *msg, unsigned char *data)
{
    DP_MsgJoin *mj = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint8(mj->flags, data + written);
    written += write_string_with_length(((char *)mj->name_avatar), mj->name_len,
                                        data + written);
    written += write_bytes(mj->name_avatar + mj->name_len + 1, mj->avatar_size,
                           data + written);
    DP_ASSERT(written == msg_join_payload_length(msg));
    return written;
}

static bool msg_join_write_payload_text(DP_Message *msg, DP_TextWriter *writer)
{
    DP_MsgJoin *mj = DP_message_internal(msg);
    return DP_text_writer_write_base64(writer, "avatar",
                                       mj->name_avatar + mj->name_len + 1,
                                       mj->avatar_size)
        && DP_text_writer_write_flags(writer, "flags", mj->flags, 3,
                                      (const char *[]){"auth", "mod", "bot"},
                                      (unsigned int[]){DP_MSG_JOIN_FLAGS_AUTH,
                                                       DP_MSG_JOIN_FLAGS_MOD,
                                                       DP_MSG_JOIN_FLAGS_BOT})
        && DP_text_writer_write_string(writer, "name",
                                       ((char *)mj->name_avatar));
}

static bool msg_join_equals(DP_Message *DP_RESTRICT msg,
                            DP_Message *DP_RESTRICT other)
{
    DP_MsgJoin *a = DP_message_internal(msg);
    DP_MsgJoin *b = DP_message_internal(other);
    return a->flags == b->flags && a->name_len == b->name_len
        && memcmp(((char *)a->name_avatar), ((char *)b->name_avatar),
                  a->name_len)
               == 0
        && a->avatar_size == b->avatar_size
        && memcmp(a->name_avatar + a->name_len + 1,
                  b->name_avatar + b->name_len + 1,
                  DP_uint16_to_size(a->avatar_size))
               == 0;
}

static const DP_MessageMethods msg_join_methods = {
    msg_join_payload_length,
    msg_join_serialize_payload,
    msg_join_write_payload_text,
    msg_join_equals,
};

DP_Message *DP_msg_join_new(unsigned int context_id, uint8_t flags,
                            const char *name_value, size_t name_len,
                            void (*set_avatar)(size_t, unsigned char *, void *),
                            size_t avatar_size, void *avatar_user)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_JOIN, context_id, &msg_join_methods,
        DP_FLEX_SIZEOF(DP_MsgJoin, name_avatar, name_len + 1 + avatar_size));
    DP_MsgJoin *mj = DP_message_internal(msg);
    mj->flags = flags;
    mj->name_len = DP_size_to_uint16(name_len);
    assign_string(((char *)mj->name_avatar), name_value, mj->name_len);
    mj->avatar_size = DP_size_to_uint16(avatar_size);
    if (set_avatar) {
        set_avatar(mj->avatar_size, mj->name_avatar + mj->name_len + 1,
                   avatar_user);
    }
    return msg;
}

DP_Message *DP_msg_join_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length)
{
    if (length < 2 || length > 65535) {
        DP_error_set("Wrong length for join message; "
                     "expected between 2 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint8_t flags = read_uint8(buffer + read, &read);
    size_t name_bytes = read_uint8(buffer + read, &read);
    if (read + name_bytes > length) {
        DP_error_set("Wrong length for name field in join message; "
                     "field length %zu exceeds total length %zu",
                     name_bytes, length);
        return NULL;
    }
    uint16_t name_len = DP_size_to_uint16(name_bytes);
    const char *name = read_string_with_length(buffer + read, name_len, &read);
    size_t avatar_bytes = length - read;
    uint16_t avatar_size = DP_size_to_uint16(avatar_bytes);
    void *avatar_user = (void *)(buffer + read);
    return DP_msg_join_new(context_id, flags, name, name_len, read_bytes,
                           avatar_size, avatar_user);
}

DP_MsgJoin *DP_msg_join_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_JOIN);
}

uint8_t DP_msg_join_flags(const DP_MsgJoin *mj)
{
    DP_ASSERT(mj);
    return mj->flags;
}

const char *DP_msg_join_name(const DP_MsgJoin *mj, size_t *out_len)
{
    DP_ASSERT(mj);
    if (out_len) {
        *out_len = mj->name_len;
    }
    return ((char *)mj->name_avatar);
}

size_t DP_msg_join_name_len(const DP_MsgJoin *mj)
{
    return mj->name_len;
}

const unsigned char *DP_msg_join_avatar(const DP_MsgJoin *mj, size_t *out_size)
{
    DP_ASSERT(mj);
    if (out_size) {
        *out_size = mj->avatar_size;
    }
    return mj->name_avatar + mj->name_len + 1;
}

size_t DP_msg_join_avatar_size(const DP_MsgJoin *mj)
{
    return mj->avatar_size;
}


/* DP_MSG_LEAVE */

DP_Message *DP_msg_leave_new(unsigned int context_id)
{
    return DP_message_new(DP_MSG_LEAVE, context_id, &zero_length_methods, 0);
}

DP_Message *DP_msg_leave_deserialize(unsigned int context_id,
                                     DP_UNUSED const unsigned char *buffer,
                                     size_t length)
{
    if (length != 0) {
        DP_error_set("Wrong length for leave message; "
                     "expected 0, got %zu",
                     length);
        return NULL;
    }
    return DP_msg_leave_new(context_id);
}


/* DP_MSG_SESSION_OWNER */

struct DP_MsgSessionOwner {
    uint16_t users_count;
    uint8_t users[];
};

static size_t msg_session_owner_payload_length(DP_Message *msg)
{
    DP_MsgSessionOwner *mso = DP_message_internal(msg);
    return DP_int_to_size(mso->users_count);
}

static size_t msg_session_owner_serialize_payload(DP_Message *msg,
                                                  unsigned char *data)
{
    DP_MsgSessionOwner *mso = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint8_array(mso->users, mso->users_count,
                                              data + written);
    DP_ASSERT(written == msg_session_owner_payload_length(msg));
    return written;
}

static bool msg_session_owner_write_payload_text(DP_Message *msg,
                                                 DP_TextWriter *writer)
{
    DP_MsgSessionOwner *mso = DP_message_internal(msg);
    return DP_text_writer_write_uint8_list(writer, "users", mso->users,
                                           mso->users_count);
}

static bool msg_session_owner_equals(DP_Message *DP_RESTRICT msg,
                                     DP_Message *DP_RESTRICT other)
{
    DP_MsgSessionOwner *a = DP_message_internal(msg);
    DP_MsgSessionOwner *b = DP_message_internal(other);
    return a->users_count == b->users_count
        && memcmp(a->users, b->users, DP_uint16_to_size(a->users_count)) == 0;
}

static const DP_MessageMethods msg_session_owner_methods = {
    msg_session_owner_payload_length,
    msg_session_owner_serialize_payload,
    msg_session_owner_write_payload_text,
    msg_session_owner_equals,
};

DP_Message *DP_msg_session_owner_new(unsigned int context_id,
                                     void (*set_users)(int, uint8_t *, void *),
                                     int users_count, void *users_user)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_SESSION_OWNER, context_id, &msg_session_owner_methods,
        DP_FLEX_SIZEOF(DP_MsgSessionOwner, users, DP_int_to_size(users_count)));
    DP_MsgSessionOwner *mso = DP_message_internal(msg);
    mso->users_count = DP_int_to_uint16(users_count);
    if (set_users) {
        set_users(mso->users_count, mso->users, users_user);
    }
    return msg;
}

DP_Message *DP_msg_session_owner_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length)
{
    if (length > 255) {
        DP_error_set("Wrong length for sessionowner message; "
                     "expected between 0 and 255, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    size_t users_bytes = length - read;
    uint16_t users_count = DP_size_to_uint16(users_bytes);
    void *users_user = (void *)(buffer + read);
    return DP_msg_session_owner_new(context_id, read_uint8_array, users_count,
                                    users_user);
}

DP_MsgSessionOwner *DP_msg_session_owner_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_SESSION_OWNER);
}

const uint8_t *DP_msg_session_owner_users(const DP_MsgSessionOwner *mso,
                                          int *out_count)
{
    DP_ASSERT(mso);
    if (out_count) {
        *out_count = mso->users_count;
    }
    return mso->users;
}

int DP_msg_session_owner_users_count(const DP_MsgSessionOwner *mso)
{
    return mso->users_count;
}


/* DP_MSG_CHAT */

const char *DP_msg_chat_tflags_flag_name(unsigned int value)
{
    switch (value) {
    case DP_MSG_CHAT_TFLAGS_BYPASS:
        return "bypass";
    default:
        return NULL;
    }
}

const char *DP_msg_chat_oflags_flag_name(unsigned int value)
{
    switch (value) {
    case DP_MSG_CHAT_OFLAGS_SHOUT:
        return "shout";
    case DP_MSG_CHAT_OFLAGS_ACTION:
        return "action";
    case DP_MSG_CHAT_OFLAGS_PIN:
        return "pin";
    case DP_MSG_CHAT_OFLAGS_ALERT:
        return "alert";
    default:
        return NULL;
    }
}

struct DP_MsgChat {
    uint8_t tflags;
    uint8_t oflags;
    uint16_t message_len;
    char message[];
};

static size_t msg_chat_payload_length(DP_Message *msg)
{
    DP_MsgChat *mc = DP_message_internal(msg);
    return ((size_t)2) + DP_uint16_to_size(mc->message_len);
}

static size_t msg_chat_serialize_payload(DP_Message *msg, unsigned char *data)
{
    DP_MsgChat *mc = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint8(mc->tflags, data + written);
    written += DP_write_bigendian_uint8(mc->oflags, data + written);
    written += DP_write_bytes(mc->message, 1, mc->message_len, data + written);
    DP_ASSERT(written == msg_chat_payload_length(msg));
    return written;
}

static bool msg_chat_write_payload_text(DP_Message *msg, DP_TextWriter *writer)
{
    DP_MsgChat *mc = DP_message_internal(msg);
    return DP_text_writer_write_string(writer, "message", mc->message)
        && DP_text_writer_write_flags(
               writer, "oflags", mc->oflags, 4,
               (const char *[]){"shout", "action", "pin", "alert"},
               (unsigned int[]){
                   DP_MSG_CHAT_OFLAGS_SHOUT, DP_MSG_CHAT_OFLAGS_ACTION,
                   DP_MSG_CHAT_OFLAGS_PIN, DP_MSG_CHAT_OFLAGS_ALERT})
        && DP_text_writer_write_flags(
               writer, "tflags", mc->tflags, 1, (const char *[]){"bypass"},
               (unsigned int[]){DP_MSG_CHAT_TFLAGS_BYPASS});
}

static bool msg_chat_equals(DP_Message *DP_RESTRICT msg,
                            DP_Message *DP_RESTRICT other)
{
    DP_MsgChat *a = DP_message_internal(msg);
    DP_MsgChat *b = DP_message_internal(other);
    return a->tflags == b->tflags && a->oflags == b->oflags
        && a->message_len == b->message_len
        && memcmp(a->message, b->message, a->message_len) == 0;
}

static const DP_MessageMethods msg_chat_methods = {
    msg_chat_payload_length,
    msg_chat_serialize_payload,
    msg_chat_write_payload_text,
    msg_chat_equals,
};

DP_Message *DP_msg_chat_new(unsigned int context_id, uint8_t tflags,
                            uint8_t oflags, const char *message_value,
                            size_t message_len)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_CHAT, context_id, &msg_chat_methods,
                       DP_FLEX_SIZEOF(DP_MsgChat, message, message_len + 1));
    DP_MsgChat *mc = DP_message_internal(msg);
    mc->tflags = tflags;
    mc->oflags = oflags;
    mc->message_len = DP_size_to_uint16(message_len);
    assign_string(mc->message, message_value, mc->message_len);
    return msg;
}

DP_Message *DP_msg_chat_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length)
{
    if (length < 2 || length > 65535) {
        DP_error_set("Wrong length for chat message; "
                     "expected between 2 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint8_t tflags = read_uint8(buffer + read, &read);
    uint8_t oflags = read_uint8(buffer + read, &read);
    size_t message_bytes = length - read;
    uint16_t message_len = DP_size_to_uint16(message_bytes);
    const char *message = (const char *)buffer + read;
    return DP_msg_chat_new(context_id, tflags, oflags, message, message_len);
}

DP_MsgChat *DP_msg_chat_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_CHAT);
}

uint8_t DP_msg_chat_tflags(const DP_MsgChat *mc)
{
    DP_ASSERT(mc);
    return mc->tflags;
}

uint8_t DP_msg_chat_oflags(const DP_MsgChat *mc)
{
    DP_ASSERT(mc);
    return mc->oflags;
}

const char *DP_msg_chat_message(const DP_MsgChat *mc, size_t *out_len)
{
    DP_ASSERT(mc);
    if (out_len) {
        *out_len = mc->message_len;
    }
    return mc->message;
}

size_t DP_msg_chat_message_len(const DP_MsgChat *mc)
{
    return mc->message_len;
}


/* DP_MSG_TRUSTED_USERS */

struct DP_MsgTrustedUsers {
    uint16_t users_count;
    uint8_t users[];
};

static size_t msg_trusted_users_payload_length(DP_Message *msg)
{
    DP_MsgTrustedUsers *mtu = DP_message_internal(msg);
    return DP_int_to_size(mtu->users_count);
}

static size_t msg_trusted_users_serialize_payload(DP_Message *msg,
                                                  unsigned char *data)
{
    DP_MsgTrustedUsers *mtu = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint8_array(mtu->users, mtu->users_count,
                                              data + written);
    DP_ASSERT(written == msg_trusted_users_payload_length(msg));
    return written;
}

static bool msg_trusted_users_write_payload_text(DP_Message *msg,
                                                 DP_TextWriter *writer)
{
    DP_MsgTrustedUsers *mtu = DP_message_internal(msg);
    return DP_text_writer_write_uint8_list(writer, "users", mtu->users,
                                           mtu->users_count);
}

static bool msg_trusted_users_equals(DP_Message *DP_RESTRICT msg,
                                     DP_Message *DP_RESTRICT other)
{
    DP_MsgTrustedUsers *a = DP_message_internal(msg);
    DP_MsgTrustedUsers *b = DP_message_internal(other);
    return a->users_count == b->users_count
        && memcmp(a->users, b->users, DP_uint16_to_size(a->users_count)) == 0;
}

static const DP_MessageMethods msg_trusted_users_methods = {
    msg_trusted_users_payload_length,
    msg_trusted_users_serialize_payload,
    msg_trusted_users_write_payload_text,
    msg_trusted_users_equals,
};

DP_Message *DP_msg_trusted_users_new(unsigned int context_id,
                                     void (*set_users)(int, uint8_t *, void *),
                                     int users_count, void *users_user)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_TRUSTED_USERS, context_id, &msg_trusted_users_methods,
        DP_FLEX_SIZEOF(DP_MsgTrustedUsers, users, DP_int_to_size(users_count)));
    DP_MsgTrustedUsers *mtu = DP_message_internal(msg);
    mtu->users_count = DP_int_to_uint16(users_count);
    if (set_users) {
        set_users(mtu->users_count, mtu->users, users_user);
    }
    return msg;
}

DP_Message *DP_msg_trusted_users_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length)
{
    if (length > 255) {
        DP_error_set("Wrong length for trusted message; "
                     "expected between 0 and 255, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    size_t users_bytes = length - read;
    uint16_t users_count = DP_size_to_uint16(users_bytes);
    void *users_user = (void *)(buffer + read);
    return DP_msg_trusted_users_new(context_id, read_uint8_array, users_count,
                                    users_user);
}

DP_MsgTrustedUsers *DP_msg_trusted_users_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_TRUSTED_USERS);
}

const uint8_t *DP_msg_trusted_users_users(const DP_MsgTrustedUsers *mtu,
                                          int *out_count)
{
    DP_ASSERT(mtu);
    if (out_count) {
        *out_count = mtu->users_count;
    }
    return mtu->users;
}

int DP_msg_trusted_users_users_count(const DP_MsgTrustedUsers *mtu)
{
    return mtu->users_count;
}


/* DP_MSG_SOFT_RESET */

DP_Message *DP_msg_soft_reset_new(unsigned int context_id)
{
    return DP_message_new(DP_MSG_SOFT_RESET, context_id, &zero_length_methods,
                          0);
}

DP_Message *DP_msg_soft_reset_deserialize(unsigned int context_id,
                                          DP_UNUSED const unsigned char *buffer,
                                          size_t length)
{
    if (length != 0) {
        DP_error_set("Wrong length for softreset message; "
                     "expected 0, got %zu",
                     length);
        return NULL;
    }
    return DP_msg_soft_reset_new(context_id);
}


/* DP_MSG_PRIVATE_CHAT */

struct DP_MsgPrivateChat {
    uint8_t target;
    uint8_t oflags;
    uint16_t message_len;
    char message[];
};

static size_t msg_private_chat_payload_length(DP_Message *msg)
{
    DP_MsgPrivateChat *mpc = DP_message_internal(msg);
    return ((size_t)2) + DP_uint16_to_size(mpc->message_len);
}

static size_t msg_private_chat_serialize_payload(DP_Message *msg,
                                                 unsigned char *data)
{
    DP_MsgPrivateChat *mpc = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint8(mpc->target, data + written);
    written += DP_write_bigendian_uint8(mpc->oflags, data + written);
    written +=
        DP_write_bytes(mpc->message, 1, mpc->message_len, data + written);
    DP_ASSERT(written == msg_private_chat_payload_length(msg));
    return written;
}

static bool msg_private_chat_write_payload_text(DP_Message *msg,
                                                DP_TextWriter *writer)
{
    DP_MsgPrivateChat *mpc = DP_message_internal(msg);
    return DP_text_writer_write_string(writer, "message", mpc->message)
        && DP_text_writer_write_uint(writer, "oflags", mpc->oflags, false)
        && DP_text_writer_write_uint(writer, "target", mpc->target, false);
}

static bool msg_private_chat_equals(DP_Message *DP_RESTRICT msg,
                                    DP_Message *DP_RESTRICT other)
{
    DP_MsgPrivateChat *a = DP_message_internal(msg);
    DP_MsgPrivateChat *b = DP_message_internal(other);
    return a->target == b->target && a->oflags == b->oflags
        && a->message_len == b->message_len
        && memcmp(a->message, b->message, a->message_len) == 0;
}

static const DP_MessageMethods msg_private_chat_methods = {
    msg_private_chat_payload_length,
    msg_private_chat_serialize_payload,
    msg_private_chat_write_payload_text,
    msg_private_chat_equals,
};

DP_Message *DP_msg_private_chat_new(unsigned int context_id, uint8_t target,
                                    uint8_t oflags, const char *message_value,
                                    size_t message_len)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_PRIVATE_CHAT, context_id, &msg_private_chat_methods,
        DP_FLEX_SIZEOF(DP_MsgPrivateChat, message, message_len + 1));
    DP_MsgPrivateChat *mpc = DP_message_internal(msg);
    mpc->target = target;
    mpc->oflags = oflags;
    mpc->message_len = DP_size_to_uint16(message_len);
    assign_string(mpc->message, message_value, mpc->message_len);
    return msg;
}

DP_Message *DP_msg_private_chat_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length)
{
    if (length < 2 || length > 65535) {
        DP_error_set("Wrong length for privatechat message; "
                     "expected between 2 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint8_t target = read_uint8(buffer + read, &read);
    uint8_t oflags = read_uint8(buffer + read, &read);
    size_t message_bytes = length - read;
    uint16_t message_len = DP_size_to_uint16(message_bytes);
    const char *message = (const char *)buffer + read;
    return DP_msg_private_chat_new(context_id, target, oflags, message,
                                   message_len);
}

DP_MsgPrivateChat *DP_msg_private_chat_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_PRIVATE_CHAT);
}

uint8_t DP_msg_private_chat_target(const DP_MsgPrivateChat *mpc)
{
    DP_ASSERT(mpc);
    return mpc->target;
}

uint8_t DP_msg_private_chat_oflags(const DP_MsgPrivateChat *mpc)
{
    DP_ASSERT(mpc);
    return mpc->oflags;
}

const char *DP_msg_private_chat_message(const DP_MsgPrivateChat *mpc,
                                        size_t *out_len)
{
    DP_ASSERT(mpc);
    if (out_len) {
        *out_len = mpc->message_len;
    }
    return mpc->message;
}

size_t DP_msg_private_chat_message_len(const DP_MsgPrivateChat *mpc)
{
    return mpc->message_len;
}


/* DP_MSG_INTERVAL */

struct DP_MsgInterval {
    uint16_t msecs;
};

static size_t msg_interval_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)2);
}

static size_t msg_interval_serialize_payload(DP_Message *msg,
                                             unsigned char *data)
{
    DP_MsgInterval *mi = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mi->msecs, data + written);
    DP_ASSERT(written == msg_interval_payload_length(msg));
    return written;
}

static bool msg_interval_write_payload_text(DP_Message *msg,
                                            DP_TextWriter *writer)
{
    DP_MsgInterval *mi = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "msecs", mi->msecs, false);
}

static bool msg_interval_equals(DP_Message *DP_RESTRICT msg,
                                DP_Message *DP_RESTRICT other)
{
    DP_MsgInterval *a = DP_message_internal(msg);
    DP_MsgInterval *b = DP_message_internal(other);
    return a->msecs == b->msecs;
}

static const DP_MessageMethods msg_interval_methods = {
    msg_interval_payload_length,
    msg_interval_serialize_payload,
    msg_interval_write_payload_text,
    msg_interval_equals,
};

DP_Message *DP_msg_interval_new(unsigned int context_id, uint16_t msecs)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_INTERVAL, context_id, &msg_interval_methods,
                       sizeof(DP_MsgInterval));
    DP_MsgInterval *mi = DP_message_internal(msg);
    mi->msecs = msecs;
    return msg;
}

DP_Message *DP_msg_interval_deserialize(unsigned int context_id,
                                        const unsigned char *buffer,
                                        size_t length)
{
    if (length != 2) {
        DP_error_set("Wrong length for interval message; "
                     "expected 2, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t msecs = read_uint16(buffer + read, &read);
    return DP_msg_interval_new(context_id, msecs);
}

DP_MsgInterval *DP_msg_interval_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_INTERVAL);
}

uint16_t DP_msg_interval_msecs(const DP_MsgInterval *mi)
{
    DP_ASSERT(mi);
    return mi->msecs;
}


/* DP_MSG_LASER_TRAIL */

struct DP_MsgLaserTrail {
    uint32_t color;
    uint8_t persistence;
};

static size_t msg_laser_trail_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)5);
}

static size_t msg_laser_trail_serialize_payload(DP_Message *msg,
                                                unsigned char *data)
{
    DP_MsgLaserTrail *mlt = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint32(mlt->color, data + written);
    written += DP_write_bigendian_uint8(mlt->persistence, data + written);
    DP_ASSERT(written == msg_laser_trail_payload_length(msg));
    return written;
}

static bool msg_laser_trail_write_payload_text(DP_Message *msg,
                                               DP_TextWriter *writer)
{
    DP_MsgLaserTrail *mlt = DP_message_internal(msg);
    return DP_text_writer_write_argb_color(writer, "color", mlt->color)
        && DP_text_writer_write_uint(writer, "persistence", mlt->persistence,
                                     false);
}

static bool msg_laser_trail_equals(DP_Message *DP_RESTRICT msg,
                                   DP_Message *DP_RESTRICT other)
{
    DP_MsgLaserTrail *a = DP_message_internal(msg);
    DP_MsgLaserTrail *b = DP_message_internal(other);
    return a->color == b->color && a->persistence == b->persistence;
}

static const DP_MessageMethods msg_laser_trail_methods = {
    msg_laser_trail_payload_length,
    msg_laser_trail_serialize_payload,
    msg_laser_trail_write_payload_text,
    msg_laser_trail_equals,
};

DP_Message *DP_msg_laser_trail_new(unsigned int context_id, uint32_t color,
                                   uint8_t persistence)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_LASER_TRAIL, context_id, &msg_laser_trail_methods,
                       sizeof(DP_MsgLaserTrail));
    DP_MsgLaserTrail *mlt = DP_message_internal(msg);
    mlt->color = color;
    mlt->persistence = persistence;
    return msg;
}

DP_Message *DP_msg_laser_trail_deserialize(unsigned int context_id,
                                           const unsigned char *buffer,
                                           size_t length)
{
    if (length != 5) {
        DP_error_set("Wrong length for lasertrail message; "
                     "expected 5, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint32_t color = read_uint32(buffer + read, &read);
    uint8_t persistence = read_uint8(buffer + read, &read);
    return DP_msg_laser_trail_new(context_id, color, persistence);
}

DP_MsgLaserTrail *DP_msg_laser_trail_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_LASER_TRAIL);
}

uint32_t DP_msg_laser_trail_color(const DP_MsgLaserTrail *mlt)
{
    DP_ASSERT(mlt);
    return mlt->color;
}

uint8_t DP_msg_laser_trail_persistence(const DP_MsgLaserTrail *mlt)
{
    DP_ASSERT(mlt);
    return mlt->persistence;
}


/* DP_MSG_MOVE_POINTER */

struct DP_MsgMovePointer {
    int32_t x;
    int32_t y;
};

static size_t msg_move_pointer_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)8);
}

static size_t msg_move_pointer_serialize_payload(DP_Message *msg,
                                                 unsigned char *data)
{
    DP_MsgMovePointer *mmp = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_int32(mmp->x, data + written);
    written += DP_write_bigendian_int32(mmp->y, data + written);
    DP_ASSERT(written == msg_move_pointer_payload_length(msg));
    return written;
}

static bool msg_move_pointer_write_payload_text(DP_Message *msg,
                                                DP_TextWriter *writer)
{
    DP_MsgMovePointer *mmp = DP_message_internal(msg);
    return DP_text_writer_write_int(writer, "x", mmp->x)
        && DP_text_writer_write_int(writer, "y", mmp->y);
}

static bool msg_move_pointer_equals(DP_Message *DP_RESTRICT msg,
                                    DP_Message *DP_RESTRICT other)
{
    DP_MsgMovePointer *a = DP_message_internal(msg);
    DP_MsgMovePointer *b = DP_message_internal(other);
    return a->x == b->x && a->y == b->y;
}

static const DP_MessageMethods msg_move_pointer_methods = {
    msg_move_pointer_payload_length,
    msg_move_pointer_serialize_payload,
    msg_move_pointer_write_payload_text,
    msg_move_pointer_equals,
};

DP_Message *DP_msg_move_pointer_new(unsigned int context_id, int32_t x,
                                    int32_t y)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_MOVE_POINTER, context_id,
                       &msg_move_pointer_methods, sizeof(DP_MsgMovePointer));
    DP_MsgMovePointer *mmp = DP_message_internal(msg);
    mmp->x = x;
    mmp->y = y;
    return msg;
}

DP_Message *DP_msg_move_pointer_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length)
{
    if (length != 8) {
        DP_error_set("Wrong length for movepointer message; "
                     "expected 8, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    int32_t x = read_int32(buffer + read, &read);
    int32_t y = read_int32(buffer + read, &read);
    return DP_msg_move_pointer_new(context_id, x, y);
}

DP_MsgMovePointer *DP_msg_move_pointer_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_MOVE_POINTER);
}

int32_t DP_msg_move_pointer_x(const DP_MsgMovePointer *mmp)
{
    DP_ASSERT(mmp);
    return mmp->x;
}

int32_t DP_msg_move_pointer_y(const DP_MsgMovePointer *mmp)
{
    DP_ASSERT(mmp);
    return mmp->y;
}


/* DP_MSG_MARKER */

struct DP_MsgMarker {
    uint16_t text_len;
    char text[];
};

static size_t msg_marker_payload_length(DP_Message *msg)
{
    DP_MsgMarker *mm = DP_message_internal(msg);
    return DP_uint16_to_size(mm->text_len);
}

static size_t msg_marker_serialize_payload(DP_Message *msg, unsigned char *data)
{
    DP_MsgMarker *mm = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bytes(mm->text, 1, mm->text_len, data + written);
    DP_ASSERT(written == msg_marker_payload_length(msg));
    return written;
}

static bool msg_marker_write_payload_text(DP_Message *msg,
                                          DP_TextWriter *writer)
{
    DP_MsgMarker *mm = DP_message_internal(msg);
    return DP_text_writer_write_string(writer, "text", mm->text);
}

static bool msg_marker_equals(DP_Message *DP_RESTRICT msg,
                              DP_Message *DP_RESTRICT other)
{
    DP_MsgMarker *a = DP_message_internal(msg);
    DP_MsgMarker *b = DP_message_internal(other);
    return a->text_len == b->text_len
        && memcmp(a->text, b->text, a->text_len) == 0;
}

static const DP_MessageMethods msg_marker_methods = {
    msg_marker_payload_length,
    msg_marker_serialize_payload,
    msg_marker_write_payload_text,
    msg_marker_equals,
};

DP_Message *DP_msg_marker_new(unsigned int context_id, const char *text_value,
                              size_t text_len)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_MARKER, context_id, &msg_marker_methods,
                       DP_FLEX_SIZEOF(DP_MsgMarker, text, text_len + 1));
    DP_MsgMarker *mm = DP_message_internal(msg);
    mm->text_len = DP_size_to_uint16(text_len);
    assign_string(mm->text, text_value, mm->text_len);
    return msg;
}

DP_Message *DP_msg_marker_deserialize(unsigned int context_id,
                                      const unsigned char *buffer,
                                      size_t length)
{
    if (length > 65535) {
        DP_error_set("Wrong length for marker message; "
                     "expected between 0 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    size_t text_bytes = length - read;
    uint16_t text_len = DP_size_to_uint16(text_bytes);
    const char *text = (const char *)buffer + read;
    return DP_msg_marker_new(context_id, text, text_len);
}

DP_MsgMarker *DP_msg_marker_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_MARKER);
}

const char *DP_msg_marker_text(const DP_MsgMarker *mm, size_t *out_len)
{
    DP_ASSERT(mm);
    if (out_len) {
        *out_len = mm->text_len;
    }
    return mm->text;
}

size_t DP_msg_marker_text_len(const DP_MsgMarker *mm)
{
    return mm->text_len;
}


/* DP_MSG_USER_ACL */

struct DP_MsgUserAcl {
    uint16_t users_count;
    uint8_t users[];
};

static size_t msg_user_acl_payload_length(DP_Message *msg)
{
    DP_MsgUserAcl *mua = DP_message_internal(msg);
    return DP_int_to_size(mua->users_count);
}

static size_t msg_user_acl_serialize_payload(DP_Message *msg,
                                             unsigned char *data)
{
    DP_MsgUserAcl *mua = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint8_array(mua->users, mua->users_count,
                                              data + written);
    DP_ASSERT(written == msg_user_acl_payload_length(msg));
    return written;
}

static bool msg_user_acl_write_payload_text(DP_Message *msg,
                                            DP_TextWriter *writer)
{
    DP_MsgUserAcl *mua = DP_message_internal(msg);
    return DP_text_writer_write_uint8_list(writer, "users", mua->users,
                                           mua->users_count);
}

static bool msg_user_acl_equals(DP_Message *DP_RESTRICT msg,
                                DP_Message *DP_RESTRICT other)
{
    DP_MsgUserAcl *a = DP_message_internal(msg);
    DP_MsgUserAcl *b = DP_message_internal(other);
    return a->users_count == b->users_count
        && memcmp(a->users, b->users, DP_uint16_to_size(a->users_count)) == 0;
}

static const DP_MessageMethods msg_user_acl_methods = {
    msg_user_acl_payload_length,
    msg_user_acl_serialize_payload,
    msg_user_acl_write_payload_text,
    msg_user_acl_equals,
};

DP_Message *DP_msg_user_acl_new(unsigned int context_id,
                                void (*set_users)(int, uint8_t *, void *),
                                int users_count, void *users_user)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_USER_ACL, context_id, &msg_user_acl_methods,
        DP_FLEX_SIZEOF(DP_MsgUserAcl, users, DP_int_to_size(users_count)));
    DP_MsgUserAcl *mua = DP_message_internal(msg);
    mua->users_count = DP_int_to_uint16(users_count);
    if (set_users) {
        set_users(mua->users_count, mua->users, users_user);
    }
    return msg;
}

DP_Message *DP_msg_user_acl_deserialize(unsigned int context_id,
                                        const unsigned char *buffer,
                                        size_t length)
{
    if (length > 255) {
        DP_error_set("Wrong length for useracl message; "
                     "expected between 0 and 255, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    size_t users_bytes = length - read;
    uint16_t users_count = DP_size_to_uint16(users_bytes);
    void *users_user = (void *)(buffer + read);
    return DP_msg_user_acl_new(context_id, read_uint8_array, users_count,
                               users_user);
}

DP_MsgUserAcl *DP_msg_user_acl_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_USER_ACL);
}

const uint8_t *DP_msg_user_acl_users(const DP_MsgUserAcl *mua, int *out_count)
{
    DP_ASSERT(mua);
    if (out_count) {
        *out_count = mua->users_count;
    }
    return mua->users;
}

int DP_msg_user_acl_users_count(const DP_MsgUserAcl *mua)
{
    return mua->users_count;
}


/* DP_MSG_LAYER_ACL */

struct DP_MsgLayerAcl {
    uint16_t id;
    uint8_t flags;
    uint16_t exclusive_count;
    uint8_t exclusive[];
};

static size_t msg_layer_acl_payload_length(DP_Message *msg)
{
    DP_MsgLayerAcl *mla = DP_message_internal(msg);
    return ((size_t)3) + DP_int_to_size(mla->exclusive_count);
}

static size_t msg_layer_acl_serialize_payload(DP_Message *msg,
                                              unsigned char *data)
{
    DP_MsgLayerAcl *mla = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mla->id, data + written);
    written += DP_write_bigendian_uint8(mla->flags, data + written);
    written += DP_write_bigendian_uint8_array(
        mla->exclusive, mla->exclusive_count, data + written);
    DP_ASSERT(written == msg_layer_acl_payload_length(msg));
    return written;
}

static bool msg_layer_acl_write_payload_text(DP_Message *msg,
                                             DP_TextWriter *writer)
{
    DP_MsgLayerAcl *mla = DP_message_internal(msg);
    return DP_text_writer_write_uint8_list(writer, "exclusive", mla->exclusive,
                                           mla->exclusive_count)
        && DP_text_writer_write_uint(writer, "flags", mla->flags, false)
        && DP_text_writer_write_uint(writer, "id", mla->id, false);
}

static bool msg_layer_acl_equals(DP_Message *DP_RESTRICT msg,
                                 DP_Message *DP_RESTRICT other)
{
    DP_MsgLayerAcl *a = DP_message_internal(msg);
    DP_MsgLayerAcl *b = DP_message_internal(other);
    return a->id == b->id && a->flags == b->flags
        && a->exclusive_count == b->exclusive_count
        && memcmp(a->exclusive, b->exclusive,
                  DP_uint16_to_size(a->exclusive_count))
               == 0;
}

static const DP_MessageMethods msg_layer_acl_methods = {
    msg_layer_acl_payload_length,
    msg_layer_acl_serialize_payload,
    msg_layer_acl_write_payload_text,
    msg_layer_acl_equals,
};

DP_Message *DP_msg_layer_acl_new(unsigned int context_id, uint16_t id,
                                 uint8_t flags,
                                 void (*set_exclusive)(int, uint8_t *, void *),
                                 int exclusive_count, void *exclusive_user)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_LAYER_ACL, context_id, &msg_layer_acl_methods,
                       DP_FLEX_SIZEOF(DP_MsgLayerAcl, exclusive,
                                      DP_int_to_size(exclusive_count)));
    DP_MsgLayerAcl *mla = DP_message_internal(msg);
    mla->id = id;
    mla->flags = flags;
    mla->exclusive_count = DP_int_to_uint16(exclusive_count);
    if (set_exclusive) {
        set_exclusive(mla->exclusive_count, mla->exclusive, exclusive_user);
    }
    return msg;
}

DP_Message *DP_msg_layer_acl_deserialize(unsigned int context_id,
                                         const unsigned char *buffer,
                                         size_t length)
{
    if (length < 3 || length > 258) {
        DP_error_set("Wrong length for layeracl message; "
                     "expected between 3 and 258, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t id = read_uint16(buffer + read, &read);
    uint8_t flags = read_uint8(buffer + read, &read);
    size_t exclusive_bytes = length - read;
    uint16_t exclusive_count = DP_size_to_uint16(exclusive_bytes);
    void *exclusive_user = (void *)(buffer + read);
    return DP_msg_layer_acl_new(context_id, id, flags, read_uint8_array,
                                exclusive_count, exclusive_user);
}

DP_MsgLayerAcl *DP_msg_layer_acl_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_LAYER_ACL);
}

uint16_t DP_msg_layer_acl_id(const DP_MsgLayerAcl *mla)
{
    DP_ASSERT(mla);
    return mla->id;
}

uint8_t DP_msg_layer_acl_flags(const DP_MsgLayerAcl *mla)
{
    DP_ASSERT(mla);
    return mla->flags;
}

const uint8_t *DP_msg_layer_acl_exclusive(const DP_MsgLayerAcl *mla,
                                          int *out_count)
{
    DP_ASSERT(mla);
    if (out_count) {
        *out_count = mla->exclusive_count;
    }
    return mla->exclusive;
}

int DP_msg_layer_acl_exclusive_count(const DP_MsgLayerAcl *mla)
{
    return mla->exclusive_count;
}


/* DP_MSG_FEATURE_ACCESS_LEVELS */

struct DP_MsgFeatureAccessLevels {
    uint16_t feature_tiers_count;
    uint8_t feature_tiers[];
};

static size_t msg_feature_access_levels_payload_length(DP_Message *msg)
{
    DP_MsgFeatureAccessLevels *mfal = DP_message_internal(msg);
    return DP_int_to_size(mfal->feature_tiers_count);
}

static size_t msg_feature_access_levels_serialize_payload(DP_Message *msg,
                                                          unsigned char *data)
{
    DP_MsgFeatureAccessLevels *mfal = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint8_array(
        mfal->feature_tiers, mfal->feature_tiers_count, data + written);
    DP_ASSERT(written == msg_feature_access_levels_payload_length(msg));
    return written;
}

static bool msg_feature_access_levels_write_payload_text(DP_Message *msg,
                                                         DP_TextWriter *writer)
{
    DP_MsgFeatureAccessLevels *mfal = DP_message_internal(msg);
    return DP_text_writer_write_uint8_list(writer, "feature_tiers",
                                           mfal->feature_tiers,
                                           mfal->feature_tiers_count);
}

static bool msg_feature_access_levels_equals(DP_Message *DP_RESTRICT msg,
                                             DP_Message *DP_RESTRICT other)
{
    DP_MsgFeatureAccessLevels *a = DP_message_internal(msg);
    DP_MsgFeatureAccessLevels *b = DP_message_internal(other);
    return a->feature_tiers_count == b->feature_tiers_count
        && memcmp(a->feature_tiers, b->feature_tiers,
                  DP_uint16_to_size(a->feature_tiers_count))
               == 0;
}

static const DP_MessageMethods msg_feature_access_levels_methods = {
    msg_feature_access_levels_payload_length,
    msg_feature_access_levels_serialize_payload,
    msg_feature_access_levels_write_payload_text,
    msg_feature_access_levels_equals,
};

DP_Message *DP_msg_feature_access_levels_new(
    unsigned int context_id, void (*set_feature_tiers)(int, uint8_t *, void *),
    int feature_tiers_count, void *feature_tiers_user)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_FEATURE_ACCESS_LEVELS, context_id,
                       &msg_feature_access_levels_methods,
                       DP_FLEX_SIZEOF(DP_MsgFeatureAccessLevels, feature_tiers,
                                      DP_int_to_size(feature_tiers_count)));
    DP_MsgFeatureAccessLevels *mfal = DP_message_internal(msg);
    mfal->feature_tiers_count = DP_int_to_uint16(feature_tiers_count);
    if (set_feature_tiers) {
        set_feature_tiers(mfal->feature_tiers_count, mfal->feature_tiers,
                          feature_tiers_user);
    }
    return msg;
}

DP_Message *DP_msg_feature_access_levels_deserialize(
    unsigned int context_id, const unsigned char *buffer, size_t length)
{
    if (length != 11) {
        DP_error_set("Wrong length for featureaccess message; "
                     "expected 11, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    size_t feature_tiers_bytes = length - read;
    uint16_t feature_tiers_count = DP_size_to_uint16(feature_tiers_bytes);
    void *feature_tiers_user = (void *)(buffer + read);
    return DP_msg_feature_access_levels_new(
        context_id, read_uint8_array, feature_tiers_count, feature_tiers_user);
}

DP_MsgFeatureAccessLevels *DP_msg_feature_access_levels_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_FEATURE_ACCESS_LEVELS);
}

const uint8_t *DP_msg_feature_access_levels_feature_tiers(
    const DP_MsgFeatureAccessLevels *mfal, int *out_count)
{
    DP_ASSERT(mfal);
    if (out_count) {
        *out_count = mfal->feature_tiers_count;
    }
    return mfal->feature_tiers;
}

int DP_msg_feature_access_levels_feature_tiers_count(
    const DP_MsgFeatureAccessLevels *mfal)
{
    return mfal->feature_tiers_count;
}


/* DP_MSG_DEFAULT_LAYER */

struct DP_MsgDefaultLayer {
    uint16_t id;
};

static size_t msg_default_layer_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)2);
}

static size_t msg_default_layer_serialize_payload(DP_Message *msg,
                                                  unsigned char *data)
{
    DP_MsgDefaultLayer *mdl = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mdl->id, data + written);
    DP_ASSERT(written == msg_default_layer_payload_length(msg));
    return written;
}

static bool msg_default_layer_write_payload_text(DP_Message *msg,
                                                 DP_TextWriter *writer)
{
    DP_MsgDefaultLayer *mdl = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "id", mdl->id, true);
}

static bool msg_default_layer_equals(DP_Message *DP_RESTRICT msg,
                                     DP_Message *DP_RESTRICT other)
{
    DP_MsgDefaultLayer *a = DP_message_internal(msg);
    DP_MsgDefaultLayer *b = DP_message_internal(other);
    return a->id == b->id;
}

static const DP_MessageMethods msg_default_layer_methods = {
    msg_default_layer_payload_length,
    msg_default_layer_serialize_payload,
    msg_default_layer_write_payload_text,
    msg_default_layer_equals,
};

DP_Message *DP_msg_default_layer_new(unsigned int context_id, uint16_t id)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_DEFAULT_LAYER, context_id,
                       &msg_default_layer_methods, sizeof(DP_MsgDefaultLayer));
    DP_MsgDefaultLayer *mdl = DP_message_internal(msg);
    mdl->id = id;
    return msg;
}

DP_Message *DP_msg_default_layer_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length)
{
    if (length != 2) {
        DP_error_set("Wrong length for defaultlayer message; "
                     "expected 2, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t id = read_uint16(buffer + read, &read);
    return DP_msg_default_layer_new(context_id, id);
}

DP_MsgDefaultLayer *DP_msg_default_layer_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_DEFAULT_LAYER);
}

uint16_t DP_msg_default_layer_id(const DP_MsgDefaultLayer *mdl)
{
    DP_ASSERT(mdl);
    return mdl->id;
}


/* DP_MSG_FILTERED */

struct DP_MsgFiltered {
    uint16_t message_size;
    unsigned char message[];
};

static size_t msg_filtered_payload_length(DP_Message *msg)
{
    DP_MsgFiltered *mf = DP_message_internal(msg);
    return mf->message_size;
}

static size_t msg_filtered_serialize_payload(DP_Message *msg,
                                             unsigned char *data)
{
    DP_MsgFiltered *mf = DP_message_internal(msg);
    size_t written = 0;
    written += write_bytes(mf->message, mf->message_size, data + written);
    DP_ASSERT(written == msg_filtered_payload_length(msg));
    return written;
}

static bool msg_filtered_write_payload_text(DP_Message *msg,
                                            DP_TextWriter *writer)
{
    DP_MsgFiltered *mf = DP_message_internal(msg);
    return DP_text_writer_write_base64(writer, "message", mf->message,
                                       mf->message_size);
}

static bool msg_filtered_equals(DP_Message *DP_RESTRICT msg,
                                DP_Message *DP_RESTRICT other)
{
    DP_MsgFiltered *a = DP_message_internal(msg);
    DP_MsgFiltered *b = DP_message_internal(other);
    return a->message_size == b->message_size
        && memcmp(a->message, b->message, DP_uint16_to_size(a->message_size))
               == 0;
}

static const DP_MessageMethods msg_filtered_methods = {
    msg_filtered_payload_length,
    msg_filtered_serialize_payload,
    msg_filtered_write_payload_text,
    msg_filtered_equals,
};

DP_Message *DP_msg_filtered_new(unsigned int context_id,
                                void (*set_message)(size_t, unsigned char *,
                                                    void *),
                                size_t message_size, void *message_user)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_FILTERED, context_id, &msg_filtered_methods,
                       DP_FLEX_SIZEOF(DP_MsgFiltered, message, message_size));
    DP_MsgFiltered *mf = DP_message_internal(msg);
    mf->message_size = DP_size_to_uint16(message_size);
    if (set_message) {
        set_message(mf->message_size, mf->message, message_user);
    }
    return msg;
}

DP_Message *DP_msg_filtered_deserialize(unsigned int context_id,
                                        const unsigned char *buffer,
                                        size_t length)
{
    if (length > 65535) {
        DP_error_set("Wrong length for filtered message; "
                     "expected between 0 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    size_t message_bytes = length - read;
    uint16_t message_size = DP_size_to_uint16(message_bytes);
    void *message_user = (void *)(buffer + read);
    return DP_msg_filtered_new(context_id, read_bytes, message_size,
                               message_user);
}

DP_MsgFiltered *DP_msg_filtered_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_FILTERED);
}

const unsigned char *DP_msg_filtered_message(const DP_MsgFiltered *mf,
                                             size_t *out_size)
{
    DP_ASSERT(mf);
    if (out_size) {
        *out_size = mf->message_size;
    }
    return mf->message;
}

size_t DP_msg_filtered_message_size(const DP_MsgFiltered *mf)
{
    return mf->message_size;
}


/* DP_MSG_UNDO_POINT */

DP_Message *DP_msg_undo_point_new(unsigned int context_id)
{
    return DP_message_new(DP_MSG_UNDO_POINT, context_id, &zero_length_methods,
                          0);
}

DP_Message *DP_msg_undo_point_deserialize(unsigned int context_id,
                                          DP_UNUSED const unsigned char *buffer,
                                          size_t length)
{
    if (length != 0) {
        DP_error_set("Wrong length for undopoint message; "
                     "expected 0, got %zu",
                     length);
        return NULL;
    }
    return DP_msg_undo_point_new(context_id);
}


/* DP_MSG_CANVAS_RESIZE */

struct DP_MsgCanvasResize {
    int32_t top;
    int32_t right;
    int32_t bottom;
    int32_t left;
};

static size_t msg_canvas_resize_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)16);
}

static size_t msg_canvas_resize_serialize_payload(DP_Message *msg,
                                                  unsigned char *data)
{
    DP_MsgCanvasResize *mcr = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_int32(mcr->top, data + written);
    written += DP_write_bigendian_int32(mcr->right, data + written);
    written += DP_write_bigendian_int32(mcr->bottom, data + written);
    written += DP_write_bigendian_int32(mcr->left, data + written);
    DP_ASSERT(written == msg_canvas_resize_payload_length(msg));
    return written;
}

static bool msg_canvas_resize_write_payload_text(DP_Message *msg,
                                                 DP_TextWriter *writer)
{
    DP_MsgCanvasResize *mcr = DP_message_internal(msg);
    return DP_text_writer_write_int(writer, "bottom", mcr->bottom)
        && DP_text_writer_write_int(writer, "left", mcr->left)
        && DP_text_writer_write_int(writer, "right", mcr->right)
        && DP_text_writer_write_int(writer, "top", mcr->top);
}

static bool msg_canvas_resize_equals(DP_Message *DP_RESTRICT msg,
                                     DP_Message *DP_RESTRICT other)
{
    DP_MsgCanvasResize *a = DP_message_internal(msg);
    DP_MsgCanvasResize *b = DP_message_internal(other);
    return a->top == b->top && a->right == b->right && a->bottom == b->bottom
        && a->left == b->left;
}

static const DP_MessageMethods msg_canvas_resize_methods = {
    msg_canvas_resize_payload_length,
    msg_canvas_resize_serialize_payload,
    msg_canvas_resize_write_payload_text,
    msg_canvas_resize_equals,
};

DP_Message *DP_msg_canvas_resize_new(unsigned int context_id, int32_t top,
                                     int32_t right, int32_t bottom,
                                     int32_t left)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_CANVAS_RESIZE, context_id,
                       &msg_canvas_resize_methods, sizeof(DP_MsgCanvasResize));
    DP_MsgCanvasResize *mcr = DP_message_internal(msg);
    mcr->top = top;
    mcr->right = right;
    mcr->bottom = bottom;
    mcr->left = left;
    return msg;
}

DP_Message *DP_msg_canvas_resize_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length)
{
    if (length != 16) {
        DP_error_set("Wrong length for resize message; "
                     "expected 16, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    int32_t top = read_int32(buffer + read, &read);
    int32_t right = read_int32(buffer + read, &read);
    int32_t bottom = read_int32(buffer + read, &read);
    int32_t left = read_int32(buffer + read, &read);
    return DP_msg_canvas_resize_new(context_id, top, right, bottom, left);
}

DP_MsgCanvasResize *DP_msg_canvas_resize_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_CANVAS_RESIZE);
}

int32_t DP_msg_canvas_resize_top(const DP_MsgCanvasResize *mcr)
{
    DP_ASSERT(mcr);
    return mcr->top;
}

int32_t DP_msg_canvas_resize_right(const DP_MsgCanvasResize *mcr)
{
    DP_ASSERT(mcr);
    return mcr->right;
}

int32_t DP_msg_canvas_resize_bottom(const DP_MsgCanvasResize *mcr)
{
    DP_ASSERT(mcr);
    return mcr->bottom;
}

int32_t DP_msg_canvas_resize_left(const DP_MsgCanvasResize *mcr)
{
    DP_ASSERT(mcr);
    return mcr->left;
}


/* DP_MSG_LAYER_CREATE */

const char *DP_msg_layer_create_flags_flag_name(unsigned int value)
{
    switch (value) {
    case DP_MSG_LAYER_CREATE_FLAGS_GROUP:
        return "group";
    case DP_MSG_LAYER_CREATE_FLAGS_INTO:
        return "into";
    default:
        return NULL;
    }
}

struct DP_MsgLayerCreate {
    uint16_t id;
    uint16_t source;
    uint16_t target;
    uint32_t fill;
    uint8_t flags;
    uint16_t name_len;
    char name[];
};

static size_t msg_layer_create_payload_length(DP_Message *msg)
{
    DP_MsgLayerCreate *mlc = DP_message_internal(msg);
    return ((size_t)11) + DP_uint16_to_size(mlc->name_len);
}

static size_t msg_layer_create_serialize_payload(DP_Message *msg,
                                                 unsigned char *data)
{
    DP_MsgLayerCreate *mlc = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mlc->id, data + written);
    written += DP_write_bigendian_uint16(mlc->source, data + written);
    written += DP_write_bigendian_uint16(mlc->target, data + written);
    written += DP_write_bigendian_uint32(mlc->fill, data + written);
    written += DP_write_bigendian_uint8(mlc->flags, data + written);
    written += DP_write_bytes(mlc->name, 1, mlc->name_len, data + written);
    DP_ASSERT(written == msg_layer_create_payload_length(msg));
    return written;
}

static bool msg_layer_create_write_payload_text(DP_Message *msg,
                                                DP_TextWriter *writer)
{
    DP_MsgLayerCreate *mlc = DP_message_internal(msg);
    return DP_text_writer_write_argb_color(writer, "fill", mlc->fill)
        && DP_text_writer_write_flags(
               writer, "flags", mlc->flags, 2,
               (const char *[]){"group", "into"},
               (unsigned int[]){DP_MSG_LAYER_CREATE_FLAGS_GROUP,
                                DP_MSG_LAYER_CREATE_FLAGS_INTO})
        && DP_text_writer_write_uint(writer, "id", mlc->id, true)
        && DP_text_writer_write_string(writer, "name", mlc->name)
        && DP_text_writer_write_uint(writer, "source", mlc->source, true)
        && DP_text_writer_write_uint(writer, "target", mlc->target, true);
}

static bool msg_layer_create_equals(DP_Message *DP_RESTRICT msg,
                                    DP_Message *DP_RESTRICT other)
{
    DP_MsgLayerCreate *a = DP_message_internal(msg);
    DP_MsgLayerCreate *b = DP_message_internal(other);
    return a->id == b->id && a->source == b->source && a->target == b->target
        && a->fill == b->fill && a->flags == b->flags
        && a->name_len == b->name_len
        && memcmp(a->name, b->name, a->name_len) == 0;
}

static const DP_MessageMethods msg_layer_create_methods = {
    msg_layer_create_payload_length,
    msg_layer_create_serialize_payload,
    msg_layer_create_write_payload_text,
    msg_layer_create_equals,
};

DP_Message *DP_msg_layer_create_new(unsigned int context_id, uint16_t id,
                                    uint16_t source, uint16_t target,
                                    uint32_t fill, uint8_t flags,
                                    const char *name_value, size_t name_len)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_LAYER_CREATE, context_id, &msg_layer_create_methods,
        DP_FLEX_SIZEOF(DP_MsgLayerCreate, name, name_len + 1));
    DP_MsgLayerCreate *mlc = DP_message_internal(msg);
    mlc->id = id;
    mlc->source = source;
    mlc->target = target;
    mlc->fill = fill;
    mlc->flags = flags;
    mlc->name_len = DP_size_to_uint16(name_len);
    assign_string(mlc->name, name_value, mlc->name_len);
    return msg;
}

DP_Message *DP_msg_layer_create_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length)
{
    if (length < 11 || length > 65535) {
        DP_error_set("Wrong length for newlayer message; "
                     "expected between 11 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t id = read_uint16(buffer + read, &read);
    uint16_t source = read_uint16(buffer + read, &read);
    uint16_t target = read_uint16(buffer + read, &read);
    uint32_t fill = read_uint32(buffer + read, &read);
    uint8_t flags = read_uint8(buffer + read, &read);
    size_t name_bytes = length - read;
    uint16_t name_len = DP_size_to_uint16(name_bytes);
    const char *name = (const char *)buffer + read;
    return DP_msg_layer_create_new(context_id, id, source, target, fill, flags,
                                   name, name_len);
}

DP_MsgLayerCreate *DP_msg_layer_create_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_LAYER_CREATE);
}

uint16_t DP_msg_layer_create_id(const DP_MsgLayerCreate *mlc)
{
    DP_ASSERT(mlc);
    return mlc->id;
}

uint16_t DP_msg_layer_create_source(const DP_MsgLayerCreate *mlc)
{
    DP_ASSERT(mlc);
    return mlc->source;
}

uint16_t DP_msg_layer_create_target(const DP_MsgLayerCreate *mlc)
{
    DP_ASSERT(mlc);
    return mlc->target;
}

uint32_t DP_msg_layer_create_fill(const DP_MsgLayerCreate *mlc)
{
    DP_ASSERT(mlc);
    return mlc->fill;
}

uint8_t DP_msg_layer_create_flags(const DP_MsgLayerCreate *mlc)
{
    DP_ASSERT(mlc);
    return mlc->flags;
}

const char *DP_msg_layer_create_name(const DP_MsgLayerCreate *mlc,
                                     size_t *out_len)
{
    DP_ASSERT(mlc);
    if (out_len) {
        *out_len = mlc->name_len;
    }
    return mlc->name;
}

size_t DP_msg_layer_create_name_len(const DP_MsgLayerCreate *mlc)
{
    return mlc->name_len;
}


/* DP_MSG_LAYER_ATTRIBUTES */

const char *DP_msg_layer_attributes_flags_flag_name(unsigned int value)
{
    switch (value) {
    case DP_MSG_LAYER_ATTRIBUTES_FLAGS_CENSOR:
        return "censor";
    case DP_MSG_LAYER_ATTRIBUTES_FLAGS_FIXED:
        return "fixed";
    case DP_MSG_LAYER_ATTRIBUTES_FLAGS_ISOLATED:
        return "isolated";
    default:
        return NULL;
    }
}

struct DP_MsgLayerAttributes {
    uint16_t id;
    uint8_t sublayer;
    uint8_t flags;
    uint8_t opacity;
    uint8_t blend;
};

static size_t msg_layer_attributes_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)6);
}

static size_t msg_layer_attributes_serialize_payload(DP_Message *msg,
                                                     unsigned char *data)
{
    DP_MsgLayerAttributes *mla = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mla->id, data + written);
    written += DP_write_bigendian_uint8(mla->sublayer, data + written);
    written += DP_write_bigendian_uint8(mla->flags, data + written);
    written += DP_write_bigendian_uint8(mla->opacity, data + written);
    written += DP_write_bigendian_uint8(mla->blend, data + written);
    DP_ASSERT(written == msg_layer_attributes_payload_length(msg));
    return written;
}

static bool msg_layer_attributes_write_payload_text(DP_Message *msg,
                                                    DP_TextWriter *writer)
{
    DP_MsgLayerAttributes *mla = DP_message_internal(msg);
    return DP_text_writer_write_blend_mode(writer, "blend", mla->blend)
        && DP_text_writer_write_flags(
               writer, "flags", mla->flags, 3,
               (const char *[]){"censor", "fixed", "isolated"},
               (unsigned int[]){DP_MSG_LAYER_ATTRIBUTES_FLAGS_CENSOR,
                                DP_MSG_LAYER_ATTRIBUTES_FLAGS_FIXED,
                                DP_MSG_LAYER_ATTRIBUTES_FLAGS_ISOLATED})
        && DP_text_writer_write_uint(writer, "id", mla->id, true)
        && DP_text_writer_write_uint(writer, "opacity", mla->opacity, false)
        && DP_text_writer_write_uint(writer, "sublayer", mla->sublayer, false);
}

static bool msg_layer_attributes_equals(DP_Message *DP_RESTRICT msg,
                                        DP_Message *DP_RESTRICT other)
{
    DP_MsgLayerAttributes *a = DP_message_internal(msg);
    DP_MsgLayerAttributes *b = DP_message_internal(other);
    return a->id == b->id && a->sublayer == b->sublayer && a->flags == b->flags
        && a->opacity == b->opacity && a->blend == b->blend;
}

static const DP_MessageMethods msg_layer_attributes_methods = {
    msg_layer_attributes_payload_length,
    msg_layer_attributes_serialize_payload,
    msg_layer_attributes_write_payload_text,
    msg_layer_attributes_equals,
};

DP_Message *DP_msg_layer_attributes_new(unsigned int context_id, uint16_t id,
                                        uint8_t sublayer, uint8_t flags,
                                        uint8_t opacity, uint8_t blend)
{
    DP_Message *msg = DP_message_new(DP_MSG_LAYER_ATTRIBUTES, context_id,
                                     &msg_layer_attributes_methods,
                                     sizeof(DP_MsgLayerAttributes));
    DP_MsgLayerAttributes *mla = DP_message_internal(msg);
    mla->id = id;
    mla->sublayer = sublayer;
    mla->flags = flags;
    mla->opacity = opacity;
    mla->blend = blend;
    return msg;
}

DP_Message *DP_msg_layer_attributes_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length)
{
    if (length != 6) {
        DP_error_set("Wrong length for layerattr message; "
                     "expected 6, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t id = read_uint16(buffer + read, &read);
    uint8_t sublayer = read_uint8(buffer + read, &read);
    uint8_t flags = read_uint8(buffer + read, &read);
    uint8_t opacity = read_uint8(buffer + read, &read);
    uint8_t blend = read_uint8(buffer + read, &read);
    return DP_msg_layer_attributes_new(context_id, id, sublayer, flags, opacity,
                                       blend);
}

DP_MsgLayerAttributes *DP_msg_layer_attributes_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_LAYER_ATTRIBUTES);
}

uint16_t DP_msg_layer_attributes_id(const DP_MsgLayerAttributes *mla)
{
    DP_ASSERT(mla);
    return mla->id;
}

uint8_t DP_msg_layer_attributes_sublayer(const DP_MsgLayerAttributes *mla)
{
    DP_ASSERT(mla);
    return mla->sublayer;
}

uint8_t DP_msg_layer_attributes_flags(const DP_MsgLayerAttributes *mla)
{
    DP_ASSERT(mla);
    return mla->flags;
}

uint8_t DP_msg_layer_attributes_opacity(const DP_MsgLayerAttributes *mla)
{
    DP_ASSERT(mla);
    return mla->opacity;
}

uint8_t DP_msg_layer_attributes_blend(const DP_MsgLayerAttributes *mla)
{
    DP_ASSERT(mla);
    return mla->blend;
}


/* DP_MSG_LAYER_RETITLE */

struct DP_MsgLayerRetitle {
    uint16_t id;
    uint16_t title_len;
    char title[];
};

static size_t msg_layer_retitle_payload_length(DP_Message *msg)
{
    DP_MsgLayerRetitle *mlr = DP_message_internal(msg);
    return ((size_t)2) + DP_uint16_to_size(mlr->title_len);
}

static size_t msg_layer_retitle_serialize_payload(DP_Message *msg,
                                                  unsigned char *data)
{
    DP_MsgLayerRetitle *mlr = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mlr->id, data + written);
    written += DP_write_bytes(mlr->title, 1, mlr->title_len, data + written);
    DP_ASSERT(written == msg_layer_retitle_payload_length(msg));
    return written;
}

static bool msg_layer_retitle_write_payload_text(DP_Message *msg,
                                                 DP_TextWriter *writer)
{
    DP_MsgLayerRetitle *mlr = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "id", mlr->id, true)
        && DP_text_writer_write_string(writer, "title", mlr->title);
}

static bool msg_layer_retitle_equals(DP_Message *DP_RESTRICT msg,
                                     DP_Message *DP_RESTRICT other)
{
    DP_MsgLayerRetitle *a = DP_message_internal(msg);
    DP_MsgLayerRetitle *b = DP_message_internal(other);
    return a->id == b->id && a->title_len == b->title_len
        && memcmp(a->title, b->title, a->title_len) == 0;
}

static const DP_MessageMethods msg_layer_retitle_methods = {
    msg_layer_retitle_payload_length,
    msg_layer_retitle_serialize_payload,
    msg_layer_retitle_write_payload_text,
    msg_layer_retitle_equals,
};

DP_Message *DP_msg_layer_retitle_new(unsigned int context_id, uint16_t id,
                                     const char *title_value, size_t title_len)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_LAYER_RETITLE, context_id, &msg_layer_retitle_methods,
        DP_FLEX_SIZEOF(DP_MsgLayerRetitle, title, title_len + 1));
    DP_MsgLayerRetitle *mlr = DP_message_internal(msg);
    mlr->id = id;
    mlr->title_len = DP_size_to_uint16(title_len);
    assign_string(mlr->title, title_value, mlr->title_len);
    return msg;
}

DP_Message *DP_msg_layer_retitle_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length)
{
    if (length < 2 || length > 65535) {
        DP_error_set("Wrong length for retitlelayer message; "
                     "expected between 2 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t id = read_uint16(buffer + read, &read);
    size_t title_bytes = length - read;
    uint16_t title_len = DP_size_to_uint16(title_bytes);
    const char *title = (const char *)buffer + read;
    return DP_msg_layer_retitle_new(context_id, id, title, title_len);
}

DP_MsgLayerRetitle *DP_msg_layer_retitle_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_LAYER_RETITLE);
}

uint16_t DP_msg_layer_retitle_id(const DP_MsgLayerRetitle *mlr)
{
    DP_ASSERT(mlr);
    return mlr->id;
}

const char *DP_msg_layer_retitle_title(const DP_MsgLayerRetitle *mlr,
                                       size_t *out_len)
{
    DP_ASSERT(mlr);
    if (out_len) {
        *out_len = mlr->title_len;
    }
    return mlr->title;
}

size_t DP_msg_layer_retitle_title_len(const DP_MsgLayerRetitle *mlr)
{
    return mlr->title_len;
}


/* DP_MSG_LAYER_ORDER */

struct DP_MsgLayerOrder {
    uint16_t root;
    uint16_t layers_count;
    uint16_t layers[];
};

static size_t msg_layer_order_payload_length(DP_Message *msg)
{
    DP_MsgLayerOrder *mlo = DP_message_internal(msg);
    return ((size_t)2) + DP_int_to_size(mlo->layers_count) * 2;
}

static size_t msg_layer_order_serialize_payload(DP_Message *msg,
                                                unsigned char *data)
{
    DP_MsgLayerOrder *mlo = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mlo->root, data + written);
    written += DP_write_bigendian_uint16_array(mlo->layers, mlo->layers_count,
                                               data + written);
    DP_ASSERT(written == msg_layer_order_payload_length(msg));
    return written;
}

static bool msg_layer_order_write_payload_text(DP_Message *msg,
                                               DP_TextWriter *writer)
{
    DP_MsgLayerOrder *mlo = DP_message_internal(msg);
    return DP_text_writer_write_uint16_list(writer, "layers", mlo->layers,
                                            mlo->layers_count, true)
        && DP_text_writer_write_uint(writer, "root", mlo->root, true);
}

static bool msg_layer_order_equals(DP_Message *DP_RESTRICT msg,
                                   DP_Message *DP_RESTRICT other)
{
    DP_MsgLayerOrder *a = DP_message_internal(msg);
    DP_MsgLayerOrder *b = DP_message_internal(other);
    return a->root == b->root && a->layers_count == b->layers_count
        && memcmp(a->layers, b->layers, DP_uint16_to_size(a->layers_count) * 2)
               == 0;
}

static const DP_MessageMethods msg_layer_order_methods = {
    msg_layer_order_payload_length,
    msg_layer_order_serialize_payload,
    msg_layer_order_write_payload_text,
    msg_layer_order_equals,
};

DP_Message *DP_msg_layer_order_new(unsigned int context_id, uint16_t root,
                                   void (*set_layers)(int, uint16_t *, void *),
                                   int layers_count, void *layers_user)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_LAYER_ORDER, context_id, &msg_layer_order_methods,
                       DP_FLEX_SIZEOF(DP_MsgLayerOrder, layers,
                                      DP_int_to_size(layers_count) * 2));
    DP_MsgLayerOrder *mlo = DP_message_internal(msg);
    mlo->root = root;
    mlo->layers_count = DP_int_to_uint16(layers_count);
    if (set_layers) {
        set_layers(mlo->layers_count, mlo->layers, layers_user);
    }
    return msg;
}

DP_Message *DP_msg_layer_order_deserialize(unsigned int context_id,
                                           const unsigned char *buffer,
                                           size_t length)
{
    if (length < 2 || length > 65535) {
        DP_error_set("Wrong length for layerorder message; "
                     "expected between 2 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t root = read_uint16(buffer + read, &read);
    size_t layers_bytes = length - read;
    if ((layers_bytes % 2) != 0) {
        DP_error_set("Wrong length for layers field in layerorder message; "
                     "%zu not divisible by 2",
                     layers_bytes);
        return NULL;
    }
    uint16_t layers_count = DP_size_to_uint16(layers_bytes / 2);
    void *layers_user = (void *)(buffer + read);
    return DP_msg_layer_order_new(context_id, root, read_uint16_array,
                                  layers_count, layers_user);
}

DP_MsgLayerOrder *DP_msg_layer_order_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_LAYER_ORDER);
}

uint16_t DP_msg_layer_order_root(const DP_MsgLayerOrder *mlo)
{
    DP_ASSERT(mlo);
    return mlo->root;
}

const uint16_t *DP_msg_layer_order_layers(const DP_MsgLayerOrder *mlo,
                                          int *out_count)
{
    DP_ASSERT(mlo);
    if (out_count) {
        *out_count = mlo->layers_count;
    }
    return mlo->layers;
}

int DP_msg_layer_order_layers_count(const DP_MsgLayerOrder *mlo)
{
    return mlo->layers_count;
}


/* DP_MSG_LAYER_DELETE */

struct DP_MsgLayerDelete {
    uint16_t id;
    uint16_t merge_to;
};

static size_t msg_layer_delete_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)4);
}

static size_t msg_layer_delete_serialize_payload(DP_Message *msg,
                                                 unsigned char *data)
{
    DP_MsgLayerDelete *mld = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mld->id, data + written);
    written += DP_write_bigendian_uint16(mld->merge_to, data + written);
    DP_ASSERT(written == msg_layer_delete_payload_length(msg));
    return written;
}

static bool msg_layer_delete_write_payload_text(DP_Message *msg,
                                                DP_TextWriter *writer)
{
    DP_MsgLayerDelete *mld = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "id", mld->id, true)
        && DP_text_writer_write_uint(writer, "merge_to", mld->merge_to, true);
}

static bool msg_layer_delete_equals(DP_Message *DP_RESTRICT msg,
                                    DP_Message *DP_RESTRICT other)
{
    DP_MsgLayerDelete *a = DP_message_internal(msg);
    DP_MsgLayerDelete *b = DP_message_internal(other);
    return a->id == b->id && a->merge_to == b->merge_to;
}

static const DP_MessageMethods msg_layer_delete_methods = {
    msg_layer_delete_payload_length,
    msg_layer_delete_serialize_payload,
    msg_layer_delete_write_payload_text,
    msg_layer_delete_equals,
};

DP_Message *DP_msg_layer_delete_new(unsigned int context_id, uint16_t id,
                                    uint16_t merge_to)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_LAYER_DELETE, context_id,
                       &msg_layer_delete_methods, sizeof(DP_MsgLayerDelete));
    DP_MsgLayerDelete *mld = DP_message_internal(msg);
    mld->id = id;
    mld->merge_to = merge_to;
    return msg;
}

DP_Message *DP_msg_layer_delete_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length)
{
    if (length != 4) {
        DP_error_set("Wrong length for deletelayer message; "
                     "expected 4, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t id = read_uint16(buffer + read, &read);
    uint16_t merge_to = read_uint16(buffer + read, &read);
    return DP_msg_layer_delete_new(context_id, id, merge_to);
}

DP_MsgLayerDelete *DP_msg_layer_delete_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_LAYER_DELETE);
}

uint16_t DP_msg_layer_delete_id(const DP_MsgLayerDelete *mld)
{
    DP_ASSERT(mld);
    return mld->id;
}

uint16_t DP_msg_layer_delete_merge_to(const DP_MsgLayerDelete *mld)
{
    DP_ASSERT(mld);
    return mld->merge_to;
}


/* DP_MSG_LAYER_VISIBILITY */

struct DP_MsgLayerVisibility {
    uint16_t id;
    bool visible;
};

static size_t msg_layer_visibility_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)3);
}

static size_t msg_layer_visibility_serialize_payload(DP_Message *msg,
                                                     unsigned char *data)
{
    DP_MsgLayerVisibility *mlv = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mlv->id, data + written);
    written += DP_write_bigendian_uint8(mlv->visible, data + written);
    DP_ASSERT(written == msg_layer_visibility_payload_length(msg));
    return written;
}

static bool msg_layer_visibility_write_payload_text(DP_Message *msg,
                                                    DP_TextWriter *writer)
{
    DP_MsgLayerVisibility *mlv = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "id", mlv->id, false)
        && DP_text_writer_write_bool(writer, "visible", mlv->visible);
}

static bool msg_layer_visibility_equals(DP_Message *DP_RESTRICT msg,
                                        DP_Message *DP_RESTRICT other)
{
    DP_MsgLayerVisibility *a = DP_message_internal(msg);
    DP_MsgLayerVisibility *b = DP_message_internal(other);
    return a->id == b->id && a->visible == b->visible;
}

static const DP_MessageMethods msg_layer_visibility_methods = {
    msg_layer_visibility_payload_length,
    msg_layer_visibility_serialize_payload,
    msg_layer_visibility_write_payload_text,
    msg_layer_visibility_equals,
};

DP_Message *DP_msg_layer_visibility_new(unsigned int context_id, uint16_t id,
                                        bool visible)
{
    DP_Message *msg = DP_message_new(DP_MSG_LAYER_VISIBILITY, context_id,
                                     &msg_layer_visibility_methods,
                                     sizeof(DP_MsgLayerVisibility));
    DP_MsgLayerVisibility *mlv = DP_message_internal(msg);
    mlv->id = id;
    mlv->visible = visible;
    return msg;
}

DP_Message *DP_msg_layer_visibility_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length)
{
    if (length != 3) {
        DP_error_set("Wrong length for layervisibility message; "
                     "expected 3, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t id = read_uint16(buffer + read, &read);
    bool visible = read_bool(buffer + read, &read);
    return DP_msg_layer_visibility_new(context_id, id, visible);
}

DP_MsgLayerVisibility *DP_msg_layer_visibility_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_LAYER_VISIBILITY);
}

uint16_t DP_msg_layer_visibility_id(const DP_MsgLayerVisibility *mlv)
{
    DP_ASSERT(mlv);
    return mlv->id;
}

bool DP_msg_layer_visibility_visible(const DP_MsgLayerVisibility *mlv)
{
    DP_ASSERT(mlv);
    return mlv->visible;
}


/* DP_MSG_PUT_IMAGE */

struct DP_MsgPutImage {
    uint16_t layer;
    uint8_t mode;
    uint32_t x;
    uint32_t y;
    uint32_t w;
    uint32_t h;
    uint16_t image_size;
    unsigned char image[];
};

static size_t msg_put_image_payload_length(DP_Message *msg)
{
    DP_MsgPutImage *mpi = DP_message_internal(msg);
    return ((size_t)19) + mpi->image_size;
}

static size_t msg_put_image_serialize_payload(DP_Message *msg,
                                              unsigned char *data)
{
    DP_MsgPutImage *mpi = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mpi->layer, data + written);
    written += DP_write_bigendian_uint8(mpi->mode, data + written);
    written += DP_write_bigendian_uint32(mpi->x, data + written);
    written += DP_write_bigendian_uint32(mpi->y, data + written);
    written += DP_write_bigendian_uint32(mpi->w, data + written);
    written += DP_write_bigendian_uint32(mpi->h, data + written);
    written += write_bytes(mpi->image, mpi->image_size, data + written);
    DP_ASSERT(written == msg_put_image_payload_length(msg));
    return written;
}

static bool msg_put_image_write_payload_text(DP_Message *msg,
                                             DP_TextWriter *writer)
{
    DP_MsgPutImage *mpi = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "h", mpi->h, false)
        && DP_text_writer_write_base64(writer, "image", mpi->image,
                                       mpi->image_size)
        && DP_text_writer_write_uint(writer, "layer", mpi->layer, true)
        && DP_text_writer_write_blend_mode(writer, "mode", mpi->mode)
        && DP_text_writer_write_uint(writer, "w", mpi->w, false)
        && DP_text_writer_write_uint(writer, "x", mpi->x, false)
        && DP_text_writer_write_uint(writer, "y", mpi->y, false);
}

static bool msg_put_image_equals(DP_Message *DP_RESTRICT msg,
                                 DP_Message *DP_RESTRICT other)
{
    DP_MsgPutImage *a = DP_message_internal(msg);
    DP_MsgPutImage *b = DP_message_internal(other);
    return a->layer == b->layer && a->mode == b->mode && a->x == b->x
        && a->y == b->y && a->w == b->w && a->h == b->h
        && a->image_size == b->image_size
        && memcmp(a->image, b->image, DP_uint16_to_size(a->image_size)) == 0;
}

static const DP_MessageMethods msg_put_image_methods = {
    msg_put_image_payload_length,
    msg_put_image_serialize_payload,
    msg_put_image_write_payload_text,
    msg_put_image_equals,
};

DP_Message *
DP_msg_put_image_new(unsigned int context_id, uint16_t layer, uint8_t mode,
                     uint32_t x, uint32_t y, uint32_t w, uint32_t h,
                     void (*set_image)(size_t, unsigned char *, void *),
                     size_t image_size, void *image_user)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_PUT_IMAGE, context_id, &msg_put_image_methods,
                       DP_FLEX_SIZEOF(DP_MsgPutImage, image, image_size));
    DP_MsgPutImage *mpi = DP_message_internal(msg);
    mpi->layer = layer;
    mpi->mode = mode;
    mpi->x = x;
    mpi->y = y;
    mpi->w = w;
    mpi->h = h;
    mpi->image_size = DP_size_to_uint16(image_size);
    if (set_image) {
        set_image(mpi->image_size, mpi->image, image_user);
    }
    return msg;
}

DP_Message *DP_msg_put_image_deserialize(unsigned int context_id,
                                         const unsigned char *buffer,
                                         size_t length)
{
    if (length < 19 || length > 65535) {
        DP_error_set("Wrong length for putimage message; "
                     "expected between 19 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t layer = read_uint16(buffer + read, &read);
    uint8_t mode = read_uint8(buffer + read, &read);
    uint32_t x = read_uint32(buffer + read, &read);
    uint32_t y = read_uint32(buffer + read, &read);
    uint32_t w = read_uint32(buffer + read, &read);
    uint32_t h = read_uint32(buffer + read, &read);
    size_t image_bytes = length - read;
    uint16_t image_size = DP_size_to_uint16(image_bytes);
    void *image_user = (void *)(buffer + read);
    return DP_msg_put_image_new(context_id, layer, mode, x, y, w, h, read_bytes,
                                image_size, image_user);
}

DP_MsgPutImage *DP_msg_put_image_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_PUT_IMAGE);
}

uint16_t DP_msg_put_image_layer(const DP_MsgPutImage *mpi)
{
    DP_ASSERT(mpi);
    return mpi->layer;
}

uint8_t DP_msg_put_image_mode(const DP_MsgPutImage *mpi)
{
    DP_ASSERT(mpi);
    return mpi->mode;
}

uint32_t DP_msg_put_image_x(const DP_MsgPutImage *mpi)
{
    DP_ASSERT(mpi);
    return mpi->x;
}

uint32_t DP_msg_put_image_y(const DP_MsgPutImage *mpi)
{
    DP_ASSERT(mpi);
    return mpi->y;
}

uint32_t DP_msg_put_image_w(const DP_MsgPutImage *mpi)
{
    DP_ASSERT(mpi);
    return mpi->w;
}

uint32_t DP_msg_put_image_h(const DP_MsgPutImage *mpi)
{
    DP_ASSERT(mpi);
    return mpi->h;
}

const unsigned char *DP_msg_put_image_image(const DP_MsgPutImage *mpi,
                                            size_t *out_size)
{
    DP_ASSERT(mpi);
    if (out_size) {
        *out_size = mpi->image_size;
    }
    return mpi->image;
}

size_t DP_msg_put_image_image_size(const DP_MsgPutImage *mpi)
{
    return mpi->image_size;
}


/* DP_MSG_FILL_RECT */

struct DP_MsgFillRect {
    uint16_t layer;
    uint8_t mode;
    uint32_t x;
    uint32_t y;
    uint32_t w;
    uint32_t h;
    uint32_t color;
};

static size_t msg_fill_rect_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)23);
}

static size_t msg_fill_rect_serialize_payload(DP_Message *msg,
                                              unsigned char *data)
{
    DP_MsgFillRect *mfr = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mfr->layer, data + written);
    written += DP_write_bigendian_uint8(mfr->mode, data + written);
    written += DP_write_bigendian_uint32(mfr->x, data + written);
    written += DP_write_bigendian_uint32(mfr->y, data + written);
    written += DP_write_bigendian_uint32(mfr->w, data + written);
    written += DP_write_bigendian_uint32(mfr->h, data + written);
    written += DP_write_bigendian_uint32(mfr->color, data + written);
    DP_ASSERT(written == msg_fill_rect_payload_length(msg));
    return written;
}

static bool msg_fill_rect_write_payload_text(DP_Message *msg,
                                             DP_TextWriter *writer)
{
    DP_MsgFillRect *mfr = DP_message_internal(msg);
    return DP_text_writer_write_argb_color(writer, "color", mfr->color)
        && DP_text_writer_write_uint(writer, "h", mfr->h, false)
        && DP_text_writer_write_uint(writer, "layer", mfr->layer, true)
        && DP_text_writer_write_blend_mode(writer, "mode", mfr->mode)
        && DP_text_writer_write_uint(writer, "w", mfr->w, false)
        && DP_text_writer_write_uint(writer, "x", mfr->x, false)
        && DP_text_writer_write_uint(writer, "y", mfr->y, false);
}

static bool msg_fill_rect_equals(DP_Message *DP_RESTRICT msg,
                                 DP_Message *DP_RESTRICT other)
{
    DP_MsgFillRect *a = DP_message_internal(msg);
    DP_MsgFillRect *b = DP_message_internal(other);
    return a->layer == b->layer && a->mode == b->mode && a->x == b->x
        && a->y == b->y && a->w == b->w && a->h == b->h && a->color == b->color;
}

static const DP_MessageMethods msg_fill_rect_methods = {
    msg_fill_rect_payload_length,
    msg_fill_rect_serialize_payload,
    msg_fill_rect_write_payload_text,
    msg_fill_rect_equals,
};

DP_Message *DP_msg_fill_rect_new(unsigned int context_id, uint16_t layer,
                                 uint8_t mode, uint32_t x, uint32_t y,
                                 uint32_t w, uint32_t h, uint32_t color)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_FILL_RECT, context_id, &msg_fill_rect_methods,
                       sizeof(DP_MsgFillRect));
    DP_MsgFillRect *mfr = DP_message_internal(msg);
    mfr->layer = layer;
    mfr->mode = mode;
    mfr->x = x;
    mfr->y = y;
    mfr->w = w;
    mfr->h = h;
    mfr->color = color;
    return msg;
}

DP_Message *DP_msg_fill_rect_deserialize(unsigned int context_id,
                                         const unsigned char *buffer,
                                         size_t length)
{
    if (length != 23) {
        DP_error_set("Wrong length for fillrect message; "
                     "expected 23, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t layer = read_uint16(buffer + read, &read);
    uint8_t mode = read_uint8(buffer + read, &read);
    uint32_t x = read_uint32(buffer + read, &read);
    uint32_t y = read_uint32(buffer + read, &read);
    uint32_t w = read_uint32(buffer + read, &read);
    uint32_t h = read_uint32(buffer + read, &read);
    uint32_t color = read_uint32(buffer + read, &read);
    return DP_msg_fill_rect_new(context_id, layer, mode, x, y, w, h, color);
}

DP_MsgFillRect *DP_msg_fill_rect_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_FILL_RECT);
}

uint16_t DP_msg_fill_rect_layer(const DP_MsgFillRect *mfr)
{
    DP_ASSERT(mfr);
    return mfr->layer;
}

uint8_t DP_msg_fill_rect_mode(const DP_MsgFillRect *mfr)
{
    DP_ASSERT(mfr);
    return mfr->mode;
}

uint32_t DP_msg_fill_rect_x(const DP_MsgFillRect *mfr)
{
    DP_ASSERT(mfr);
    return mfr->x;
}

uint32_t DP_msg_fill_rect_y(const DP_MsgFillRect *mfr)
{
    DP_ASSERT(mfr);
    return mfr->y;
}

uint32_t DP_msg_fill_rect_w(const DP_MsgFillRect *mfr)
{
    DP_ASSERT(mfr);
    return mfr->w;
}

uint32_t DP_msg_fill_rect_h(const DP_MsgFillRect *mfr)
{
    DP_ASSERT(mfr);
    return mfr->h;
}

uint32_t DP_msg_fill_rect_color(const DP_MsgFillRect *mfr)
{
    DP_ASSERT(mfr);
    return mfr->color;
}


/* DP_MSG_PEN_UP */

DP_Message *DP_msg_pen_up_new(unsigned int context_id)
{
    return DP_message_new(DP_MSG_PEN_UP, context_id, &zero_length_methods, 0);
}

DP_Message *DP_msg_pen_up_deserialize(unsigned int context_id,
                                      DP_UNUSED const unsigned char *buffer,
                                      size_t length)
{
    if (length != 0) {
        DP_error_set("Wrong length for penup message; "
                     "expected 0, got %zu",
                     length);
        return NULL;
    }
    return DP_msg_pen_up_new(context_id);
}


/* DP_MSG_ANNOTATION_CREATE */

struct DP_MsgAnnotationCreate {
    uint16_t id;
    int32_t x;
    int32_t y;
    uint16_t w;
    uint16_t h;
};

static size_t msg_annotation_create_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)14);
}

static size_t msg_annotation_create_serialize_payload(DP_Message *msg,
                                                      unsigned char *data)
{
    DP_MsgAnnotationCreate *mac = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mac->id, data + written);
    written += DP_write_bigendian_int32(mac->x, data + written);
    written += DP_write_bigendian_int32(mac->y, data + written);
    written += DP_write_bigendian_uint16(mac->w, data + written);
    written += DP_write_bigendian_uint16(mac->h, data + written);
    DP_ASSERT(written == msg_annotation_create_payload_length(msg));
    return written;
}

static bool msg_annotation_create_write_payload_text(DP_Message *msg,
                                                     DP_TextWriter *writer)
{
    DP_MsgAnnotationCreate *mac = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "h", mac->h, false)
        && DP_text_writer_write_uint(writer, "id", mac->id, true)
        && DP_text_writer_write_uint(writer, "w", mac->w, false)
        && DP_text_writer_write_int(writer, "x", mac->x)
        && DP_text_writer_write_int(writer, "y", mac->y);
}

static bool msg_annotation_create_equals(DP_Message *DP_RESTRICT msg,
                                         DP_Message *DP_RESTRICT other)
{
    DP_MsgAnnotationCreate *a = DP_message_internal(msg);
    DP_MsgAnnotationCreate *b = DP_message_internal(other);
    return a->id == b->id && a->x == b->x && a->y == b->y && a->w == b->w
        && a->h == b->h;
}

static const DP_MessageMethods msg_annotation_create_methods = {
    msg_annotation_create_payload_length,
    msg_annotation_create_serialize_payload,
    msg_annotation_create_write_payload_text,
    msg_annotation_create_equals,
};

DP_Message *DP_msg_annotation_create_new(unsigned int context_id, uint16_t id,
                                         int32_t x, int32_t y, uint16_t w,
                                         uint16_t h)
{
    DP_Message *msg = DP_message_new(DP_MSG_ANNOTATION_CREATE, context_id,
                                     &msg_annotation_create_methods,
                                     sizeof(DP_MsgAnnotationCreate));
    DP_MsgAnnotationCreate *mac = DP_message_internal(msg);
    mac->id = id;
    mac->x = x;
    mac->y = y;
    mac->w = w;
    mac->h = h;
    return msg;
}

DP_Message *DP_msg_annotation_create_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length)
{
    if (length != 14) {
        DP_error_set("Wrong length for newannotation message; "
                     "expected 14, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t id = read_uint16(buffer + read, &read);
    int32_t x = read_int32(buffer + read, &read);
    int32_t y = read_int32(buffer + read, &read);
    uint16_t w = read_uint16(buffer + read, &read);
    uint16_t h = read_uint16(buffer + read, &read);
    return DP_msg_annotation_create_new(context_id, id, x, y, w, h);
}

DP_MsgAnnotationCreate *DP_msg_annotation_create_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_ANNOTATION_CREATE);
}

uint16_t DP_msg_annotation_create_id(const DP_MsgAnnotationCreate *mac)
{
    DP_ASSERT(mac);
    return mac->id;
}

int32_t DP_msg_annotation_create_x(const DP_MsgAnnotationCreate *mac)
{
    DP_ASSERT(mac);
    return mac->x;
}

int32_t DP_msg_annotation_create_y(const DP_MsgAnnotationCreate *mac)
{
    DP_ASSERT(mac);
    return mac->y;
}

uint16_t DP_msg_annotation_create_w(const DP_MsgAnnotationCreate *mac)
{
    DP_ASSERT(mac);
    return mac->w;
}

uint16_t DP_msg_annotation_create_h(const DP_MsgAnnotationCreate *mac)
{
    DP_ASSERT(mac);
    return mac->h;
}


/* DP_MSG_ANNOTATION_RESHAPE */

struct DP_MsgAnnotationReshape {
    uint16_t id;
    int32_t x;
    int32_t y;
    uint16_t w;
    uint16_t h;
};

static size_t msg_annotation_reshape_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)14);
}

static size_t msg_annotation_reshape_serialize_payload(DP_Message *msg,
                                                       unsigned char *data)
{
    DP_MsgAnnotationReshape *mar = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mar->id, data + written);
    written += DP_write_bigendian_int32(mar->x, data + written);
    written += DP_write_bigendian_int32(mar->y, data + written);
    written += DP_write_bigendian_uint16(mar->w, data + written);
    written += DP_write_bigendian_uint16(mar->h, data + written);
    DP_ASSERT(written == msg_annotation_reshape_payload_length(msg));
    return written;
}

static bool msg_annotation_reshape_write_payload_text(DP_Message *msg,
                                                      DP_TextWriter *writer)
{
    DP_MsgAnnotationReshape *mar = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "h", mar->h, false)
        && DP_text_writer_write_uint(writer, "id", mar->id, true)
        && DP_text_writer_write_uint(writer, "w", mar->w, false)
        && DP_text_writer_write_int(writer, "x", mar->x)
        && DP_text_writer_write_int(writer, "y", mar->y);
}

static bool msg_annotation_reshape_equals(DP_Message *DP_RESTRICT msg,
                                          DP_Message *DP_RESTRICT other)
{
    DP_MsgAnnotationReshape *a = DP_message_internal(msg);
    DP_MsgAnnotationReshape *b = DP_message_internal(other);
    return a->id == b->id && a->x == b->x && a->y == b->y && a->w == b->w
        && a->h == b->h;
}

static const DP_MessageMethods msg_annotation_reshape_methods = {
    msg_annotation_reshape_payload_length,
    msg_annotation_reshape_serialize_payload,
    msg_annotation_reshape_write_payload_text,
    msg_annotation_reshape_equals,
};

DP_Message *DP_msg_annotation_reshape_new(unsigned int context_id, uint16_t id,
                                          int32_t x, int32_t y, uint16_t w,
                                          uint16_t h)
{
    DP_Message *msg = DP_message_new(DP_MSG_ANNOTATION_RESHAPE, context_id,
                                     &msg_annotation_reshape_methods,
                                     sizeof(DP_MsgAnnotationReshape));
    DP_MsgAnnotationReshape *mar = DP_message_internal(msg);
    mar->id = id;
    mar->x = x;
    mar->y = y;
    mar->w = w;
    mar->h = h;
    return msg;
}

DP_Message *DP_msg_annotation_reshape_deserialize(unsigned int context_id,
                                                  const unsigned char *buffer,
                                                  size_t length)
{
    if (length != 14) {
        DP_error_set("Wrong length for reshapeannotation message; "
                     "expected 14, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t id = read_uint16(buffer + read, &read);
    int32_t x = read_int32(buffer + read, &read);
    int32_t y = read_int32(buffer + read, &read);
    uint16_t w = read_uint16(buffer + read, &read);
    uint16_t h = read_uint16(buffer + read, &read);
    return DP_msg_annotation_reshape_new(context_id, id, x, y, w, h);
}

DP_MsgAnnotationReshape *DP_msg_annotation_reshape_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_ANNOTATION_RESHAPE);
}

uint16_t DP_msg_annotation_reshape_id(const DP_MsgAnnotationReshape *mar)
{
    DP_ASSERT(mar);
    return mar->id;
}

int32_t DP_msg_annotation_reshape_x(const DP_MsgAnnotationReshape *mar)
{
    DP_ASSERT(mar);
    return mar->x;
}

int32_t DP_msg_annotation_reshape_y(const DP_MsgAnnotationReshape *mar)
{
    DP_ASSERT(mar);
    return mar->y;
}

uint16_t DP_msg_annotation_reshape_w(const DP_MsgAnnotationReshape *mar)
{
    DP_ASSERT(mar);
    return mar->w;
}

uint16_t DP_msg_annotation_reshape_h(const DP_MsgAnnotationReshape *mar)
{
    DP_ASSERT(mar);
    return mar->h;
}


/* DP_MSG_ANNOTATION_EDIT */

const char *DP_msg_annotation_edit_flags_flag_name(unsigned int value)
{
    switch (value) {
    case DP_MSG_ANNOTATION_EDIT_FLAGS_PROTECT:
        return "protect";
    case DP_MSG_ANNOTATION_EDIT_FLAGS_VALIGN_CENTER:
        return "valign_center";
    case DP_MSG_ANNOTATION_EDIT_FLAGS_VALIGN_BOTTOM:
        return "valign_bottom";
    default:
        return NULL;
    }
}

struct DP_MsgAnnotationEdit {
    uint16_t id;
    uint32_t bg;
    uint8_t flags;
    uint8_t border;
    uint16_t text_len;
    char text[];
};

static size_t msg_annotation_edit_payload_length(DP_Message *msg)
{
    DP_MsgAnnotationEdit *mae = DP_message_internal(msg);
    return ((size_t)8) + DP_uint16_to_size(mae->text_len);
}

static size_t msg_annotation_edit_serialize_payload(DP_Message *msg,
                                                    unsigned char *data)
{
    DP_MsgAnnotationEdit *mae = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mae->id, data + written);
    written += DP_write_bigendian_uint32(mae->bg, data + written);
    written += DP_write_bigendian_uint8(mae->flags, data + written);
    written += DP_write_bigendian_uint8(mae->border, data + written);
    written += DP_write_bytes(mae->text, 1, mae->text_len, data + written);
    DP_ASSERT(written == msg_annotation_edit_payload_length(msg));
    return written;
}

static bool msg_annotation_edit_write_payload_text(DP_Message *msg,
                                                   DP_TextWriter *writer)
{
    DP_MsgAnnotationEdit *mae = DP_message_internal(msg);
    return DP_text_writer_write_argb_color(writer, "bg", mae->bg)
        && DP_text_writer_write_uint(writer, "border", mae->border, false)
        && DP_text_writer_write_flags(
               writer, "flags", mae->flags, 3,
               (const char *[]){"protect", "valign_center", "valign_bottom"},
               (unsigned int[]){DP_MSG_ANNOTATION_EDIT_FLAGS_PROTECT,
                                DP_MSG_ANNOTATION_EDIT_FLAGS_VALIGN_CENTER,
                                DP_MSG_ANNOTATION_EDIT_FLAGS_VALIGN_BOTTOM})
        && DP_text_writer_write_uint(writer, "id", mae->id, true)
        && DP_text_writer_write_string(writer, "text", mae->text);
}

static bool msg_annotation_edit_equals(DP_Message *DP_RESTRICT msg,
                                       DP_Message *DP_RESTRICT other)
{
    DP_MsgAnnotationEdit *a = DP_message_internal(msg);
    DP_MsgAnnotationEdit *b = DP_message_internal(other);
    return a->id == b->id && a->bg == b->bg && a->flags == b->flags
        && a->border == b->border && a->text_len == b->text_len
        && memcmp(a->text, b->text, a->text_len) == 0;
}

static const DP_MessageMethods msg_annotation_edit_methods = {
    msg_annotation_edit_payload_length,
    msg_annotation_edit_serialize_payload,
    msg_annotation_edit_write_payload_text,
    msg_annotation_edit_equals,
};

DP_Message *DP_msg_annotation_edit_new(unsigned int context_id, uint16_t id,
                                       uint32_t bg, uint8_t flags,
                                       uint8_t border, const char *text_value,
                                       size_t text_len)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_ANNOTATION_EDIT, context_id, &msg_annotation_edit_methods,
        DP_FLEX_SIZEOF(DP_MsgAnnotationEdit, text, text_len + 1));
    DP_MsgAnnotationEdit *mae = DP_message_internal(msg);
    mae->id = id;
    mae->bg = bg;
    mae->flags = flags;
    mae->border = border;
    mae->text_len = DP_size_to_uint16(text_len);
    assign_string(mae->text, text_value, mae->text_len);
    return msg;
}

DP_Message *DP_msg_annotation_edit_deserialize(unsigned int context_id,
                                               const unsigned char *buffer,
                                               size_t length)
{
    if (length < 8 || length > 65535) {
        DP_error_set("Wrong length for editannotation message; "
                     "expected between 8 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t id = read_uint16(buffer + read, &read);
    uint32_t bg = read_uint32(buffer + read, &read);
    uint8_t flags = read_uint8(buffer + read, &read);
    uint8_t border = read_uint8(buffer + read, &read);
    size_t text_bytes = length - read;
    uint16_t text_len = DP_size_to_uint16(text_bytes);
    const char *text = (const char *)buffer + read;
    return DP_msg_annotation_edit_new(context_id, id, bg, flags, border, text,
                                      text_len);
}

DP_MsgAnnotationEdit *DP_msg_annotation_edit_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_ANNOTATION_EDIT);
}

uint16_t DP_msg_annotation_edit_id(const DP_MsgAnnotationEdit *mae)
{
    DP_ASSERT(mae);
    return mae->id;
}

uint32_t DP_msg_annotation_edit_bg(const DP_MsgAnnotationEdit *mae)
{
    DP_ASSERT(mae);
    return mae->bg;
}

uint8_t DP_msg_annotation_edit_flags(const DP_MsgAnnotationEdit *mae)
{
    DP_ASSERT(mae);
    return mae->flags;
}

uint8_t DP_msg_annotation_edit_border(const DP_MsgAnnotationEdit *mae)
{
    DP_ASSERT(mae);
    return mae->border;
}

const char *DP_msg_annotation_edit_text(const DP_MsgAnnotationEdit *mae,
                                        size_t *out_len)
{
    DP_ASSERT(mae);
    if (out_len) {
        *out_len = mae->text_len;
    }
    return mae->text;
}

size_t DP_msg_annotation_edit_text_len(const DP_MsgAnnotationEdit *mae)
{
    return mae->text_len;
}


/* DP_MSG_ANNOTATION_DELETE */

struct DP_MsgAnnotationDelete {
    uint16_t id;
};

static size_t msg_annotation_delete_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)2);
}

static size_t msg_annotation_delete_serialize_payload(DP_Message *msg,
                                                      unsigned char *data)
{
    DP_MsgAnnotationDelete *mad = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mad->id, data + written);
    DP_ASSERT(written == msg_annotation_delete_payload_length(msg));
    return written;
}

static bool msg_annotation_delete_write_payload_text(DP_Message *msg,
                                                     DP_TextWriter *writer)
{
    DP_MsgAnnotationDelete *mad = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "id", mad->id, true);
}

static bool msg_annotation_delete_equals(DP_Message *DP_RESTRICT msg,
                                         DP_Message *DP_RESTRICT other)
{
    DP_MsgAnnotationDelete *a = DP_message_internal(msg);
    DP_MsgAnnotationDelete *b = DP_message_internal(other);
    return a->id == b->id;
}

static const DP_MessageMethods msg_annotation_delete_methods = {
    msg_annotation_delete_payload_length,
    msg_annotation_delete_serialize_payload,
    msg_annotation_delete_write_payload_text,
    msg_annotation_delete_equals,
};

DP_Message *DP_msg_annotation_delete_new(unsigned int context_id, uint16_t id)
{
    DP_Message *msg = DP_message_new(DP_MSG_ANNOTATION_DELETE, context_id,
                                     &msg_annotation_delete_methods,
                                     sizeof(DP_MsgAnnotationDelete));
    DP_MsgAnnotationDelete *mad = DP_message_internal(msg);
    mad->id = id;
    return msg;
}

DP_Message *DP_msg_annotation_delete_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length)
{
    if (length != 2) {
        DP_error_set("Wrong length for deleteannotation message; "
                     "expected 2, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t id = read_uint16(buffer + read, &read);
    return DP_msg_annotation_delete_new(context_id, id);
}

DP_MsgAnnotationDelete *DP_msg_annotation_delete_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_ANNOTATION_DELETE);
}

uint16_t DP_msg_annotation_delete_id(const DP_MsgAnnotationDelete *mad)
{
    DP_ASSERT(mad);
    return mad->id;
}


/* DP_MSG_MOVE_REGION */

struct DP_MsgMoveRegion {
    uint16_t layer;
    int32_t bx;
    int32_t by;
    int32_t bw;
    int32_t bh;
    int32_t x1;
    int32_t y1;
    int32_t x2;
    int32_t y2;
    int32_t x3;
    int32_t y3;
    int32_t x4;
    int32_t y4;
    uint16_t mask_size;
    unsigned char mask[];
};

static size_t msg_move_region_payload_length(DP_Message *msg)
{
    DP_MsgMoveRegion *mmr = DP_message_internal(msg);
    return ((size_t)50) + mmr->mask_size;
}

static size_t msg_move_region_serialize_payload(DP_Message *msg,
                                                unsigned char *data)
{
    DP_MsgMoveRegion *mmr = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mmr->layer, data + written);
    written += DP_write_bigendian_int32(mmr->bx, data + written);
    written += DP_write_bigendian_int32(mmr->by, data + written);
    written += DP_write_bigendian_int32(mmr->bw, data + written);
    written += DP_write_bigendian_int32(mmr->bh, data + written);
    written += DP_write_bigendian_int32(mmr->x1, data + written);
    written += DP_write_bigendian_int32(mmr->y1, data + written);
    written += DP_write_bigendian_int32(mmr->x2, data + written);
    written += DP_write_bigendian_int32(mmr->y2, data + written);
    written += DP_write_bigendian_int32(mmr->x3, data + written);
    written += DP_write_bigendian_int32(mmr->y3, data + written);
    written += DP_write_bigendian_int32(mmr->x4, data + written);
    written += DP_write_bigendian_int32(mmr->y4, data + written);
    written += write_bytes(mmr->mask, mmr->mask_size, data + written);
    DP_ASSERT(written == msg_move_region_payload_length(msg));
    return written;
}

static bool msg_move_region_write_payload_text(DP_Message *msg,
                                               DP_TextWriter *writer)
{
    DP_MsgMoveRegion *mmr = DP_message_internal(msg);
    return DP_text_writer_write_int(writer, "bh", mmr->bh)
        && DP_text_writer_write_int(writer, "bw", mmr->bw)
        && DP_text_writer_write_int(writer, "bx", mmr->bx)
        && DP_text_writer_write_int(writer, "by", mmr->by)
        && DP_text_writer_write_uint(writer, "layer", mmr->layer, true)
        && DP_text_writer_write_base64(writer, "mask", mmr->mask,
                                       mmr->mask_size)
        && DP_text_writer_write_int(writer, "x1", mmr->x1)
        && DP_text_writer_write_int(writer, "x2", mmr->x2)
        && DP_text_writer_write_int(writer, "x3", mmr->x3)
        && DP_text_writer_write_int(writer, "x4", mmr->x4)
        && DP_text_writer_write_int(writer, "y1", mmr->y1)
        && DP_text_writer_write_int(writer, "y2", mmr->y2)
        && DP_text_writer_write_int(writer, "y3", mmr->y3)
        && DP_text_writer_write_int(writer, "y4", mmr->y4);
}

static bool msg_move_region_equals(DP_Message *DP_RESTRICT msg,
                                   DP_Message *DP_RESTRICT other)
{
    DP_MsgMoveRegion *a = DP_message_internal(msg);
    DP_MsgMoveRegion *b = DP_message_internal(other);
    return a->layer == b->layer && a->bx == b->bx && a->by == b->by
        && a->bw == b->bw && a->bh == b->bh && a->x1 == b->x1 && a->y1 == b->y1
        && a->x2 == b->x2 && a->y2 == b->y2 && a->x3 == b->x3 && a->y3 == b->y3
        && a->x4 == b->x4 && a->y4 == b->y4 && a->mask_size == b->mask_size
        && memcmp(a->mask, b->mask, DP_uint16_to_size(a->mask_size)) == 0;
}

static const DP_MessageMethods msg_move_region_methods = {
    msg_move_region_payload_length,
    msg_move_region_serialize_payload,
    msg_move_region_write_payload_text,
    msg_move_region_equals,
};

DP_Message *
DP_msg_move_region_new(unsigned int context_id, uint16_t layer, int32_t bx,
                       int32_t by, int32_t bw, int32_t bh, int32_t x1,
                       int32_t y1, int32_t x2, int32_t y2, int32_t x3,
                       int32_t y3, int32_t x4, int32_t y4,
                       void (*set_mask)(size_t, unsigned char *, void *),
                       size_t mask_size, void *mask_user)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_MOVE_REGION, context_id, &msg_move_region_methods,
                       DP_FLEX_SIZEOF(DP_MsgMoveRegion, mask, mask_size));
    DP_MsgMoveRegion *mmr = DP_message_internal(msg);
    mmr->layer = layer;
    mmr->bx = bx;
    mmr->by = by;
    mmr->bw = bw;
    mmr->bh = bh;
    mmr->x1 = x1;
    mmr->y1 = y1;
    mmr->x2 = x2;
    mmr->y2 = y2;
    mmr->x3 = x3;
    mmr->y3 = y3;
    mmr->x4 = x4;
    mmr->y4 = y4;
    mmr->mask_size = DP_size_to_uint16(mask_size);
    if (set_mask) {
        set_mask(mmr->mask_size, mmr->mask, mask_user);
    }
    return msg;
}

DP_Message *DP_msg_move_region_deserialize(unsigned int context_id,
                                           const unsigned char *buffer,
                                           size_t length)
{
    if (length < 50 || length > 65535) {
        DP_error_set("Wrong length for moveregion message; "
                     "expected between 50 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t layer = read_uint16(buffer + read, &read);
    int32_t bx = read_int32(buffer + read, &read);
    int32_t by = read_int32(buffer + read, &read);
    int32_t bw = read_int32(buffer + read, &read);
    int32_t bh = read_int32(buffer + read, &read);
    int32_t x1 = read_int32(buffer + read, &read);
    int32_t y1 = read_int32(buffer + read, &read);
    int32_t x2 = read_int32(buffer + read, &read);
    int32_t y2 = read_int32(buffer + read, &read);
    int32_t x3 = read_int32(buffer + read, &read);
    int32_t y3 = read_int32(buffer + read, &read);
    int32_t x4 = read_int32(buffer + read, &read);
    int32_t y4 = read_int32(buffer + read, &read);
    size_t mask_bytes = length - read;
    uint16_t mask_size = DP_size_to_uint16(mask_bytes);
    void *mask_user = (void *)(buffer + read);
    return DP_msg_move_region_new(context_id, layer, bx, by, bw, bh, x1, y1, x2,
                                  y2, x3, y3, x4, y4, read_bytes, mask_size,
                                  mask_user);
}

DP_MsgMoveRegion *DP_msg_move_region_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_MOVE_REGION);
}

uint16_t DP_msg_move_region_layer(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->layer;
}

int32_t DP_msg_move_region_bx(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->bx;
}

int32_t DP_msg_move_region_by(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->by;
}

int32_t DP_msg_move_region_bw(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->bw;
}

int32_t DP_msg_move_region_bh(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->bh;
}

int32_t DP_msg_move_region_x1(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->x1;
}

int32_t DP_msg_move_region_y1(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->y1;
}

int32_t DP_msg_move_region_x2(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->x2;
}

int32_t DP_msg_move_region_y2(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->y2;
}

int32_t DP_msg_move_region_x3(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->x3;
}

int32_t DP_msg_move_region_y3(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->y3;
}

int32_t DP_msg_move_region_x4(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->x4;
}

int32_t DP_msg_move_region_y4(const DP_MsgMoveRegion *mmr)
{
    DP_ASSERT(mmr);
    return mmr->y4;
}

const unsigned char *DP_msg_move_region_mask(const DP_MsgMoveRegion *mmr,
                                             size_t *out_size)
{
    DP_ASSERT(mmr);
    if (out_size) {
        *out_size = mmr->mask_size;
    }
    return mmr->mask;
}

size_t DP_msg_move_region_mask_size(const DP_MsgMoveRegion *mmr)
{
    return mmr->mask_size;
}


/* DP_MSG_PUT_TILE */

struct DP_MsgPutTile {
    uint16_t layer;
    uint8_t sublayer;
    uint8_t last_touch;
    uint16_t col;
    uint16_t row;
    uint16_t repeat;
    uint16_t image_size;
    unsigned char image[];
};

static size_t msg_put_tile_payload_length(DP_Message *msg)
{
    DP_MsgPutTile *mpt = DP_message_internal(msg);
    return ((size_t)10) + mpt->image_size;
}

static size_t msg_put_tile_serialize_payload(DP_Message *msg,
                                             unsigned char *data)
{
    DP_MsgPutTile *mpt = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mpt->layer, data + written);
    written += DP_write_bigendian_uint8(mpt->sublayer, data + written);
    written += DP_write_bigendian_uint8(mpt->last_touch, data + written);
    written += DP_write_bigendian_uint16(mpt->col, data + written);
    written += DP_write_bigendian_uint16(mpt->row, data + written);
    written += DP_write_bigendian_uint16(mpt->repeat, data + written);
    written += write_bytes(mpt->image, mpt->image_size, data + written);
    DP_ASSERT(written == msg_put_tile_payload_length(msg));
    return written;
}

static bool msg_put_tile_write_payload_text(DP_Message *msg,
                                            DP_TextWriter *writer)
{
    DP_MsgPutTile *mpt = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "col", mpt->col, false)
        && DP_text_writer_write_base64(writer, "image", mpt->image,
                                       mpt->image_size)
        && DP_text_writer_write_uint(writer, "last_touch", mpt->last_touch,
                                     false)
        && DP_text_writer_write_uint(writer, "layer", mpt->layer, true)
        && DP_text_writer_write_uint(writer, "repeat", mpt->repeat, false)
        && DP_text_writer_write_uint(writer, "row", mpt->row, false)
        && DP_text_writer_write_uint(writer, "sublayer", mpt->sublayer, false);
}

static bool msg_put_tile_equals(DP_Message *DP_RESTRICT msg,
                                DP_Message *DP_RESTRICT other)
{
    DP_MsgPutTile *a = DP_message_internal(msg);
    DP_MsgPutTile *b = DP_message_internal(other);
    return a->layer == b->layer && a->sublayer == b->sublayer
        && a->last_touch == b->last_touch && a->col == b->col
        && a->row == b->row && a->repeat == b->repeat
        && a->image_size == b->image_size
        && memcmp(a->image, b->image, DP_uint16_to_size(a->image_size)) == 0;
}

static const DP_MessageMethods msg_put_tile_methods = {
    msg_put_tile_payload_length,
    msg_put_tile_serialize_payload,
    msg_put_tile_write_payload_text,
    msg_put_tile_equals,
};

DP_Message *DP_msg_put_tile_new(unsigned int context_id, uint16_t layer,
                                uint8_t sublayer, uint8_t last_touch,
                                uint16_t col, uint16_t row, uint16_t repeat,
                                void (*set_image)(size_t, unsigned char *,
                                                  void *),
                                size_t image_size, void *image_user)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_PUT_TILE, context_id, &msg_put_tile_methods,
                       DP_FLEX_SIZEOF(DP_MsgPutTile, image, image_size));
    DP_MsgPutTile *mpt = DP_message_internal(msg);
    mpt->layer = layer;
    mpt->sublayer = sublayer;
    mpt->last_touch = last_touch;
    mpt->col = col;
    mpt->row = row;
    mpt->repeat = repeat;
    mpt->image_size = DP_size_to_uint16(image_size);
    if (set_image) {
        set_image(mpt->image_size, mpt->image, image_user);
    }
    return msg;
}

DP_Message *DP_msg_put_tile_deserialize(unsigned int context_id,
                                        const unsigned char *buffer,
                                        size_t length)
{
    if (length < 10 || length > 65535) {
        DP_error_set("Wrong length for puttile message; "
                     "expected between 10 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t layer = read_uint16(buffer + read, &read);
    uint8_t sublayer = read_uint8(buffer + read, &read);
    uint8_t last_touch = read_uint8(buffer + read, &read);
    uint16_t col = read_uint16(buffer + read, &read);
    uint16_t row = read_uint16(buffer + read, &read);
    uint16_t repeat = read_uint16(buffer + read, &read);
    size_t image_bytes = length - read;
    uint16_t image_size = DP_size_to_uint16(image_bytes);
    void *image_user = (void *)(buffer + read);
    return DP_msg_put_tile_new(context_id, layer, sublayer, last_touch, col,
                               row, repeat, read_bytes, image_size, image_user);
}

DP_MsgPutTile *DP_msg_put_tile_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_PUT_TILE);
}

uint16_t DP_msg_put_tile_layer(const DP_MsgPutTile *mpt)
{
    DP_ASSERT(mpt);
    return mpt->layer;
}

uint8_t DP_msg_put_tile_sublayer(const DP_MsgPutTile *mpt)
{
    DP_ASSERT(mpt);
    return mpt->sublayer;
}

uint8_t DP_msg_put_tile_last_touch(const DP_MsgPutTile *mpt)
{
    DP_ASSERT(mpt);
    return mpt->last_touch;
}

uint16_t DP_msg_put_tile_col(const DP_MsgPutTile *mpt)
{
    DP_ASSERT(mpt);
    return mpt->col;
}

uint16_t DP_msg_put_tile_row(const DP_MsgPutTile *mpt)
{
    DP_ASSERT(mpt);
    return mpt->row;
}

uint16_t DP_msg_put_tile_repeat(const DP_MsgPutTile *mpt)
{
    DP_ASSERT(mpt);
    return mpt->repeat;
}

const unsigned char *DP_msg_put_tile_image(const DP_MsgPutTile *mpt,
                                           size_t *out_size)
{
    DP_ASSERT(mpt);
    if (out_size) {
        *out_size = mpt->image_size;
    }
    return mpt->image;
}

size_t DP_msg_put_tile_image_size(const DP_MsgPutTile *mpt)
{
    return mpt->image_size;
}


/* DP_MSG_CANVAS_BACKGROUND */

struct DP_MsgCanvasBackground {
    uint16_t image_size;
    unsigned char image[];
};

static size_t msg_canvas_background_payload_length(DP_Message *msg)
{
    DP_MsgCanvasBackground *mcb = DP_message_internal(msg);
    return mcb->image_size;
}

static size_t msg_canvas_background_serialize_payload(DP_Message *msg,
                                                      unsigned char *data)
{
    DP_MsgCanvasBackground *mcb = DP_message_internal(msg);
    size_t written = 0;
    written += write_bytes(mcb->image, mcb->image_size, data + written);
    DP_ASSERT(written == msg_canvas_background_payload_length(msg));
    return written;
}

static bool msg_canvas_background_write_payload_text(DP_Message *msg,
                                                     DP_TextWriter *writer)
{
    DP_MsgCanvasBackground *mcb = DP_message_internal(msg);
    return DP_text_writer_write_base64(writer, "image", mcb->image,
                                       mcb->image_size);
}

static bool msg_canvas_background_equals(DP_Message *DP_RESTRICT msg,
                                         DP_Message *DP_RESTRICT other)
{
    DP_MsgCanvasBackground *a = DP_message_internal(msg);
    DP_MsgCanvasBackground *b = DP_message_internal(other);
    return a->image_size == b->image_size
        && memcmp(a->image, b->image, DP_uint16_to_size(a->image_size)) == 0;
}

static const DP_MessageMethods msg_canvas_background_methods = {
    msg_canvas_background_payload_length,
    msg_canvas_background_serialize_payload,
    msg_canvas_background_write_payload_text,
    msg_canvas_background_equals,
};

DP_Message *
DP_msg_canvas_background_new(unsigned int context_id,
                             void (*set_image)(size_t, unsigned char *, void *),
                             size_t image_size, void *image_user)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_CANVAS_BACKGROUND, context_id, &msg_canvas_background_methods,
        DP_FLEX_SIZEOF(DP_MsgCanvasBackground, image, image_size));
    DP_MsgCanvasBackground *mcb = DP_message_internal(msg);
    mcb->image_size = DP_size_to_uint16(image_size);
    if (set_image) {
        set_image(mcb->image_size, mcb->image, image_user);
    }
    return msg;
}

DP_Message *DP_msg_canvas_background_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length)
{
    if (length > 65535) {
        DP_error_set("Wrong length for background message; "
                     "expected between 0 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    size_t image_bytes = length - read;
    uint16_t image_size = DP_size_to_uint16(image_bytes);
    void *image_user = (void *)(buffer + read);
    return DP_msg_canvas_background_new(context_id, read_bytes, image_size,
                                        image_user);
}

DP_MsgCanvasBackground *DP_msg_canvas_background_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_CANVAS_BACKGROUND);
}

const unsigned char *
DP_msg_canvas_background_image(const DP_MsgCanvasBackground *mcb,
                               size_t *out_size)
{
    DP_ASSERT(mcb);
    if (out_size) {
        *out_size = mcb->image_size;
    }
    return mcb->image;
}

size_t DP_msg_canvas_background_image_size(const DP_MsgCanvasBackground *mcb)
{
    return mcb->image_size;
}


/* DP_MSG_DRAW_DABS_CLASSIC */

struct DP_ClassicDab {
    int8_t x;
    int8_t y;
    uint16_t size;
    uint8_t hardness;
    uint8_t opacity;
};

static size_t classic_dab_serialize_payload(DP_ClassicDab *cd,
                                            unsigned char *data)
{
    size_t written = 0;
    written += DP_write_bigendian_int8(cd->x, data + written);
    written += DP_write_bigendian_int8(cd->y, data + written);
    written += DP_write_bigendian_uint16(cd->size, data + written);
    written += DP_write_bigendian_uint8(cd->hardness, data + written);
    written += DP_write_bigendian_uint8(cd->opacity, data + written);
    return written;
}

static size_t classic_dab_serialize_payloads(DP_ClassicDab *cd, int count,
                                             unsigned char *data)
{
    size_t written = 0;
    for (int i = 0; i < count; ++i) {
        written += classic_dab_serialize_payload(&cd[i], data + written);
    }
    return written;
}

static bool classic_dab_write_payload_text(DP_ClassicDab *cd,
                                           DP_TextWriter *writer)
{
    return DP_TEXT_WRITER_RAW_PRINT_LITERAL(writer, "   ")
        && DP_text_writer_write_subfield_decimal(writer, (double)cd->x / 4.0)
        && DP_text_writer_write_subfield_decimal(writer, (double)cd->y / 4.0)
        && DP_text_writer_write_subfield_decimal(writer,
                                                 (double)cd->size / 256.0)
        && DP_text_writer_write_subfield_uint(writer, cd->hardness)
        && DP_text_writer_write_subfield_uint(writer, cd->opacity)
        && DP_TEXT_WRITER_RAW_PRINT_LITERAL(writer, "\n");
}

static size_t classic_dab_write_payload_texts(DP_ClassicDab *cd, int count,
                                              DP_TextWriter *writer)
{
    if (!DP_TEXT_WRITER_RAW_PRINT_LITERAL(writer, " {\n")) {
        return false;
    }
    for (int i = 0; i < count; ++i) {
        if (!classic_dab_write_payload_text(&cd[i], writer)) {
            return false;
        }
    }
    return DP_TEXT_WRITER_RAW_PRINT_LITERAL(writer, "}");
}

static bool classic_dab_equals(DP_ClassicDab *DP_RESTRICT a,
                               DP_ClassicDab *DP_RESTRICT b)
{
    return a->x == b->x && a->y == b->y && a->size == b->size
        && a->hardness == b->hardness && a->opacity == b->opacity;
}

static bool classic_dabs_equal(DP_ClassicDab *DP_RESTRICT a,
                               DP_ClassicDab *DP_RESTRICT b, int count)
{
    for (int i = 0; i < count; ++i) {
        if (!classic_dab_equals(&a[i], &b[i])) {
            return false;
        }
    }
    return true;
}

void DP_classic_dab_init(DP_ClassicDab *cds, int i, int8_t x, int8_t y,
                         uint16_t size, uint8_t hardness, uint8_t opacity)
{
    DP_ASSERT(cds);
    DP_ClassicDab *cd = &cds[i];
    cd->x = x;
    cd->y = y;
    cd->size = size;
    cd->hardness = hardness;
    cd->opacity = opacity;
}

void classic_dab_deserialize(int count, DP_ClassicDab *cds, void *user)
{
    const unsigned char *buffer = user;
    size_t read = 0;
    for (int i = 0; i < count; ++i) {
        int8_t x = read_int8(buffer + read, &read);
        int8_t y = read_int8(buffer + read, &read);
        uint16_t size = read_uint16(buffer + read, &read);
        uint8_t hardness = read_uint8(buffer + read, &read);
        uint8_t opacity = read_uint8(buffer + read, &read);
        DP_classic_dab_init(cds, i, x, y, size, hardness, opacity);
    }
}

int8_t DP_classic_dab_x(const DP_ClassicDab *cd)
{
    DP_ASSERT(cd);
    return cd->x;
}

int8_t DP_classic_dab_y(const DP_ClassicDab *cd)
{
    DP_ASSERT(cd);
    return cd->y;
}

uint16_t DP_classic_dab_size(const DP_ClassicDab *cd)
{
    DP_ASSERT(cd);
    return cd->size;
}

uint8_t DP_classic_dab_hardness(const DP_ClassicDab *cd)
{
    DP_ASSERT(cd);
    return cd->hardness;
}

uint8_t DP_classic_dab_opacity(const DP_ClassicDab *cd)
{
    DP_ASSERT(cd);
    return cd->opacity;
}

const DP_ClassicDab *DP_classic_dab_at(const DP_ClassicDab *cd, int i)
{
    DP_ASSERT(cd);
    return &cd[i];
}

struct DP_MsgDrawDabsClassic {
    uint16_t layer;
    int32_t x;
    int32_t y;
    uint32_t color;
    uint8_t mode;
    uint16_t dabs_count;
    DP_ClassicDab dabs[];
};

static size_t msg_draw_dabs_classic_payload_length(DP_Message *msg)
{
    DP_MsgDrawDabsClassic *mddc = DP_message_internal(msg);
    return ((size_t)15) + DP_int_to_size(mddc->dabs_count) * 6;
}

static size_t msg_draw_dabs_classic_serialize_payload(DP_Message *msg,
                                                      unsigned char *data)
{
    DP_MsgDrawDabsClassic *mddc = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mddc->layer, data + written);
    written += DP_write_bigendian_int32(mddc->x, data + written);
    written += DP_write_bigendian_int32(mddc->y, data + written);
    written += DP_write_bigendian_uint32(mddc->color, data + written);
    written += DP_write_bigendian_uint8(mddc->mode, data + written);
    written += classic_dab_serialize_payloads(mddc->dabs, mddc->dabs_count,
                                              data + written);
    DP_ASSERT(written == msg_draw_dabs_classic_payload_length(msg));
    return written;
}

static bool msg_draw_dabs_classic_write_payload_text(DP_Message *msg,
                                                     DP_TextWriter *writer)
{
    DP_MsgDrawDabsClassic *mddc = DP_message_internal(msg);
    return DP_text_writer_write_argb_color(writer, "color", mddc->color)
        && DP_text_writer_write_uint(writer, "layer", mddc->layer, true)
        && DP_text_writer_write_blend_mode(writer, "mode", mddc->mode)
        && DP_text_writer_write_decimal(writer, "x", (double)mddc->x / 4.0)
        && DP_text_writer_write_decimal(writer, "y", (double)mddc->y / 4.0)
        && classic_dab_write_payload_texts(mddc->dabs, mddc->dabs_count,
                                           writer);
}

static bool msg_draw_dabs_classic_equals(DP_Message *DP_RESTRICT msg,
                                         DP_Message *DP_RESTRICT other)
{
    DP_MsgDrawDabsClassic *a = DP_message_internal(msg);
    DP_MsgDrawDabsClassic *b = DP_message_internal(other);
    return a->layer == b->layer && a->x == b->x && a->y == b->y
        && a->color == b->color && a->mode == b->mode
        && a->dabs_count == b->dabs_count
        && classic_dabs_equal(a->dabs, b->dabs, a->dabs_count);
}

static const DP_MessageMethods msg_draw_dabs_classic_methods = {
    msg_draw_dabs_classic_payload_length,
    msg_draw_dabs_classic_serialize_payload,
    msg_draw_dabs_classic_write_payload_text,
    msg_draw_dabs_classic_equals,
};

DP_Message *
DP_msg_draw_dabs_classic_new(unsigned int context_id, uint16_t layer, int32_t x,
                             int32_t y, uint32_t color, uint8_t mode,
                             void (*set_dabs)(int, DP_ClassicDab *, void *),
                             int dabs_count, void *dabs_user)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_DRAW_DABS_CLASSIC, context_id, &msg_draw_dabs_classic_methods,
        DP_FLEX_SIZEOF(DP_MsgDrawDabsClassic, dabs,
                       DP_int_to_size(dabs_count) * sizeof(DP_ClassicDab)));
    DP_MsgDrawDabsClassic *mddc = DP_message_internal(msg);
    mddc->layer = layer;
    mddc->x = x;
    mddc->y = y;
    mddc->color = color;
    mddc->mode = mode;
    mddc->dabs_count = DP_int_to_uint16(dabs_count);
    set_dabs(mddc->dabs_count, mddc->dabs, dabs_user);
    return msg;
}

DP_Message *DP_msg_draw_dabs_classic_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length)
{
    if (length < 21 || length > 65535) {
        DP_error_set("Wrong length for classicdabs message; "
                     "expected between 21 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t layer = read_uint16(buffer + read, &read);
    int32_t x = read_int32(buffer + read, &read);
    int32_t y = read_int32(buffer + read, &read);
    uint32_t color = read_uint32(buffer + read, &read);
    uint8_t mode = read_uint8(buffer + read, &read);
    size_t dabs_bytes = length - read;
    if ((dabs_bytes % 6) != 0) {
        DP_error_set("Wrong length for dabs field in classicdabs message; "
                     "%zu not divisible by 6",
                     dabs_bytes);
        return NULL;
    }
    int dabs_count = DP_size_to_int(dabs_bytes) / 6;
    void *dabs_user = (void *)(buffer + read);
    return DP_msg_draw_dabs_classic_new(context_id, layer, x, y, color, mode,
                                        classic_dab_deserialize, dabs_count,
                                        dabs_user);
}

DP_MsgDrawDabsClassic *DP_msg_draw_dabs_classic_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_DRAW_DABS_CLASSIC);
}

uint16_t DP_msg_draw_dabs_classic_layer(const DP_MsgDrawDabsClassic *mddc)
{
    DP_ASSERT(mddc);
    return mddc->layer;
}

int32_t DP_msg_draw_dabs_classic_x(const DP_MsgDrawDabsClassic *mddc)
{
    DP_ASSERT(mddc);
    return mddc->x;
}

int32_t DP_msg_draw_dabs_classic_y(const DP_MsgDrawDabsClassic *mddc)
{
    DP_ASSERT(mddc);
    return mddc->y;
}

uint32_t DP_msg_draw_dabs_classic_color(const DP_MsgDrawDabsClassic *mddc)
{
    DP_ASSERT(mddc);
    return mddc->color;
}

uint8_t DP_msg_draw_dabs_classic_mode(const DP_MsgDrawDabsClassic *mddc)
{
    DP_ASSERT(mddc);
    return mddc->mode;
}

const DP_ClassicDab *
DP_msg_draw_dabs_classic_dabs(const DP_MsgDrawDabsClassic *mddc, int *out_count)
{
    DP_ASSERT(mddc);
    if (out_count) {
        *out_count = mddc->dabs_count;
    }
    return mddc->dabs;
}

int DP_msg_draw_dabs_classic_dabs_count(const DP_MsgDrawDabsClassic *mddc)
{
    return mddc->dabs_count;
}


/* DP_MSG_DRAW_DABS_PIXEL */

struct DP_PixelDab {
    int8_t x;
    int8_t y;
    uint8_t size;
    uint8_t opacity;
};

static size_t pixel_dab_serialize_payload(DP_PixelDab *pd, unsigned char *data)
{
    size_t written = 0;
    written += DP_write_bigendian_int8(pd->x, data + written);
    written += DP_write_bigendian_int8(pd->y, data + written);
    written += DP_write_bigendian_uint8(pd->size, data + written);
    written += DP_write_bigendian_uint8(pd->opacity, data + written);
    return written;
}

static size_t pixel_dab_serialize_payloads(DP_PixelDab *pd, int count,
                                           unsigned char *data)
{
    size_t written = 0;
    for (int i = 0; i < count; ++i) {
        written += pixel_dab_serialize_payload(&pd[i], data + written);
    }
    return written;
}

static bool pixel_dab_write_payload_text(DP_PixelDab *pd, DP_TextWriter *writer)
{
    return DP_TEXT_WRITER_RAW_PRINT_LITERAL(writer, "   ")
        && DP_text_writer_write_subfield_int(writer, pd->x)
        && DP_text_writer_write_subfield_int(writer, pd->y)
        && DP_text_writer_write_subfield_uint(writer, pd->size)
        && DP_text_writer_write_subfield_uint(writer, pd->opacity)
        && DP_TEXT_WRITER_RAW_PRINT_LITERAL(writer, "\n");
}

static size_t pixel_dab_write_payload_texts(DP_PixelDab *pd, int count,
                                            DP_TextWriter *writer)
{
    if (!DP_TEXT_WRITER_RAW_PRINT_LITERAL(writer, " {\n")) {
        return false;
    }
    for (int i = 0; i < count; ++i) {
        if (!pixel_dab_write_payload_text(&pd[i], writer)) {
            return false;
        }
    }
    return DP_TEXT_WRITER_RAW_PRINT_LITERAL(writer, "}");
}

static bool pixel_dab_equals(DP_PixelDab *DP_RESTRICT a,
                             DP_PixelDab *DP_RESTRICT b)
{
    return a->x == b->x && a->y == b->y && a->size == b->size
        && a->opacity == b->opacity;
}

static bool pixel_dabs_equal(DP_PixelDab *DP_RESTRICT a,
                             DP_PixelDab *DP_RESTRICT b, int count)
{
    for (int i = 0; i < count; ++i) {
        if (!pixel_dab_equals(&a[i], &b[i])) {
            return false;
        }
    }
    return true;
}

void DP_pixel_dab_init(DP_PixelDab *pds, int i, int8_t x, int8_t y,
                       uint8_t size, uint8_t opacity)
{
    DP_ASSERT(pds);
    DP_PixelDab *pd = &pds[i];
    pd->x = x;
    pd->y = y;
    pd->size = size;
    pd->opacity = opacity;
}

void pixel_dab_deserialize(int count, DP_PixelDab *pds, void *user)
{
    const unsigned char *buffer = user;
    size_t read = 0;
    for (int i = 0; i < count; ++i) {
        int8_t x = read_int8(buffer + read, &read);
        int8_t y = read_int8(buffer + read, &read);
        uint8_t size = read_uint8(buffer + read, &read);
        uint8_t opacity = read_uint8(buffer + read, &read);
        DP_pixel_dab_init(pds, i, x, y, size, opacity);
    }
}

int8_t DP_pixel_dab_x(const DP_PixelDab *pd)
{
    DP_ASSERT(pd);
    return pd->x;
}

int8_t DP_pixel_dab_y(const DP_PixelDab *pd)
{
    DP_ASSERT(pd);
    return pd->y;
}

uint8_t DP_pixel_dab_size(const DP_PixelDab *pd)
{
    DP_ASSERT(pd);
    return pd->size;
}

uint8_t DP_pixel_dab_opacity(const DP_PixelDab *pd)
{
    DP_ASSERT(pd);
    return pd->opacity;
}

const DP_PixelDab *DP_pixel_dab_at(const DP_PixelDab *pd, int i)
{
    DP_ASSERT(pd);
    return &pd[i];
}

struct DP_MsgDrawDabsPixel {
    uint16_t layer;
    int32_t x;
    int32_t y;
    uint32_t color;
    uint8_t mode;
    uint16_t dabs_count;
    DP_PixelDab dabs[];
};

static size_t msg_draw_dabs_pixel_payload_length(DP_Message *msg)
{
    DP_MsgDrawDabsPixel *mddp = DP_message_internal(msg);
    return ((size_t)15) + DP_int_to_size(mddp->dabs_count) * 4;
}

static size_t msg_draw_dabs_pixel_serialize_payload(DP_Message *msg,
                                                    unsigned char *data)
{
    DP_MsgDrawDabsPixel *mddp = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mddp->layer, data + written);
    written += DP_write_bigendian_int32(mddp->x, data + written);
    written += DP_write_bigendian_int32(mddp->y, data + written);
    written += DP_write_bigendian_uint32(mddp->color, data + written);
    written += DP_write_bigendian_uint8(mddp->mode, data + written);
    written += pixel_dab_serialize_payloads(mddp->dabs, mddp->dabs_count,
                                            data + written);
    DP_ASSERT(written == msg_draw_dabs_pixel_payload_length(msg));
    return written;
}

static bool msg_draw_dabs_pixel_write_payload_text(DP_Message *msg,
                                                   DP_TextWriter *writer)
{
    DP_MsgDrawDabsPixel *mddp = DP_message_internal(msg);
    return DP_text_writer_write_argb_color(writer, "color", mddp->color)
        && DP_text_writer_write_uint(writer, "layer", mddp->layer, true)
        && DP_text_writer_write_blend_mode(writer, "mode", mddp->mode)
        && DP_text_writer_write_int(writer, "x", mddp->x)
        && DP_text_writer_write_int(writer, "y", mddp->y)
        && pixel_dab_write_payload_texts(mddp->dabs, mddp->dabs_count, writer);
}

static bool msg_draw_dabs_pixel_equals(DP_Message *DP_RESTRICT msg,
                                       DP_Message *DP_RESTRICT other)
{
    DP_MsgDrawDabsPixel *a = DP_message_internal(msg);
    DP_MsgDrawDabsPixel *b = DP_message_internal(other);
    return a->layer == b->layer && a->x == b->x && a->y == b->y
        && a->color == b->color && a->mode == b->mode
        && a->dabs_count == b->dabs_count
        && pixel_dabs_equal(a->dabs, b->dabs, a->dabs_count);
}

static const DP_MessageMethods msg_draw_dabs_pixel_methods = {
    msg_draw_dabs_pixel_payload_length,
    msg_draw_dabs_pixel_serialize_payload,
    msg_draw_dabs_pixel_write_payload_text,
    msg_draw_dabs_pixel_equals,
};

DP_Message *
DP_msg_draw_dabs_pixel_new(unsigned int context_id, uint16_t layer, int32_t x,
                           int32_t y, uint32_t color, uint8_t mode,
                           void (*set_dabs)(int, DP_PixelDab *, void *),
                           int dabs_count, void *dabs_user)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_DRAW_DABS_PIXEL, context_id, &msg_draw_dabs_pixel_methods,
        DP_FLEX_SIZEOF(DP_MsgDrawDabsPixel, dabs,
                       DP_int_to_size(dabs_count) * sizeof(DP_PixelDab)));
    DP_MsgDrawDabsPixel *mddp = DP_message_internal(msg);
    mddp->layer = layer;
    mddp->x = x;
    mddp->y = y;
    mddp->color = color;
    mddp->mode = mode;
    mddp->dabs_count = DP_int_to_uint16(dabs_count);
    set_dabs(mddp->dabs_count, mddp->dabs, dabs_user);
    return msg;
}

DP_Message *DP_msg_draw_dabs_pixel_deserialize(unsigned int context_id,
                                               const unsigned char *buffer,
                                               size_t length)
{
    if (length < 19 || length > 65535) {
        DP_error_set("Wrong length for pixeldabs message; "
                     "expected between 19 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t layer = read_uint16(buffer + read, &read);
    int32_t x = read_int32(buffer + read, &read);
    int32_t y = read_int32(buffer + read, &read);
    uint32_t color = read_uint32(buffer + read, &read);
    uint8_t mode = read_uint8(buffer + read, &read);
    size_t dabs_bytes = length - read;
    if ((dabs_bytes % 4) != 0) {
        DP_error_set("Wrong length for dabs field in pixeldabs message; "
                     "%zu not divisible by 4",
                     dabs_bytes);
        return NULL;
    }
    int dabs_count = DP_size_to_int(dabs_bytes) / 4;
    void *dabs_user = (void *)(buffer + read);
    return DP_msg_draw_dabs_pixel_new(context_id, layer, x, y, color, mode,
                                      pixel_dab_deserialize, dabs_count,
                                      dabs_user);
}

DP_MsgDrawDabsPixel *DP_msg_draw_dabs_pixel_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_DRAW_DABS_PIXEL);
}

uint16_t DP_msg_draw_dabs_pixel_layer(const DP_MsgDrawDabsPixel *mddp)
{
    DP_ASSERT(mddp);
    return mddp->layer;
}

int32_t DP_msg_draw_dabs_pixel_x(const DP_MsgDrawDabsPixel *mddp)
{
    DP_ASSERT(mddp);
    return mddp->x;
}

int32_t DP_msg_draw_dabs_pixel_y(const DP_MsgDrawDabsPixel *mddp)
{
    DP_ASSERT(mddp);
    return mddp->y;
}

uint32_t DP_msg_draw_dabs_pixel_color(const DP_MsgDrawDabsPixel *mddp)
{
    DP_ASSERT(mddp);
    return mddp->color;
}

uint8_t DP_msg_draw_dabs_pixel_mode(const DP_MsgDrawDabsPixel *mddp)
{
    DP_ASSERT(mddp);
    return mddp->mode;
}

const DP_PixelDab *DP_msg_draw_dabs_pixel_dabs(const DP_MsgDrawDabsPixel *mddp,
                                               int *out_count)
{
    DP_ASSERT(mddp);
    if (out_count) {
        *out_count = mddp->dabs_count;
    }
    return mddp->dabs;
}

int DP_msg_draw_dabs_pixel_dabs_count(const DP_MsgDrawDabsPixel *mddp)
{
    return mddp->dabs_count;
}


/* DP_MSG_DRAW_DABS_PIXEL_SQUARE */

DP_Message *DP_msg_draw_dabs_pixel_square_new(
    unsigned int context_id, uint16_t layer, int32_t x, int32_t y,
    uint32_t color, uint8_t mode, void (*set_dabs)(int, DP_PixelDab *, void *),
    int dabs_count, void *dabs_user)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_DRAW_DABS_PIXEL_SQUARE, context_id, &msg_draw_dabs_pixel_methods,
        DP_FLEX_SIZEOF(DP_MsgDrawDabsPixel, dabs,
                       DP_int_to_size(dabs_count) * sizeof(DP_PixelDab)));
    DP_MsgDrawDabsPixel *mddps = DP_message_internal(msg);
    mddps->layer = layer;
    mddps->x = x;
    mddps->y = y;
    mddps->color = color;
    mddps->mode = mode;
    mddps->dabs_count = DP_int_to_uint16(dabs_count);
    set_dabs(mddps->dabs_count, mddps->dabs, dabs_user);
    return msg;
}

DP_Message *DP_msg_draw_dabs_pixel_square_deserialize(
    unsigned int context_id, const unsigned char *buffer, size_t length)
{
    if (length < 19 || length > 65535) {
        DP_error_set("Wrong length for squarepixeldabs message; "
                     "expected between 19 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t layer = read_uint16(buffer + read, &read);
    int32_t x = read_int32(buffer + read, &read);
    int32_t y = read_int32(buffer + read, &read);
    uint32_t color = read_uint32(buffer + read, &read);
    uint8_t mode = read_uint8(buffer + read, &read);
    size_t dabs_bytes = length - read;
    if ((dabs_bytes % 4) != 0) {
        DP_error_set("Wrong length for dabs field in squarepixeldabs message; "
                     "%zu not divisible by 4",
                     dabs_bytes);
        return NULL;
    }
    int dabs_count = DP_size_to_int(dabs_bytes) / 4;
    void *dabs_user = (void *)(buffer + read);
    return DP_msg_draw_dabs_pixel_square_new(context_id, layer, x, y, color,
                                             mode, pixel_dab_deserialize,
                                             dabs_count, dabs_user);
}

DP_MsgDrawDabsPixel *DP_msg_draw_dabs_pixel_square_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_DRAW_DABS_PIXEL_SQUARE);
}


/* DP_MSG_DRAW_DABS_MYPAINT */

struct DP_MyPaintDab {
    int8_t x;
    int8_t y;
    uint16_t size;
    uint8_t hardness;
    uint8_t opacity;
    uint8_t angle;
    uint8_t aspect_ratio;
};

static size_t mypaint_dab_serialize_payload(DP_MyPaintDab *mpd,
                                            unsigned char *data)
{
    size_t written = 0;
    written += DP_write_bigendian_int8(mpd->x, data + written);
    written += DP_write_bigendian_int8(mpd->y, data + written);
    written += DP_write_bigendian_uint16(mpd->size, data + written);
    written += DP_write_bigendian_uint8(mpd->hardness, data + written);
    written += DP_write_bigendian_uint8(mpd->opacity, data + written);
    written += DP_write_bigendian_uint8(mpd->angle, data + written);
    written += DP_write_bigendian_uint8(mpd->aspect_ratio, data + written);
    return written;
}

static size_t mypaint_dab_serialize_payloads(DP_MyPaintDab *mpd, int count,
                                             unsigned char *data)
{
    size_t written = 0;
    for (int i = 0; i < count; ++i) {
        written += mypaint_dab_serialize_payload(&mpd[i], data + written);
    }
    return written;
}

static bool mypaint_dab_write_payload_text(DP_MyPaintDab *mpd,
                                           DP_TextWriter *writer)
{
    return DP_TEXT_WRITER_RAW_PRINT_LITERAL(writer, "   ")
        && DP_text_writer_write_subfield_decimal(writer, (double)mpd->x / 4.0)
        && DP_text_writer_write_subfield_decimal(writer, (double)mpd->y / 4.0)
        && DP_text_writer_write_subfield_decimal(writer,
                                                 (double)mpd->size / 256.0)
        && DP_text_writer_write_subfield_uint(writer, mpd->hardness)
        && DP_text_writer_write_subfield_uint(writer, mpd->opacity)
        && DP_text_writer_write_subfield_uint(writer, mpd->angle)
        && DP_text_writer_write_subfield_uint(writer, mpd->aspect_ratio)
        && DP_TEXT_WRITER_RAW_PRINT_LITERAL(writer, "\n");
}

static size_t mypaint_dab_write_payload_texts(DP_MyPaintDab *mpd, int count,
                                              DP_TextWriter *writer)
{
    if (!DP_TEXT_WRITER_RAW_PRINT_LITERAL(writer, " {\n")) {
        return false;
    }
    for (int i = 0; i < count; ++i) {
        if (!mypaint_dab_write_payload_text(&mpd[i], writer)) {
            return false;
        }
    }
    return DP_TEXT_WRITER_RAW_PRINT_LITERAL(writer, "}");
}

static bool mypaint_dab_equals(DP_MyPaintDab *DP_RESTRICT a,
                               DP_MyPaintDab *DP_RESTRICT b)
{
    return a->x == b->x && a->y == b->y && a->size == b->size
        && a->hardness == b->hardness && a->opacity == b->opacity
        && a->angle == b->angle && a->aspect_ratio == b->aspect_ratio;
}

static bool mypaint_dabs_equal(DP_MyPaintDab *DP_RESTRICT a,
                               DP_MyPaintDab *DP_RESTRICT b, int count)
{
    for (int i = 0; i < count; ++i) {
        if (!mypaint_dab_equals(&a[i], &b[i])) {
            return false;
        }
    }
    return true;
}

void DP_mypaint_dab_init(DP_MyPaintDab *mpds, int i, int8_t x, int8_t y,
                         uint16_t size, uint8_t hardness, uint8_t opacity,
                         uint8_t angle, uint8_t aspect_ratio)
{
    DP_ASSERT(mpds);
    DP_MyPaintDab *mpd = &mpds[i];
    mpd->x = x;
    mpd->y = y;
    mpd->size = size;
    mpd->hardness = hardness;
    mpd->opacity = opacity;
    mpd->angle = angle;
    mpd->aspect_ratio = aspect_ratio;
}

void mypaint_dab_deserialize(int count, DP_MyPaintDab *mpds, void *user)
{
    const unsigned char *buffer = user;
    size_t read = 0;
    for (int i = 0; i < count; ++i) {
        int8_t x = read_int8(buffer + read, &read);
        int8_t y = read_int8(buffer + read, &read);
        uint16_t size = read_uint16(buffer + read, &read);
        uint8_t hardness = read_uint8(buffer + read, &read);
        uint8_t opacity = read_uint8(buffer + read, &read);
        uint8_t angle = read_uint8(buffer + read, &read);
        uint8_t aspect_ratio = read_uint8(buffer + read, &read);
        DP_mypaint_dab_init(mpds, i, x, y, size, hardness, opacity, angle,
                            aspect_ratio);
    }
}

int8_t DP_mypaint_dab_x(const DP_MyPaintDab *mpd)
{
    DP_ASSERT(mpd);
    return mpd->x;
}

int8_t DP_mypaint_dab_y(const DP_MyPaintDab *mpd)
{
    DP_ASSERT(mpd);
    return mpd->y;
}

uint16_t DP_mypaint_dab_size(const DP_MyPaintDab *mpd)
{
    DP_ASSERT(mpd);
    return mpd->size;
}

uint8_t DP_mypaint_dab_hardness(const DP_MyPaintDab *mpd)
{
    DP_ASSERT(mpd);
    return mpd->hardness;
}

uint8_t DP_mypaint_dab_opacity(const DP_MyPaintDab *mpd)
{
    DP_ASSERT(mpd);
    return mpd->opacity;
}

uint8_t DP_mypaint_dab_angle(const DP_MyPaintDab *mpd)
{
    DP_ASSERT(mpd);
    return mpd->angle;
}

uint8_t DP_mypaint_dab_aspect_ratio(const DP_MyPaintDab *mpd)
{
    DP_ASSERT(mpd);
    return mpd->aspect_ratio;
}

const DP_MyPaintDab *DP_mypaint_dab_at(const DP_MyPaintDab *mpd, int i)
{
    DP_ASSERT(mpd);
    return &mpd[i];
}

struct DP_MsgDrawDabsMyPaint {
    uint16_t layer;
    int32_t x;
    int32_t y;
    uint32_t color;
    uint8_t lock_alpha;
    uint16_t dabs_count;
    DP_MyPaintDab dabs[];
};

static size_t msg_draw_dabs_mypaint_payload_length(DP_Message *msg)
{
    DP_MsgDrawDabsMyPaint *mddmp = DP_message_internal(msg);
    return ((size_t)15) + DP_int_to_size(mddmp->dabs_count) * 8;
}

static size_t msg_draw_dabs_mypaint_serialize_payload(DP_Message *msg,
                                                      unsigned char *data)
{
    DP_MsgDrawDabsMyPaint *mddmp = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mddmp->layer, data + written);
    written += DP_write_bigendian_int32(mddmp->x, data + written);
    written += DP_write_bigendian_int32(mddmp->y, data + written);
    written += DP_write_bigendian_uint32(mddmp->color, data + written);
    written += DP_write_bigendian_uint8(mddmp->lock_alpha, data + written);
    written += mypaint_dab_serialize_payloads(mddmp->dabs, mddmp->dabs_count,
                                              data + written);
    DP_ASSERT(written == msg_draw_dabs_mypaint_payload_length(msg));
    return written;
}

static bool msg_draw_dabs_mypaint_write_payload_text(DP_Message *msg,
                                                     DP_TextWriter *writer)
{
    DP_MsgDrawDabsMyPaint *mddmp = DP_message_internal(msg);
    return DP_text_writer_write_argb_color(writer, "color", mddmp->color)
        && DP_text_writer_write_uint(writer, "layer", mddmp->layer, true)
        && DP_text_writer_write_uint(writer, "lock_alpha", mddmp->lock_alpha,
                                     false)
        && DP_text_writer_write_decimal(writer, "x", (double)mddmp->x / 4.0)
        && DP_text_writer_write_decimal(writer, "y", (double)mddmp->y / 4.0)
        && mypaint_dab_write_payload_texts(mddmp->dabs, mddmp->dabs_count,
                                           writer);
}

static bool msg_draw_dabs_mypaint_equals(DP_Message *DP_RESTRICT msg,
                                         DP_Message *DP_RESTRICT other)
{
    DP_MsgDrawDabsMyPaint *a = DP_message_internal(msg);
    DP_MsgDrawDabsMyPaint *b = DP_message_internal(other);
    return a->layer == b->layer && a->x == b->x && a->y == b->y
        && a->color == b->color && a->lock_alpha == b->lock_alpha
        && a->dabs_count == b->dabs_count
        && mypaint_dabs_equal(a->dabs, b->dabs, a->dabs_count);
}

static const DP_MessageMethods msg_draw_dabs_mypaint_methods = {
    msg_draw_dabs_mypaint_payload_length,
    msg_draw_dabs_mypaint_serialize_payload,
    msg_draw_dabs_mypaint_write_payload_text,
    msg_draw_dabs_mypaint_equals,
};

DP_Message *
DP_msg_draw_dabs_mypaint_new(unsigned int context_id, uint16_t layer, int32_t x,
                             int32_t y, uint32_t color, uint8_t lock_alpha,
                             void (*set_dabs)(int, DP_MyPaintDab *, void *),
                             int dabs_count, void *dabs_user)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_DRAW_DABS_MYPAINT, context_id, &msg_draw_dabs_mypaint_methods,
        DP_FLEX_SIZEOF(DP_MsgDrawDabsMyPaint, dabs,
                       DP_int_to_size(dabs_count) * sizeof(DP_MyPaintDab)));
    DP_MsgDrawDabsMyPaint *mddmp = DP_message_internal(msg);
    mddmp->layer = layer;
    mddmp->x = x;
    mddmp->y = y;
    mddmp->color = color;
    mddmp->lock_alpha = lock_alpha;
    mddmp->dabs_count = DP_int_to_uint16(dabs_count);
    set_dabs(mddmp->dabs_count, mddmp->dabs, dabs_user);
    return msg;
}

DP_Message *DP_msg_draw_dabs_mypaint_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length)
{
    if (length < 23 || length > 65535) {
        DP_error_set("Wrong length for mypaintdabs message; "
                     "expected between 23 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t layer = read_uint16(buffer + read, &read);
    int32_t x = read_int32(buffer + read, &read);
    int32_t y = read_int32(buffer + read, &read);
    uint32_t color = read_uint32(buffer + read, &read);
    uint8_t lock_alpha = read_uint8(buffer + read, &read);
    size_t dabs_bytes = length - read;
    if ((dabs_bytes % 8) != 0) {
        DP_error_set("Wrong length for dabs field in mypaintdabs message; "
                     "%zu not divisible by 8",
                     dabs_bytes);
        return NULL;
    }
    int dabs_count = DP_size_to_int(dabs_bytes) / 8;
    void *dabs_user = (void *)(buffer + read);
    return DP_msg_draw_dabs_mypaint_new(context_id, layer, x, y, color,
                                        lock_alpha, mypaint_dab_deserialize,
                                        dabs_count, dabs_user);
}

DP_MsgDrawDabsMyPaint *DP_msg_draw_dabs_mypaint_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_DRAW_DABS_MYPAINT);
}

uint16_t DP_msg_draw_dabs_mypaint_layer(const DP_MsgDrawDabsMyPaint *mddmp)
{
    DP_ASSERT(mddmp);
    return mddmp->layer;
}

int32_t DP_msg_draw_dabs_mypaint_x(const DP_MsgDrawDabsMyPaint *mddmp)
{
    DP_ASSERT(mddmp);
    return mddmp->x;
}

int32_t DP_msg_draw_dabs_mypaint_y(const DP_MsgDrawDabsMyPaint *mddmp)
{
    DP_ASSERT(mddmp);
    return mddmp->y;
}

uint32_t DP_msg_draw_dabs_mypaint_color(const DP_MsgDrawDabsMyPaint *mddmp)
{
    DP_ASSERT(mddmp);
    return mddmp->color;
}

uint8_t DP_msg_draw_dabs_mypaint_lock_alpha(const DP_MsgDrawDabsMyPaint *mddmp)
{
    DP_ASSERT(mddmp);
    return mddmp->lock_alpha;
}

const DP_MyPaintDab *
DP_msg_draw_dabs_mypaint_dabs(const DP_MsgDrawDabsMyPaint *mddmp,
                              int *out_count)
{
    DP_ASSERT(mddmp);
    if (out_count) {
        *out_count = mddmp->dabs_count;
    }
    return mddmp->dabs;
}

int DP_msg_draw_dabs_mypaint_dabs_count(const DP_MsgDrawDabsMyPaint *mddmp)
{
    return mddmp->dabs_count;
}


/* DP_MSG_MOVE_RECT */

struct DP_MsgMoveRect {
    uint16_t layer;
    int32_t sx;
    int32_t sy;
    int32_t tx;
    int32_t ty;
    int32_t w;
    int32_t h;
    uint16_t mask_size;
    unsigned char mask[];
};

static size_t msg_move_rect_payload_length(DP_Message *msg)
{
    DP_MsgMoveRect *mmr = DP_message_internal(msg);
    return ((size_t)26) + mmr->mask_size;
}

static size_t msg_move_rect_serialize_payload(DP_Message *msg,
                                              unsigned char *data)
{
    DP_MsgMoveRect *mmr = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mmr->layer, data + written);
    written += DP_write_bigendian_int32(mmr->sx, data + written);
    written += DP_write_bigendian_int32(mmr->sy, data + written);
    written += DP_write_bigendian_int32(mmr->tx, data + written);
    written += DP_write_bigendian_int32(mmr->ty, data + written);
    written += DP_write_bigendian_int32(mmr->w, data + written);
    written += DP_write_bigendian_int32(mmr->h, data + written);
    written += write_bytes(mmr->mask, mmr->mask_size, data + written);
    DP_ASSERT(written == msg_move_rect_payload_length(msg));
    return written;
}

static bool msg_move_rect_write_payload_text(DP_Message *msg,
                                             DP_TextWriter *writer)
{
    DP_MsgMoveRect *mmr = DP_message_internal(msg);
    return DP_text_writer_write_int(writer, "h", mmr->h)
        && DP_text_writer_write_uint(writer, "layer", mmr->layer, true)
        && DP_text_writer_write_base64(writer, "mask", mmr->mask,
                                       mmr->mask_size)
        && DP_text_writer_write_int(writer, "sx", mmr->sx)
        && DP_text_writer_write_int(writer, "sy", mmr->sy)
        && DP_text_writer_write_int(writer, "tx", mmr->tx)
        && DP_text_writer_write_int(writer, "ty", mmr->ty)
        && DP_text_writer_write_int(writer, "w", mmr->w);
}

static bool msg_move_rect_equals(DP_Message *DP_RESTRICT msg,
                                 DP_Message *DP_RESTRICT other)
{
    DP_MsgMoveRect *a = DP_message_internal(msg);
    DP_MsgMoveRect *b = DP_message_internal(other);
    return a->layer == b->layer && a->sx == b->sx && a->sy == b->sy
        && a->tx == b->tx && a->ty == b->ty && a->w == b->w && a->h == b->h
        && a->mask_size == b->mask_size
        && memcmp(a->mask, b->mask, DP_uint16_to_size(a->mask_size)) == 0;
}

static const DP_MessageMethods msg_move_rect_methods = {
    msg_move_rect_payload_length,
    msg_move_rect_serialize_payload,
    msg_move_rect_write_payload_text,
    msg_move_rect_equals,
};

DP_Message *
DP_msg_move_rect_new(unsigned int context_id, uint16_t layer, int32_t sx,
                     int32_t sy, int32_t tx, int32_t ty, int32_t w, int32_t h,
                     void (*set_mask)(size_t, unsigned char *, void *),
                     size_t mask_size, void *mask_user)
{
    DP_Message *msg =
        DP_message_new(DP_MSG_MOVE_RECT, context_id, &msg_move_rect_methods,
                       DP_FLEX_SIZEOF(DP_MsgMoveRect, mask, mask_size));
    DP_MsgMoveRect *mmr = DP_message_internal(msg);
    mmr->layer = layer;
    mmr->sx = sx;
    mmr->sy = sy;
    mmr->tx = tx;
    mmr->ty = ty;
    mmr->w = w;
    mmr->h = h;
    mmr->mask_size = DP_size_to_uint16(mask_size);
    if (set_mask) {
        set_mask(mmr->mask_size, mmr->mask, mask_user);
    }
    return msg;
}

DP_Message *DP_msg_move_rect_deserialize(unsigned int context_id,
                                         const unsigned char *buffer,
                                         size_t length)
{
    if (length < 26 || length > 65535) {
        DP_error_set("Wrong length for moverect message; "
                     "expected between 26 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t layer = read_uint16(buffer + read, &read);
    int32_t sx = read_int32(buffer + read, &read);
    int32_t sy = read_int32(buffer + read, &read);
    int32_t tx = read_int32(buffer + read, &read);
    int32_t ty = read_int32(buffer + read, &read);
    int32_t w = read_int32(buffer + read, &read);
    int32_t h = read_int32(buffer + read, &read);
    size_t mask_bytes = length - read;
    uint16_t mask_size = DP_size_to_uint16(mask_bytes);
    void *mask_user = (void *)(buffer + read);
    return DP_msg_move_rect_new(context_id, layer, sx, sy, tx, ty, w, h,
                                read_bytes, mask_size, mask_user);
}

DP_MsgMoveRect *DP_msg_move_rect_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_MOVE_RECT);
}

uint16_t DP_msg_move_rect_layer(const DP_MsgMoveRect *mmr)
{
    DP_ASSERT(mmr);
    return mmr->layer;
}

int32_t DP_msg_move_rect_sx(const DP_MsgMoveRect *mmr)
{
    DP_ASSERT(mmr);
    return mmr->sx;
}

int32_t DP_msg_move_rect_sy(const DP_MsgMoveRect *mmr)
{
    DP_ASSERT(mmr);
    return mmr->sy;
}

int32_t DP_msg_move_rect_tx(const DP_MsgMoveRect *mmr)
{
    DP_ASSERT(mmr);
    return mmr->tx;
}

int32_t DP_msg_move_rect_ty(const DP_MsgMoveRect *mmr)
{
    DP_ASSERT(mmr);
    return mmr->ty;
}

int32_t DP_msg_move_rect_w(const DP_MsgMoveRect *mmr)
{
    DP_ASSERT(mmr);
    return mmr->w;
}

int32_t DP_msg_move_rect_h(const DP_MsgMoveRect *mmr)
{
    DP_ASSERT(mmr);
    return mmr->h;
}

const unsigned char *DP_msg_move_rect_mask(const DP_MsgMoveRect *mmr,
                                           size_t *out_size)
{
    DP_ASSERT(mmr);
    if (out_size) {
        *out_size = mmr->mask_size;
    }
    return mmr->mask;
}

size_t DP_msg_move_rect_mask_size(const DP_MsgMoveRect *mmr)
{
    return mmr->mask_size;
}


/* DP_MSG_SET_METADATA_INT */

const char *DP_msg_set_metadata_int_field_variant_name(unsigned int value)
{
    switch (value) {
    case DP_MSG_SET_METADATA_INT_FIELD_DPIX:
        return "Dpix";
    case DP_MSG_SET_METADATA_INT_FIELD_DPIY:
        return "Dpiy";
    case DP_MSG_SET_METADATA_INT_FIELD_FRAMERATE:
        return "Framerate";
    case DP_MSG_SET_METADATA_INT_FIELD_USE_TIMELINE:
        return "UseTimeline";
    default:
        return NULL;
    }
}

struct DP_MsgSetMetadataInt {
    uint8_t field;
    int32_t value;
};

static size_t msg_set_metadata_int_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)5);
}

static size_t msg_set_metadata_int_serialize_payload(DP_Message *msg,
                                                     unsigned char *data)
{
    DP_MsgSetMetadataInt *msmi = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint8(msmi->field, data + written);
    written += DP_write_bigendian_int32(msmi->value, data + written);
    DP_ASSERT(written == msg_set_metadata_int_payload_length(msg));
    return written;
}

static bool msg_set_metadata_int_write_payload_text(DP_Message *msg,
                                                    DP_TextWriter *writer)
{
    DP_MsgSetMetadataInt *msmi = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "field", msmi->field, false)
        && DP_text_writer_write_int(writer, "value", msmi->value);
}

static bool msg_set_metadata_int_equals(DP_Message *DP_RESTRICT msg,
                                        DP_Message *DP_RESTRICT other)
{
    DP_MsgSetMetadataInt *a = DP_message_internal(msg);
    DP_MsgSetMetadataInt *b = DP_message_internal(other);
    return a->field == b->field && a->value == b->value;
}

static const DP_MessageMethods msg_set_metadata_int_methods = {
    msg_set_metadata_int_payload_length,
    msg_set_metadata_int_serialize_payload,
    msg_set_metadata_int_write_payload_text,
    msg_set_metadata_int_equals,
};

DP_Message *DP_msg_set_metadata_int_new(unsigned int context_id, uint8_t field,
                                        int32_t value)
{
    DP_Message *msg = DP_message_new(DP_MSG_SET_METADATA_INT, context_id,
                                     &msg_set_metadata_int_methods,
                                     sizeof(DP_MsgSetMetadataInt));
    DP_MsgSetMetadataInt *msmi = DP_message_internal(msg);
    msmi->field = field;
    msmi->value = value;
    return msg;
}

DP_Message *DP_msg_set_metadata_int_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length)
{
    if (length != 5) {
        DP_error_set("Wrong length for setmetadataint message; "
                     "expected 5, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint8_t field = read_uint8(buffer + read, &read);
    int32_t value = read_int32(buffer + read, &read);
    return DP_msg_set_metadata_int_new(context_id, field, value);
}

DP_MsgSetMetadataInt *DP_msg_set_metadata_int_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_SET_METADATA_INT);
}

uint8_t DP_msg_set_metadata_int_field(const DP_MsgSetMetadataInt *msmi)
{
    DP_ASSERT(msmi);
    return msmi->field;
}

int32_t DP_msg_set_metadata_int_value(const DP_MsgSetMetadataInt *msmi)
{
    DP_ASSERT(msmi);
    return msmi->value;
}


/* DP_MSG_SET_METADATA_STR */

struct DP_MsgSetMetadataStr {
    uint8_t field;
    uint16_t value_len;
    char value[];
};

static size_t msg_set_metadata_str_payload_length(DP_Message *msg)
{
    DP_MsgSetMetadataStr *msms = DP_message_internal(msg);
    return ((size_t)1) + DP_uint16_to_size(msms->value_len);
}

static size_t msg_set_metadata_str_serialize_payload(DP_Message *msg,
                                                     unsigned char *data)
{
    DP_MsgSetMetadataStr *msms = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint8(msms->field, data + written);
    written += DP_write_bytes(msms->value, 1, msms->value_len, data + written);
    DP_ASSERT(written == msg_set_metadata_str_payload_length(msg));
    return written;
}

static bool msg_set_metadata_str_write_payload_text(DP_Message *msg,
                                                    DP_TextWriter *writer)
{
    DP_MsgSetMetadataStr *msms = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "field", msms->field, false)
        && DP_text_writer_write_string(writer, "value", msms->value);
}

static bool msg_set_metadata_str_equals(DP_Message *DP_RESTRICT msg,
                                        DP_Message *DP_RESTRICT other)
{
    DP_MsgSetMetadataStr *a = DP_message_internal(msg);
    DP_MsgSetMetadataStr *b = DP_message_internal(other);
    return a->field == b->field && a->value_len == b->value_len
        && memcmp(a->value, b->value, a->value_len) == 0;
}

static const DP_MessageMethods msg_set_metadata_str_methods = {
    msg_set_metadata_str_payload_length,
    msg_set_metadata_str_serialize_payload,
    msg_set_metadata_str_write_payload_text,
    msg_set_metadata_str_equals,
};

DP_Message *DP_msg_set_metadata_str_new(unsigned int context_id, uint8_t field,
                                        const char *value_value,
                                        size_t value_len)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_SET_METADATA_STR, context_id, &msg_set_metadata_str_methods,
        DP_FLEX_SIZEOF(DP_MsgSetMetadataStr, value, value_len + 1));
    DP_MsgSetMetadataStr *msms = DP_message_internal(msg);
    msms->field = field;
    msms->value_len = DP_size_to_uint16(value_len);
    assign_string(msms->value, value_value, msms->value_len);
    return msg;
}

DP_Message *DP_msg_set_metadata_str_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length)
{
    if (length < 1 || length > 65535) {
        DP_error_set("Wrong length for setmetadatastr message; "
                     "expected between 1 and 65535, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint8_t field = read_uint8(buffer + read, &read);
    size_t value_bytes = length - read;
    uint16_t value_len = DP_size_to_uint16(value_bytes);
    const char *value = (const char *)buffer + read;
    return DP_msg_set_metadata_str_new(context_id, field, value, value_len);
}

DP_MsgSetMetadataStr *DP_msg_set_metadata_str_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_SET_METADATA_STR);
}

uint8_t DP_msg_set_metadata_str_field(const DP_MsgSetMetadataStr *msms)
{
    DP_ASSERT(msms);
    return msms->field;
}

const char *DP_msg_set_metadata_str_value(const DP_MsgSetMetadataStr *msms,
                                          size_t *out_len)
{
    DP_ASSERT(msms);
    if (out_len) {
        *out_len = msms->value_len;
    }
    return msms->value;
}

size_t DP_msg_set_metadata_str_value_len(const DP_MsgSetMetadataStr *msms)
{
    return msms->value_len;
}


/* DP_MSG_SET_TIMELINE_FRAME */

struct DP_MsgSetTimelineFrame {
    uint16_t frame;
    bool insert;
    uint16_t layers_count;
    uint16_t layers[];
};

static size_t msg_set_timeline_frame_payload_length(DP_Message *msg)
{
    DP_MsgSetTimelineFrame *mstf = DP_message_internal(msg);
    return ((size_t)3) + DP_int_to_size(mstf->layers_count) * 2;
}

static size_t msg_set_timeline_frame_serialize_payload(DP_Message *msg,
                                                       unsigned char *data)
{
    DP_MsgSetTimelineFrame *mstf = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mstf->frame, data + written);
    written += DP_write_bigendian_uint8(mstf->insert, data + written);
    written += DP_write_bigendian_uint16_array(mstf->layers, mstf->layers_count,
                                               data + written);
    DP_ASSERT(written == msg_set_timeline_frame_payload_length(msg));
    return written;
}

static bool msg_set_timeline_frame_write_payload_text(DP_Message *msg,
                                                      DP_TextWriter *writer)
{
    DP_MsgSetTimelineFrame *mstf = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "frame", mstf->frame, false)
        && DP_text_writer_write_bool(writer, "insert", mstf->insert)
        && DP_text_writer_write_uint16_list(writer, "layers", mstf->layers,
                                            mstf->layers_count, true);
}

static bool msg_set_timeline_frame_equals(DP_Message *DP_RESTRICT msg,
                                          DP_Message *DP_RESTRICT other)
{
    DP_MsgSetTimelineFrame *a = DP_message_internal(msg);
    DP_MsgSetTimelineFrame *b = DP_message_internal(other);
    return a->frame == b->frame && a->insert == b->insert
        && a->layers_count == b->layers_count
        && memcmp(a->layers, b->layers, DP_uint16_to_size(a->layers_count) * 2)
               == 0;
}

static const DP_MessageMethods msg_set_timeline_frame_methods = {
    msg_set_timeline_frame_payload_length,
    msg_set_timeline_frame_serialize_payload,
    msg_set_timeline_frame_write_payload_text,
    msg_set_timeline_frame_equals,
};

DP_Message *DP_msg_set_timeline_frame_new(unsigned int context_id,
                                          uint16_t frame, bool insert,
                                          void (*set_layers)(int, uint16_t *,
                                                             void *),
                                          int layers_count, void *layers_user)
{
    DP_Message *msg = DP_message_new(
        DP_MSG_SET_TIMELINE_FRAME, context_id, &msg_set_timeline_frame_methods,
        DP_FLEX_SIZEOF(DP_MsgSetTimelineFrame, layers,
                       DP_int_to_size(layers_count) * 2));
    DP_MsgSetTimelineFrame *mstf = DP_message_internal(msg);
    mstf->frame = frame;
    mstf->insert = insert;
    mstf->layers_count = DP_int_to_uint16(layers_count);
    if (set_layers) {
        set_layers(mstf->layers_count, mstf->layers, layers_user);
    }
    return msg;
}

DP_Message *DP_msg_set_timeline_frame_deserialize(unsigned int context_id,
                                                  const unsigned char *buffer,
                                                  size_t length)
{
    if (length < 3 || length > 27) {
        DP_error_set("Wrong length for settimelineframe message; "
                     "expected between 3 and 27, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t frame = read_uint16(buffer + read, &read);
    bool insert = read_bool(buffer + read, &read);
    size_t layers_bytes = length - read;
    if ((layers_bytes % 2) != 0) {
        DP_error_set(
            "Wrong length for layers field in settimelineframe message; "
            "%zu not divisible by 2",
            layers_bytes);
        return NULL;
    }
    uint16_t layers_count = DP_size_to_uint16(layers_bytes / 2);
    void *layers_user = (void *)(buffer + read);
    return DP_msg_set_timeline_frame_new(context_id, frame, insert,
                                         read_uint16_array, layers_count,
                                         layers_user);
}

DP_MsgSetTimelineFrame *DP_msg_set_timeline_frame_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_SET_TIMELINE_FRAME);
}

uint16_t DP_msg_set_timeline_frame_frame(const DP_MsgSetTimelineFrame *mstf)
{
    DP_ASSERT(mstf);
    return mstf->frame;
}

bool DP_msg_set_timeline_frame_insert(const DP_MsgSetTimelineFrame *mstf)
{
    DP_ASSERT(mstf);
    return mstf->insert;
}

const uint16_t *
DP_msg_set_timeline_frame_layers(const DP_MsgSetTimelineFrame *mstf,
                                 int *out_count)
{
    DP_ASSERT(mstf);
    if (out_count) {
        *out_count = mstf->layers_count;
    }
    return mstf->layers;
}

int DP_msg_set_timeline_frame_layers_count(const DP_MsgSetTimelineFrame *mstf)
{
    return mstf->layers_count;
}


/* DP_MSG_REMOVE_TIMELINE_FRAME */

struct DP_MsgRemoveTimelineFrame {
    uint16_t frame;
};

static size_t
msg_remove_timeline_frame_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)2);
}

static size_t msg_remove_timeline_frame_serialize_payload(DP_Message *msg,
                                                          unsigned char *data)
{
    DP_MsgRemoveTimelineFrame *mrtf = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint16(mrtf->frame, data + written);
    DP_ASSERT(written == msg_remove_timeline_frame_payload_length(msg));
    return written;
}

static bool msg_remove_timeline_frame_write_payload_text(DP_Message *msg,
                                                         DP_TextWriter *writer)
{
    DP_MsgRemoveTimelineFrame *mrtf = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "frame", mrtf->frame, false);
}

static bool msg_remove_timeline_frame_equals(DP_Message *DP_RESTRICT msg,
                                             DP_Message *DP_RESTRICT other)
{
    DP_MsgRemoveTimelineFrame *a = DP_message_internal(msg);
    DP_MsgRemoveTimelineFrame *b = DP_message_internal(other);
    return a->frame == b->frame;
}

static const DP_MessageMethods msg_remove_timeline_frame_methods = {
    msg_remove_timeline_frame_payload_length,
    msg_remove_timeline_frame_serialize_payload,
    msg_remove_timeline_frame_write_payload_text,
    msg_remove_timeline_frame_equals,
};

DP_Message *DP_msg_remove_timeline_frame_new(unsigned int context_id,
                                             uint16_t frame)
{
    DP_Message *msg = DP_message_new(DP_MSG_REMOVE_TIMELINE_FRAME, context_id,
                                     &msg_remove_timeline_frame_methods,
                                     sizeof(DP_MsgRemoveTimelineFrame));
    DP_MsgRemoveTimelineFrame *mrtf = DP_message_internal(msg);
    mrtf->frame = frame;
    return msg;
}

DP_Message *DP_msg_remove_timeline_frame_deserialize(
    unsigned int context_id, const unsigned char *buffer, size_t length)
{
    if (length != 2) {
        DP_error_set("Wrong length for removetimelineframe message; "
                     "expected 2, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint16_t frame = read_uint16(buffer + read, &read);
    return DP_msg_remove_timeline_frame_new(context_id, frame);
}

DP_MsgRemoveTimelineFrame *DP_msg_remove_timeline_frame_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_REMOVE_TIMELINE_FRAME);
}

uint16_t
DP_msg_remove_timeline_frame_frame(const DP_MsgRemoveTimelineFrame *mrtf)
{
    DP_ASSERT(mrtf);
    return mrtf->frame;
}


/* DP_MSG_UNDO */

struct DP_MsgUndo {
    uint8_t override_user;
    bool redo;
};

static size_t msg_undo_payload_length(DP_UNUSED DP_Message *msg)
{
    return ((size_t)2);
}

static size_t msg_undo_serialize_payload(DP_Message *msg, unsigned char *data)
{
    DP_MsgUndo *mu = DP_message_internal(msg);
    size_t written = 0;
    written += DP_write_bigendian_uint8(mu->override_user, data + written);
    written += DP_write_bigendian_uint8(mu->redo, data + written);
    DP_ASSERT(written == msg_undo_payload_length(msg));
    return written;
}

static bool msg_undo_write_payload_text(DP_Message *msg, DP_TextWriter *writer)
{
    DP_MsgUndo *mu = DP_message_internal(msg);
    return DP_text_writer_write_uint(writer, "override_user", mu->override_user,
                                     false)
        && DP_text_writer_write_bool(writer, "redo", mu->redo);
}

static bool msg_undo_equals(DP_Message *DP_RESTRICT msg,
                            DP_Message *DP_RESTRICT other)
{
    DP_MsgUndo *a = DP_message_internal(msg);
    DP_MsgUndo *b = DP_message_internal(other);
    return a->override_user == b->override_user && a->redo == b->redo;
}

static const DP_MessageMethods msg_undo_methods = {
    msg_undo_payload_length,
    msg_undo_serialize_payload,
    msg_undo_write_payload_text,
    msg_undo_equals,
};

DP_Message *DP_msg_undo_new(unsigned int context_id, uint8_t override_user,
                            bool redo)
{
    DP_Message *msg = DP_message_new(DP_MSG_UNDO, context_id, &msg_undo_methods,
                                     sizeof(DP_MsgUndo));
    DP_MsgUndo *mu = DP_message_internal(msg);
    mu->override_user = override_user;
    mu->redo = redo;
    return msg;
}

DP_Message *DP_msg_undo_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length)
{
    if (length != 2) {
        DP_error_set("Wrong length for undo message; "
                     "expected 2, got %zu",
                     length);
        return NULL;
    }
    size_t read = 0;
    uint8_t override_user = read_uint8(buffer + read, &read);
    bool redo = read_bool(buffer + read, &read);
    return DP_msg_undo_new(context_id, override_user, redo);
}

DP_MsgUndo *DP_msg_undo_cast(DP_Message *msg)
{
    return DP_message_cast(msg, DP_MSG_UNDO);
}

uint8_t DP_msg_undo_override_user(const DP_MsgUndo *mu)
{
    DP_ASSERT(mu);
    return mu->override_user;
}

bool DP_msg_undo_redo(const DP_MsgUndo *mu)
{
    DP_ASSERT(mu);
    return mu->redo;
}
