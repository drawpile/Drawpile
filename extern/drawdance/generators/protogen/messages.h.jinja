/*
 * Copyright (C) 2022 askmeaboutloom
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * --------------------------------------------------------------------
 *
 * This code is auto-generated by generators/protogen/protogen_drawdance.py
 * from generators/protogen/messages.h.jinja. Don't edit it directly.
 */
#ifndef DPMSG_MESSAGES_H
#define DPMSG_MESSAGES_H
#include <dpcommon/common.h>

typedef struct DP_Message DP_Message;
typedef struct DP_TextReader DP_TextReader;
typedef struct DP_TextWriter DP_TextWriter;

#define DP_PROTOCOL_VERSION_NAMESPACE "{{ version.namespace }}"
#define DP_PROTOCOL_VERSION_SERVER    {{ version.server }}
#define DP_PROTOCOL_VERSION_MAJOR     {{ version.major }}
#define DP_PROTOCOL_VERSION_MINOR     {{ version.minor }}
#define DP_PROTOCOL_VERSION           "{{ version.string }}"
#define DP_UNDO_DEPTH                 {{ undo_depth }}

typedef struct DP_MessageMethods {
    size_t (*payload_length)(DP_Message *msg);
    size_t (*serialize_payload)(DP_Message *msg, unsigned char *data);
    bool (*write_payload_text)(DP_Message *msg, DP_TextWriter *writer);
    bool (*equals)(DP_Message *DP_RESTRICT msg, DP_Message *DP_RESTRICT other);
} DP_MessageMethods;

typedef enum DP_MessageType {
    {% for message in messages %}
        {{ message.enum_name }} = {{ message.id }},
    {% endfor %}
    DP_MSG_TYPE_COUNT,
} DP_MessageType;

bool DP_message_type_control(DP_MessageType type);

bool DP_message_type_client_meta(DP_MessageType type);

bool DP_message_type_server_meta(DP_MessageType type);

bool DP_message_type_command(DP_MessageType type);

const char *DP_message_type_name(DP_MessageType type);

const char *DP_message_type_enum_name(DP_MessageType type);

const char *DP_message_type_enum_name_unprefixed(DP_MessageType type);

DP_MessageType DP_message_type_from_name(const char *type_name, DP_MessageType not_found_value);

// Returns if the given type's text format has a body of value tuples, rather
// than a body of multiline fields. This is the case for draw dabs messages.
bool DP_message_type_parse_multiline_tuples(DP_MessageType type);


DP_Message *DP_message_deserialize_body(int type, unsigned int context_id, const unsigned char *buf, size_t length);

DP_Message *DP_message_parse_body(DP_MessageType type, unsigned int context_id, DP_TextReader *reader);

{% for message in messages %}

/*
 * {{ message.enum_name }}
 *
{{ message.comment }}
 */
    {% if not message.reserved %}
        {% for f in message.fields %}
            {% if f.flags %}

                {% for flag in f.flags %}
                    #define {{ flag.define_name }} 0x{{ '%.x'|format(flag.value) }}
                {% endfor %}

                const char *DP_{{ message.func_name }}_{{ f.func_name }}_flag_name(unsigned int value);
            {% endif %}
            {% if f.variants %}

                {% for variant in f.variants %}
                    #define {{ variant.define_name }} {{ variant.value }}
                {% endfor %}

                const char *DP_{{ message.func_name }}_{{ f.func_name }}_variant_name(unsigned int value);
            {% endif %}
        {% endfor %}
        {% for f in message.fields %}
            {% if f.sub %}

                #define {{ message.enum_name }}_{{ f.func_name|upper }}_MAX {{ f.sub.max_items }}

                typedef struct {{ f.sub.struct_name }} {{ f.sub.struct_name }};

                void DP_{{ f.sub.func_name }}_init({{ f.sub.param }}s, int i
                    {%- for sf in f.sub.fields %}
                        , {{ sf.constructor_param }}
                    {% endfor -%}
                );
                {% for sf in f.sub.fields %}

                    {{ sf.accessor_return_type }} DP_{{ f.sub.func_name }}_{{ sf.func_name }}(
                        const {{ f.sub.param }});
                {% endfor %}

                const {{ f.sub.struct_name }} *DP_{{ f.sub.func_name }}_at(const {{ f.sub.param }}, int i);

            {% endif %}
        {% endfor %}
        {% if message.fields %}

            typedef struct {{ message.struct_name }} {{ message.struct_name }};
        {% endif %}

        DP_Message *DP_{{ message.func_name }}_new(
            unsigned int context_id
            {%- for f in message.effective_fields -%}
                , {{ f.constructor_param }}
            {% endfor %}
        );

        DP_Message *DP_{{ message.func_name }}_deserialize(unsigned int context_id, const unsigned char *buffer, size_t length);

        DP_Message *DP_{{ message.func_name }}_parse(unsigned int context_id, DP_TextReader *reader);
        {% if message.fields or message.alias %}

            {{ message.struct_name }} *DP_{{ message.func_name }}_cast(DP_Message *msg);
        {% endif %}
        {% for f in message.fields %}

            {{ f.accessor_return_type }} DP_{{ message.func_name }}_{{ f.func_name }}(
                const {{ message.param }}
                {%- if f.accessor_out_param %}, {{ f.accessor_out_param }}{% endif -%}
            );
            {% set array_size_type = f.array_size_type %}
            {% if array_size_type %}

                {{ array_size_type }} DP_{{ message.func_name }}_{{ f.func_name }}_{{ f.array_size_name }}(const {{message.param}});
            {% endif %}
        {% endfor %}
    {% endif %}

{% endfor %}

#endif
