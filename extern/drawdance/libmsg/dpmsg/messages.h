/*
 * Copyright (C) 2022 askmeaboutloom
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * --------------------------------------------------------------------
 *
 * This code is auto-generated by generators/protogen/protogen_drawdance.py
 * from generators/protogen/messages.h.jinja. Don't edit it directly.
 */
#ifndef DPMSG_MESSAGES_H
#define DPMSG_MESSAGES_H
#include <dpcommon/common.h>

typedef struct DP_Message DP_Message;
typedef struct DP_TextReader DP_TextReader;
typedef struct DP_TextWriter DP_TextWriter;

#define DP_PROTOCOL_VERSION_NAMESPACE "dp"
#define DP_PROTOCOL_VERSION_SERVER    4
#define DP_PROTOCOL_VERSION_MAJOR     23
#define DP_PROTOCOL_VERSION_MINOR     0
#define DP_PROTOCOL_VERSION           "dp:4.23.0"
#define DP_UNDO_DEPTH_DEFAULT         30

typedef struct DP_MessageMethods {
    size_t (*payload_length)(DP_Message *msg);
    size_t (*serialize_payload)(DP_Message *msg, unsigned char *data);
    bool (*write_payload_text)(DP_Message *msg, DP_TextWriter *writer);
    bool (*equals)(DP_Message *DP_RESTRICT msg, DP_Message *DP_RESTRICT other);
} DP_MessageMethods;

typedef enum DP_MessageType {
    DP_MSG_SERVER_COMMAND = 0,
    DP_MSG_DISCONNECT = 1,
    DP_MSG_PING = 2,
    DP_MSG_INTERNAL = 31,
    DP_MSG_JOIN = 32,
    DP_MSG_LEAVE = 33,
    DP_MSG_SESSION_OWNER = 34,
    DP_MSG_CHAT = 35,
    DP_MSG_TRUSTED_USERS = 36,
    DP_MSG_SOFT_RESET = 37,
    DP_MSG_PRIVATE_CHAT = 38,
    DP_MSG_INTERVAL = 64,
    DP_MSG_LASER_TRAIL = 65,
    DP_MSG_MOVE_POINTER = 66,
    DP_MSG_MARKER = 67,
    DP_MSG_USER_ACL = 68,
    DP_MSG_LAYER_ACL = 69,
    DP_MSG_FEATURE_ACCESS_LEVELS = 70,
    DP_MSG_DEFAULT_LAYER = 71,
    DP_MSG_FILTERED = 72,
    DP_MSG_EXTENSION = 73,
    DP_MSG_UNDO_DEPTH = 74,
    DP_MSG_DATA = 75,
    DP_MSG_LOCAL_CHANGE = 76,
    DP_MSG_UNDO_POINT = 128,
    DP_MSG_CANVAS_RESIZE = 129,
    DP_MSG_LAYER_CREATE = 130,
    DP_MSG_LAYER_ATTRIBUTES = 131,
    DP_MSG_LAYER_RETITLE = 132,
    DP_MSG_LAYER_ORDER = 133,
    DP_MSG_LAYER_DELETE = 134,
    DP_MSG_LAYER_VISIBILITY = 135,
    DP_MSG_PUT_IMAGE = 136,
    DP_MSG_FILL_RECT = 137,
    DP_MSG_TOOL_CHANGE = 138,
    DP_MSG_PEN_MOVE = 139,
    DP_MSG_PEN_UP = 140,
    DP_MSG_ANNOTATION_CREATE = 141,
    DP_MSG_ANNOTATION_RESHAPE = 142,
    DP_MSG_ANNOTATION_EDIT = 143,
    DP_MSG_ANNOTATION_DELETE = 144,
    DP_MSG_MOVE_REGION = 145,
    DP_MSG_PUT_TILE = 146,
    DP_MSG_CANVAS_BACKGROUND = 147,
    DP_MSG_DRAW_DABS_CLASSIC = 148,
    DP_MSG_DRAW_DABS_PIXEL = 149,
    DP_MSG_DRAW_DABS_PIXEL_SQUARE = 150,
    DP_MSG_DRAW_DABS_MYPAINT = 151,
    DP_MSG_MOVE_RECT = 160,
    DP_MSG_SET_METADATA_INT = 161,
    DP_MSG_LAYER_TREE_CREATE = 162,
    DP_MSG_LAYER_TREE_ORDER = 163,
    DP_MSG_LAYER_TREE_DELETE = 164,
    DP_MSG_TRANSFORM_REGION = 165,
    DP_MSG_TRACK_CREATE = 166,
    DP_MSG_TRACK_RETITLE = 167,
    DP_MSG_TRACK_DELETE = 168,
    DP_MSG_TRACK_ORDER = 169,
    DP_MSG_KEY_FRAME_SET = 170,
    DP_MSG_KEY_FRAME_RETITLE = 171,
    DP_MSG_KEY_FRAME_LAYER_ATTRIBUTES = 172,
    DP_MSG_KEY_FRAME_DELETE = 173,
    DP_MSG_UNDO = 255,
    DP_MSG_TYPE_COUNT,
} DP_MessageType;

bool DP_message_type_control(DP_MessageType type);

bool DP_message_type_client_meta(DP_MessageType type);

bool DP_message_type_server_meta(DP_MessageType type);

bool DP_message_type_command(DP_MessageType type);

const char *DP_message_type_name(DP_MessageType type);

const char *DP_message_type_enum_name(DP_MessageType type);

const char *DP_message_type_enum_name_unprefixed(DP_MessageType type);

DP_MessageType DP_message_type_from_name(const char *type_name,
                                         DP_MessageType not_found_value);

// Returns if the given type's text format has a body of value tuples, rather
// than a body of multiline fields. This is the case for draw dabs messages.
bool DP_message_type_parse_multiline_tuples(DP_MessageType type);


DP_Message *DP_message_deserialize_body(int type, unsigned int context_id,
                                        const unsigned char *buf,
                                        size_t length);

DP_Message *DP_message_parse_body(DP_MessageType type, unsigned int context_id,
                                  DP_TextReader *reader);


/*
 * DP_MSG_SERVER_COMMAND
 *
 * Server command message
 *
 * This is a general purpose message for sending commands to the server
 * and receiving replies. This is used for (among other things):
 *
 * - the login handshake
 * - setting session parameters (e.g. max user count and password)
 * - sending administration commands (e.g. kick user)
 */

#define DP_MSG_SERVER_COMMAND_STATIC_LENGTH 0

typedef struct DP_MsgServerCommand DP_MsgServerCommand;

DP_Message *DP_msg_server_command_new(unsigned int context_id,
                                      const char *msg_value, size_t msg_len);

DP_Message *DP_msg_server_command_deserialize(unsigned int context_id,
                                              const unsigned char *buffer,
                                              size_t length);

DP_Message *DP_msg_server_command_parse(unsigned int context_id,
                                        DP_TextReader *reader);

DP_MsgServerCommand *DP_msg_server_command_cast(DP_Message *msg);

const char *DP_msg_server_command_msg(const DP_MsgServerCommand *msc,
                                      size_t *out_len);

size_t DP_msg_server_command_msg_len(const DP_MsgServerCommand *msc);


/*
 * DP_MSG_DISCONNECT
 *
 * Disconnect notification
 *
 * This message is used when closing the connection gracefully. The message
 * queue will automatically close the socket after sending this message.
 */

#define DP_MSG_DISCONNECT_STATIC_LENGTH 1

#define DP_MSG_DISCONNECT_REASON_ERROR    0
#define DP_MSG_DISCONNECT_REASON_KICK     1
#define DP_MSG_DISCONNECT_REASON_SHUTDOWN 2
#define DP_MSG_DISCONNECT_REASON_OTHER    3

const char *DP_msg_disconnect_reason_variant_name(unsigned int value);

typedef struct DP_MsgDisconnect DP_MsgDisconnect;

DP_Message *DP_msg_disconnect_new(unsigned int context_id, uint8_t reason,
                                  const char *message_value,
                                  size_t message_len);

DP_Message *DP_msg_disconnect_deserialize(unsigned int context_id,
                                          const unsigned char *buffer,
                                          size_t length);

DP_Message *DP_msg_disconnect_parse(unsigned int context_id,
                                    DP_TextReader *reader);

DP_MsgDisconnect *DP_msg_disconnect_cast(DP_Message *msg);

uint8_t DP_msg_disconnect_reason(const DP_MsgDisconnect *md);

const char *DP_msg_disconnect_message(const DP_MsgDisconnect *md,
                                      size_t *out_len);

size_t DP_msg_disconnect_message_len(const DP_MsgDisconnect *md);


/*
 * DP_MSG_PING
 *
 * Ping message
 *
 * This is used for latency measurement as well as a keepalive. Normally, the
 * client should be the one to send the ping messages.
 *
 * The server should return a Ping with the is_pong flag set
 */

#define DP_MSG_PING_STATIC_LENGTH 1

typedef struct DP_MsgPing DP_MsgPing;

DP_Message *DP_msg_ping_new(unsigned int context_id, bool is_pong);

DP_Message *DP_msg_ping_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length);

DP_Message *DP_msg_ping_parse(unsigned int context_id, DP_TextReader *reader);

DP_MsgPing *DP_msg_ping_cast(DP_Message *msg);

bool DP_msg_ping_is_pong(const DP_MsgPing *mp);


/*
 * DP_MSG_INTERNAL
 *
 * Reserved for internal use
 */


/*
 * DP_MSG_JOIN
 *
 * Inform the client of a new user
 *
 * This message is sent only be the server. It associates a username
 * with a context ID.
 */

#define DP_MSG_JOIN_STATIC_LENGTH 2

#define DP_MSG_JOIN_FLAGS_AUTH 0x1
#define DP_MSG_JOIN_FLAGS_MOD  0x2
#define DP_MSG_JOIN_FLAGS_BOT  0x4

const char *DP_msg_join_flags_flag_name(unsigned int value);

typedef struct DP_MsgJoin DP_MsgJoin;

DP_Message *DP_msg_join_new(unsigned int context_id, uint8_t flags,
                            const char *name_value, size_t name_len,
                            void (*set_avatar)(size_t, unsigned char *, void *),
                            size_t avatar_size, void *avatar_user);

DP_Message *DP_msg_join_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length);

DP_Message *DP_msg_join_parse(unsigned int context_id, DP_TextReader *reader);

DP_MsgJoin *DP_msg_join_cast(DP_Message *msg);

uint8_t DP_msg_join_flags(const DP_MsgJoin *mj);

const char *DP_msg_join_name(const DP_MsgJoin *mj, size_t *out_len);

size_t DP_msg_join_name_len(const DP_MsgJoin *mj);

const unsigned char *DP_msg_join_avatar(const DP_MsgJoin *mj, size_t *out_size);

size_t DP_msg_join_avatar_size(const DP_MsgJoin *mj);


/*
 * DP_MSG_LEAVE
 *
 * Inform the client of a user leaving
 *
 * This message is sent only by the server. Upon receiving this message,
 * clients will typically remove the user from the user listing. The client
 * is also allowed to release resources associated with this context ID.
 */

#define DP_MSG_LEAVE_STATIC_LENGTH 0

DP_Message *DP_msg_leave_new(unsigned int context_id);

DP_Message *DP_msg_leave_deserialize(unsigned int context_id,
                                     const unsigned char *buffer,
                                     size_t length);

DP_Message *DP_msg_leave_parse(unsigned int context_id, DP_TextReader *reader);


/*
 * DP_MSG_SESSION_OWNER
 *
 * Session ownership change
 *
 * This message sets the users who have operator status. It can be
 * sent by users who are already operators or by the server (user id=0).
 *
 * The list of operators implicitly contains the user who sends the
 * message, thus users cannot deop themselves.
 *
 * The server sanitizes the ID list so, when distributed to other users,
 * it does not contain any duplicates or non-existing users and can be trusted
 * without checking the access control list.
 */

#define DP_MSG_SESSION_OWNER_STATIC_LENGTH 0

typedef struct DP_MsgSessionOwner DP_MsgSessionOwner;

DP_Message *DP_msg_session_owner_new(unsigned int context_id,
                                     void (*set_users)(int, uint8_t *, void *),
                                     int users_count, void *users_user);

DP_Message *DP_msg_session_owner_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length);

DP_Message *DP_msg_session_owner_parse(unsigned int context_id,
                                       DP_TextReader *reader);

DP_MsgSessionOwner *DP_msg_session_owner_cast(DP_Message *msg);

const uint8_t *DP_msg_session_owner_users(const DP_MsgSessionOwner *mso,
                                          int *out_count);

int DP_msg_session_owner_users_count(const DP_MsgSessionOwner *mso);


/*
 * DP_MSG_CHAT
 *
 * A chat message
 *
 * Chat message sent by the server with the user ID 0 are server messages.
 * (Typically a Command message is used for server announcements, but the Chat
 * message is used for those messages that must be stored in the session
 * history.)
 */

#define DP_MSG_CHAT_STATIC_LENGTH 2

#define DP_MSG_CHAT_TFLAGS_BYPASS 0x1

const char *DP_msg_chat_tflags_flag_name(unsigned int value);

#define DP_MSG_CHAT_OFLAGS_SHOUT  0x1
#define DP_MSG_CHAT_OFLAGS_ACTION 0x2
#define DP_MSG_CHAT_OFLAGS_PIN    0x4
#define DP_MSG_CHAT_OFLAGS_ALERT  0x8

const char *DP_msg_chat_oflags_flag_name(unsigned int value);

typedef struct DP_MsgChat DP_MsgChat;

DP_Message *DP_msg_chat_new(unsigned int context_id, uint8_t tflags,
                            uint8_t oflags, const char *message_value,
                            size_t message_len);

DP_Message *DP_msg_chat_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length);

DP_Message *DP_msg_chat_parse(unsigned int context_id, DP_TextReader *reader);

DP_MsgChat *DP_msg_chat_cast(DP_Message *msg);

uint8_t DP_msg_chat_tflags(const DP_MsgChat *mc);

uint8_t DP_msg_chat_oflags(const DP_MsgChat *mc);

const char *DP_msg_chat_message(const DP_MsgChat *mc, size_t *out_len);

size_t DP_msg_chat_message_len(const DP_MsgChat *mc);


/*
 * DP_MSG_TRUSTED_USERS
 *
 * List of trusted users
 *
 * This message sets the list of user who have been tagged as trusted,
 * but who are not operators. The meaning of "trusted" is a mostly
 * clientside concept, but the session can be configured to allow trusted
 * users access to some operator commands. (Deputies)
 *
 * This command can be sent by operators or by the server (ctx=0).
 *
 * The server sanitizes the ID list so, when distributed to other users,
 * it does not contain any duplicates or non-existing users and can be trusted
 * without checking the access control list.
 */

#define DP_MSG_TRUSTED_USERS_STATIC_LENGTH 0

typedef struct DP_MsgTrustedUsers DP_MsgTrustedUsers;

DP_Message *DP_msg_trusted_users_new(unsigned int context_id,
                                     void (*set_users)(int, uint8_t *, void *),
                                     int users_count, void *users_user);

DP_Message *DP_msg_trusted_users_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length);

DP_Message *DP_msg_trusted_users_parse(unsigned int context_id,
                                       DP_TextReader *reader);

DP_MsgTrustedUsers *DP_msg_trusted_users_cast(DP_Message *msg);

const uint8_t *DP_msg_trusted_users_users(const DP_MsgTrustedUsers *mtu,
                                          int *out_count);

int DP_msg_trusted_users_users_count(const DP_MsgTrustedUsers *mtu);


/*
 * DP_MSG_SOFT_RESET
 *
 * Soft reset point marker
 *
 * This message marks the point in the session history where a soft reset
 * occurs. A thick-server performs an internal soft-reset when a user joins.
 *
 * All users should truncate their own session history when receiving this
 * message, since undos cannot cross the reset boundary.
 */

#define DP_MSG_SOFT_RESET_STATIC_LENGTH 0

DP_Message *DP_msg_soft_reset_new(unsigned int context_id);

DP_Message *DP_msg_soft_reset_deserialize(unsigned int context_id,
                                          const unsigned char *buffer,
                                          size_t length);

DP_Message *DP_msg_soft_reset_parse(unsigned int context_id,
                                    DP_TextReader *reader);


/*
 * DP_MSG_PRIVATE_CHAT
 *
 * A private chat message
 *
 * Note. This message type was added in protocol 4.21.2 (v. 2.1.0). For backward
 * compatiblity, the server will not send any private messages from itself; it
 * will only relay them from other users. In version 3.0, this should be merged
 * with the normal Chat message.
 *
 * Private messages always bypass the session history.
 */

#define DP_MSG_PRIVATE_CHAT_STATIC_LENGTH 2

typedef struct DP_MsgPrivateChat DP_MsgPrivateChat;

DP_Message *DP_msg_private_chat_new(unsigned int context_id, uint8_t target,
                                    uint8_t oflags, const char *message_value,
                                    size_t message_len);

DP_Message *DP_msg_private_chat_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length);

DP_Message *DP_msg_private_chat_parse(unsigned int context_id,
                                      DP_TextReader *reader);

DP_MsgPrivateChat *DP_msg_private_chat_cast(DP_Message *msg);

uint8_t DP_msg_private_chat_target(const DP_MsgPrivateChat *mpc);

uint8_t DP_msg_private_chat_oflags(const DP_MsgPrivateChat *mpc);

const char *DP_msg_private_chat_message(const DP_MsgPrivateChat *mpc,
                                        size_t *out_len);

size_t DP_msg_private_chat_message_len(const DP_MsgPrivateChat *mpc);


/*
 * DP_MSG_INTERVAL
 *
 * Event interval record
 *
 * This is used to preserve timing information in session recordings.
 *
 * Note. The maximum interval (using a single message) is about 65 seconds.
 * Typically the intervals we want to store are a few seconds at most, so this
 * should be enough.
 */

#define DP_MSG_INTERVAL_STATIC_LENGTH 2

typedef struct DP_MsgInterval DP_MsgInterval;

DP_Message *DP_msg_interval_new(unsigned int context_id, uint16_t msecs);

DP_Message *DP_msg_interval_deserialize(unsigned int context_id,
                                        const unsigned char *buffer,
                                        size_t length);

DP_Message *DP_msg_interval_parse(unsigned int context_id,
                                  DP_TextReader *reader);

DP_MsgInterval *DP_msg_interval_cast(DP_Message *msg);

uint16_t DP_msg_interval_msecs(const DP_MsgInterval *mi);


/*
 * DP_MSG_LASER_TRAIL
 *
 * Start/end drawing pointer laser trail
 *
 * This signals the beginning or the end of a laser pointer trail. The trail
 * coordinates are sent with MovePointer messages.
 *
 * A nonzero persistence indicates the start of the trail and zero the end.
 */

#define DP_MSG_LASER_TRAIL_STATIC_LENGTH 5

typedef struct DP_MsgLaserTrail DP_MsgLaserTrail;

DP_Message *DP_msg_laser_trail_new(unsigned int context_id, uint32_t color,
                                   uint8_t persistence);

DP_Message *DP_msg_laser_trail_deserialize(unsigned int context_id,
                                           const unsigned char *buffer,
                                           size_t length);

DP_Message *DP_msg_laser_trail_parse(unsigned int context_id,
                                     DP_TextReader *reader);

DP_MsgLaserTrail *DP_msg_laser_trail_cast(DP_Message *msg);

uint32_t DP_msg_laser_trail_color(const DP_MsgLaserTrail *mlt);

uint8_t DP_msg_laser_trail_persistence(const DP_MsgLaserTrail *mlt);


/*
 * DP_MSG_MOVE_POINTER
 *
 * Move user pointer
 *
 * This is message is used to update the position of the user pointer when no
 * actual drawing is taking place. It is also used to draw the "laser pointer"
 * trail. Note. This is a META message, since this is used for a temporary
 * visual effect only, and thus doesn't affect the actual canvas content.
 *
 * The pointer position is divided by 4, like classic brushes.
 */

#define DP_MSG_MOVE_POINTER_STATIC_LENGTH 8

typedef struct DP_MsgMovePointer DP_MsgMovePointer;

DP_Message *DP_msg_move_pointer_new(unsigned int context_id, int32_t x,
                                    int32_t y);

DP_Message *DP_msg_move_pointer_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length);

DP_Message *DP_msg_move_pointer_parse(unsigned int context_id,
                                      DP_TextReader *reader);

DP_MsgMovePointer *DP_msg_move_pointer_cast(DP_Message *msg);

int32_t DP_msg_move_pointer_x(const DP_MsgMovePointer *mmp);

int32_t DP_msg_move_pointer_y(const DP_MsgMovePointer *mmp);


/*
 * DP_MSG_MARKER
 *
 * A bookmark
 *
 * This is used to bookmark points in the session for quick access when playing
 * back a recording
 */

#define DP_MSG_MARKER_STATIC_LENGTH 0

typedef struct DP_MsgMarker DP_MsgMarker;

DP_Message *DP_msg_marker_new(unsigned int context_id, const char *text_value,
                              size_t text_len);

DP_Message *DP_msg_marker_deserialize(unsigned int context_id,
                                      const unsigned char *buffer,
                                      size_t length);

DP_Message *DP_msg_marker_parse(unsigned int context_id, DP_TextReader *reader);

DP_MsgMarker *DP_msg_marker_cast(DP_Message *msg);

const char *DP_msg_marker_text(const DP_MsgMarker *mm, size_t *out_len);

size_t DP_msg_marker_text_len(const DP_MsgMarker *mm);


/*
 * DP_MSG_USER_ACL
 *
 * Set user specific locks
 *
 * This is an opaque meta command that contains a list of users to be locked.
 * It can only be sent by session operators.
 */

#define DP_MSG_USER_ACL_STATIC_LENGTH 0

typedef struct DP_MsgUserAcl DP_MsgUserAcl;

DP_Message *DP_msg_user_acl_new(unsigned int context_id,
                                void (*set_users)(int, uint8_t *, void *),
                                int users_count, void *users_user);

DP_Message *DP_msg_user_acl_deserialize(unsigned int context_id,
                                        const unsigned char *buffer,
                                        size_t length);

DP_Message *DP_msg_user_acl_parse(unsigned int context_id,
                                  DP_TextReader *reader);

DP_MsgUserAcl *DP_msg_user_acl_cast(DP_Message *msg);

const uint8_t *DP_msg_user_acl_users(const DP_MsgUserAcl *mua, int *out_count);

int DP_msg_user_acl_users_count(const DP_MsgUserAcl *mua);


/*
 * DP_MSG_LAYER_ACL
 *
 * Change layer access control list
 *
 * This is an opaque meta command. It is used to set the general layer lock
 * as well as give exclusive access to selected users.
 *
 * When the OWNLAYERS mode is set, any user can use this to change the ACLs on
 * layers they themselves have created (identified by the ID prefix.)
 *
 * Using layer ID 0 sets or clears a general canvaswide lock. The tier and
 * exclusive user list is not used in this case.
 *
 * The eighth bit of the flags field (0x80) indicates whether the layer is
 * locked in general. The first three bits (0x07) indicate the access tier
 * level.
 */

#define DP_MSG_LAYER_ACL_STATIC_LENGTH 3

typedef struct DP_MsgLayerAcl DP_MsgLayerAcl;

DP_Message *DP_msg_layer_acl_new(unsigned int context_id, uint16_t id,
                                 uint8_t flags,
                                 void (*set_exclusive)(int, uint8_t *, void *),
                                 int exclusive_count, void *exclusive_user);

DP_Message *DP_msg_layer_acl_deserialize(unsigned int context_id,
                                         const unsigned char *buffer,
                                         size_t length);

DP_Message *DP_msg_layer_acl_parse(unsigned int context_id,
                                   DP_TextReader *reader);

DP_MsgLayerAcl *DP_msg_layer_acl_cast(DP_Message *msg);

uint16_t DP_msg_layer_acl_id(const DP_MsgLayerAcl *mla);

uint8_t DP_msg_layer_acl_flags(const DP_MsgLayerAcl *mla);

const uint8_t *DP_msg_layer_acl_exclusive(const DP_MsgLayerAcl *mla,
                                          int *out_count);

int DP_msg_layer_acl_exclusive_count(const DP_MsgLayerAcl *mla);


/*
 * DP_MSG_FEATURE_ACCESS_LEVELS
 *
 * Change feature access tiers
 *
 * Tier 0 is operator, 1 is trusted, 2 is authenticated, 3 and above
 * is guest. A value of 255 means to leave that tier unchanged. Any
 * unknown features will be ignored by the client.
 */

#define DP_MSG_FEATURE_ACCESS_LEVELS_STATIC_LENGTH 0

typedef struct DP_MsgFeatureAccessLevels DP_MsgFeatureAccessLevels;

DP_Message *DP_msg_feature_access_levels_new(
    unsigned int context_id, void (*set_feature_tiers)(int, uint8_t *, void *),
    int feature_tiers_count, void *feature_tiers_user);

DP_Message *DP_msg_feature_access_levels_deserialize(
    unsigned int context_id, const unsigned char *buffer, size_t length);

DP_Message *DP_msg_feature_access_levels_parse(unsigned int context_id,
                                               DP_TextReader *reader);

DP_MsgFeatureAccessLevels *DP_msg_feature_access_levels_cast(DP_Message *msg);

const uint8_t *DP_msg_feature_access_levels_feature_tiers(
    const DP_MsgFeatureAccessLevels *mfal, int *out_count);

int DP_msg_feature_access_levels_feature_tiers_count(
    const DP_MsgFeatureAccessLevels *mfal);


/*
 * DP_MSG_DEFAULT_LAYER
 *
 * Set the default layer
 *
 * The default layer is the one new users default to when logging in.
 * If no default layer is set, the newest layer will be selected by default.
 */

#define DP_MSG_DEFAULT_LAYER_STATIC_LENGTH 2

typedef struct DP_MsgDefaultLayer DP_MsgDefaultLayer;

DP_Message *DP_msg_default_layer_new(unsigned int context_id, uint16_t id);

DP_Message *DP_msg_default_layer_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length);

DP_Message *DP_msg_default_layer_parse(unsigned int context_id,
                                       DP_TextReader *reader);

DP_MsgDefaultLayer *DP_msg_default_layer_cast(DP_Message *msg);

uint16_t DP_msg_default_layer_id(const DP_MsgDefaultLayer *mdl);


/*
 * DP_MSG_FILTERED
 *
 * A message that has been filtered away by the ACL filter
 *
 * This is only used in recordings for mainly debugging purposes.
 * This message should never be sent over the network.
 */

#define DP_MSG_FILTERED_STATIC_LENGTH 0

typedef struct DP_MsgFiltered DP_MsgFiltered;

DP_Message *DP_msg_filtered_new(unsigned int context_id,
                                void (*set_message)(size_t, unsigned char *,
                                                    void *),
                                size_t message_size, void *message_user);

DP_Message *DP_msg_filtered_deserialize(unsigned int context_id,
                                        const unsigned char *buffer,
                                        size_t length);

DP_Message *DP_msg_filtered_parse(unsigned int context_id,
                                  DP_TextReader *reader);

DP_MsgFiltered *DP_msg_filtered_cast(DP_Message *msg);

const unsigned char *DP_msg_filtered_message(const DP_MsgFiltered *mf,
                                             size_t *out_size);

size_t DP_msg_filtered_message_size(const DP_MsgFiltered *mf);


/*
 * DP_MSG_EXTENSION
 *
 * Reserved for non-standard extension use
 */


/*
 * DP_MSG_UNDO_DEPTH
 *
 * Set maximum undo depth
 */

#define DP_MSG_UNDO_DEPTH_STATIC_LENGTH 1

typedef struct DP_MsgUndoDepth DP_MsgUndoDepth;

DP_Message *DP_msg_undo_depth_new(unsigned int context_id, uint8_t depth);

DP_Message *DP_msg_undo_depth_deserialize(unsigned int context_id,
                                          const unsigned char *buffer,
                                          size_t length);

DP_Message *DP_msg_undo_depth_parse(unsigned int context_id,
                                    DP_TextReader *reader);

DP_MsgUndoDepth *DP_msg_undo_depth_cast(DP_Message *msg);

uint8_t DP_msg_undo_depth_depth(const DP_MsgUndoDepth *mud);


/*
 * DP_MSG_DATA
 *
 * Send and receive structured information. Intended for stuff like
 * sending and receiving user troubleshooting information, sharing
 * brushes etc. Should probably be a server meta message so that it
 * can be directed at the appropriate user, but that's something for
 * Drawpile 3.0.
 */

#define DP_MSG_DATA_STATIC_LENGTH 2

#define DP_MSG_DATA_TYPE_USER_INFO 0

const char *DP_msg_data_type_variant_name(unsigned int value);

typedef struct DP_MsgData DP_MsgData;

DP_Message *DP_msg_data_new(unsigned int context_id, uint8_t type,
                            uint8_t recipient,
                            void (*set_body)(size_t, unsigned char *, void *),
                            size_t body_size, void *body_user);

DP_Message *DP_msg_data_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length);

DP_Message *DP_msg_data_parse(unsigned int context_id, DP_TextReader *reader);

DP_MsgData *DP_msg_data_cast(DP_Message *msg);

uint8_t DP_msg_data_type(const DP_MsgData *md);

uint8_t DP_msg_data_recipient(const DP_MsgData *md);

const unsigned char *DP_msg_data_body(const DP_MsgData *md, size_t *out_size);

size_t DP_msg_data_body_size(const DP_MsgData *md);


/*
 * DP_MSG_LOCAL_CHANGE
 *
 * A local-only modification, such as toggling layer visibility or
 * setting a local canvas background. Shouldn't be sent over the
 * network, but will be recorded.
 */

#define DP_MSG_LOCAL_CHANGE_STATIC_LENGTH 1

#define DP_MSG_LOCAL_CHANGE_TYPE_LAYER_VISIBILITY 0
#define DP_MSG_LOCAL_CHANGE_TYPE_BACKGROUND_TILE  1
#define DP_MSG_LOCAL_CHANGE_TYPE_TRACK_VISIBILITY 2
#define DP_MSG_LOCAL_CHANGE_TYPE_TRACK_ONION_SKIN 3

const char *DP_msg_local_change_type_variant_name(unsigned int value);

typedef struct DP_MsgLocalChange DP_MsgLocalChange;

DP_Message *DP_msg_local_change_new(unsigned int context_id, uint8_t type,
                                    void (*set_body)(size_t, unsigned char *,
                                                     void *),
                                    size_t body_size, void *body_user);

DP_Message *DP_msg_local_change_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length);

DP_Message *DP_msg_local_change_parse(unsigned int context_id,
                                      DP_TextReader *reader);

DP_MsgLocalChange *DP_msg_local_change_cast(DP_Message *msg);

uint8_t DP_msg_local_change_type(const DP_MsgLocalChange *mlc);

const unsigned char *DP_msg_local_change_body(const DP_MsgLocalChange *mlc,
                                              size_t *out_size);

size_t DP_msg_local_change_body_size(const DP_MsgLocalChange *mlc);


/*
 * DP_MSG_UNDO_POINT
 *
 * Undo demarcation point
 *
 * The client sends an UndoPoint message to signal the start of an undoable
 * sequence.
 */

#define DP_MSG_UNDO_POINT_STATIC_LENGTH 0

DP_Message *DP_msg_undo_point_new(unsigned int context_id);

DP_Message *DP_msg_undo_point_deserialize(unsigned int context_id,
                                          const unsigned char *buffer,
                                          size_t length);

DP_Message *DP_msg_undo_point_parse(unsigned int context_id,
                                    DP_TextReader *reader);


/*
 * DP_MSG_CANVAS_RESIZE
 *
 * Adjust canvas size
 *
 * This is the first command that must be sent to initialize the session.
 *
 * This affects the size of all existing and future layers.
 *
 * The new canvas size is relative to the old one. The four adjustement
 * parameters extend or retract their respective borders.
 * Initial canvas resize should be (0, w, h, 0).
 */

#define DP_MSG_CANVAS_RESIZE_STATIC_LENGTH 16

typedef struct DP_MsgCanvasResize DP_MsgCanvasResize;

DP_Message *DP_msg_canvas_resize_new(unsigned int context_id, int32_t top,
                                     int32_t right, int32_t bottom,
                                     int32_t left);

DP_Message *DP_msg_canvas_resize_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length);

DP_Message *DP_msg_canvas_resize_parse(unsigned int context_id,
                                       DP_TextReader *reader);

DP_MsgCanvasResize *DP_msg_canvas_resize_cast(DP_Message *msg);

int32_t DP_msg_canvas_resize_top(const DP_MsgCanvasResize *mcr);

int32_t DP_msg_canvas_resize_right(const DP_MsgCanvasResize *mcr);

int32_t DP_msg_canvas_resize_bottom(const DP_MsgCanvasResize *mcr);

int32_t DP_msg_canvas_resize_left(const DP_MsgCanvasResize *mcr);


/*
 * DP_MSG_LAYER_CREATE
 *
 * Layer creation command (legacy, subsumed by LayerTreeCreate)
 *
 * A session starts with zero layers, so a layer creation command is typically
 * the second command to be sent, right after setting the canvas size.
 *
 * The layer ID must be prefixed with the context ID of the user creating it.
 * This allows users to choose the layer ID themselves without worrying about
 * clashes. In single user mode, the client can assign IDs as it pleases,
 * but in multiuser mode the server validates the prefix for all new layers.
 *
 * The following flags can be used with layer creation:
 * - COPY   -- a copy of the Source layer is made, rather than a blank layer
 * - INSERT -- the new layer is inserted above the Source layer. Source 0 means
 *             the layer will be placed bottom-most on the stack
 *
 * The Source layer ID should be zero when COPY or INSERT flags are not used.
 * When COPY is used, it should refer to an existing layer. Copy commands
 * referring to missing layers are dropped.
 * When INSERT is used, referring to 0 or a nonexistent layer places
 * the new layer at the bottom of the stack.
 *
 * If layer controls are locked, this command requires session operator
 * privileges.
 */

#define DP_MSG_LAYER_CREATE_STATIC_LENGTH 9

#define DP_MSG_LAYER_CREATE_FLAGS_COPY   0x1
#define DP_MSG_LAYER_CREATE_FLAGS_INSERT 0x2

const char *DP_msg_layer_create_flags_flag_name(unsigned int value);

typedef struct DP_MsgLayerCreate DP_MsgLayerCreate;

DP_Message *DP_msg_layer_create_new(unsigned int context_id, uint16_t id,
                                    uint16_t source, uint32_t fill,
                                    uint8_t flags, const char *title_value,
                                    size_t title_len);

DP_Message *DP_msg_layer_create_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length);

DP_Message *DP_msg_layer_create_parse(unsigned int context_id,
                                      DP_TextReader *reader);

DP_MsgLayerCreate *DP_msg_layer_create_cast(DP_Message *msg);

uint16_t DP_msg_layer_create_id(const DP_MsgLayerCreate *mlc);

uint16_t DP_msg_layer_create_source(const DP_MsgLayerCreate *mlc);

uint32_t DP_msg_layer_create_fill(const DP_MsgLayerCreate *mlc);

uint8_t DP_msg_layer_create_flags(const DP_MsgLayerCreate *mlc);

const char *DP_msg_layer_create_title(const DP_MsgLayerCreate *mlc,
                                      size_t *out_len);

size_t DP_msg_layer_create_title_len(const DP_MsgLayerCreate *mlc);


/*
 * DP_MSG_LAYER_ATTRIBUTES
 *
 * Change layer attributes
 *
 * If the target layer is locked, this command requires session operator
 * privileges.
 *
 * Specifying a sublayer requires session operator privileges. Currently, it is
 * used only when sublayers are needed at canvas initialization.
 *
 * Note: the `fixed` flag is unused since version 2.2. It's functionality is
 * replaced by the custom timeline feature.
 */

#define DP_MSG_LAYER_ATTRIBUTES_STATIC_LENGTH 6

#define DP_MSG_LAYER_ATTRIBUTES_FLAGS_CENSOR   0x1
#define DP_MSG_LAYER_ATTRIBUTES_FLAGS_FIXED    0x2
#define DP_MSG_LAYER_ATTRIBUTES_FLAGS_ISOLATED 0x4

const char *DP_msg_layer_attributes_flags_flag_name(unsigned int value);

typedef struct DP_MsgLayerAttributes DP_MsgLayerAttributes;

DP_Message *DP_msg_layer_attributes_new(unsigned int context_id, uint16_t id,
                                        uint8_t sublayer, uint8_t flags,
                                        uint8_t opacity, uint8_t blend);

DP_Message *DP_msg_layer_attributes_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length);

DP_Message *DP_msg_layer_attributes_parse(unsigned int context_id,
                                          DP_TextReader *reader);

DP_MsgLayerAttributes *DP_msg_layer_attributes_cast(DP_Message *msg);

uint16_t DP_msg_layer_attributes_id(const DP_MsgLayerAttributes *mla);

uint8_t DP_msg_layer_attributes_sublayer(const DP_MsgLayerAttributes *mla);

uint8_t DP_msg_layer_attributes_flags(const DP_MsgLayerAttributes *mla);

uint8_t DP_msg_layer_attributes_opacity(const DP_MsgLayerAttributes *mla);

uint8_t DP_msg_layer_attributes_blend(const DP_MsgLayerAttributes *mla);


/*
 * DP_MSG_LAYER_RETITLE
 *
 * Change a layer's title
 */

#define DP_MSG_LAYER_RETITLE_STATIC_LENGTH 2

typedef struct DP_MsgLayerRetitle DP_MsgLayerRetitle;

DP_Message *DP_msg_layer_retitle_new(unsigned int context_id, uint16_t id,
                                     const char *title_value, size_t title_len);

DP_Message *DP_msg_layer_retitle_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length);

DP_Message *DP_msg_layer_retitle_parse(unsigned int context_id,
                                       DP_TextReader *reader);

DP_MsgLayerRetitle *DP_msg_layer_retitle_cast(DP_Message *msg);

uint16_t DP_msg_layer_retitle_id(const DP_MsgLayerRetitle *mlr);

const char *DP_msg_layer_retitle_title(const DP_MsgLayerRetitle *mlr,
                                       size_t *out_len);

size_t DP_msg_layer_retitle_title_len(const DP_MsgLayerRetitle *mlr);


/*
 * DP_MSG_LAYER_ORDER
 *
 * Layer order change command (legacy, subsumed by LayerTreeOrder)
 *
 * New layers are always added to the top of the stack.
 * This command includes a list of layer IDs that define the new stacking order.
 *
 * An order change should list all layers in the stack, but due to
 * synchronization issues, that is not always possible. The layer order should
 * therefore be sanitized by removing all layers not in the current layer stack
 * and adding all missing layers to the end in their current relative order.
 *
 * For example: if the current stack is [1,2,3,4,5] and the client receives
 * a reordering command [3,4,1], the missing layers are appended: [3,4,1,2,5].
 *
 * If layer controls are locked, this command requires session operator
 * privileges.
 */

#define DP_MSG_LAYER_ORDER_STATIC_LENGTH 0

typedef struct DP_MsgLayerOrder DP_MsgLayerOrder;

DP_Message *DP_msg_layer_order_new(unsigned int context_id,
                                   void (*set_layers)(int, uint16_t *, void *),
                                   int layers_count, void *layers_user);

DP_Message *DP_msg_layer_order_deserialize(unsigned int context_id,
                                           const unsigned char *buffer,
                                           size_t length);

DP_Message *DP_msg_layer_order_parse(unsigned int context_id,
                                     DP_TextReader *reader);

DP_MsgLayerOrder *DP_msg_layer_order_cast(DP_Message *msg);

const uint16_t *DP_msg_layer_order_layers(const DP_MsgLayerOrder *mlo,
                                          int *out_count);

int DP_msg_layer_order_layers_count(const DP_MsgLayerOrder *mlo);


/*
 * DP_MSG_LAYER_DELETE
 *
 * Layer deletion command (legacy, subsumed by LayerTreeDelete)
 *
 * If the merge attribute is set, the contents of the layer is merged
 * to the layer below it. Merging the bottom-most layer does nothing.
 *
 * If the current layer or layer controls in general are locked, this command
 * requires session operator privileges.
 */

#define DP_MSG_LAYER_DELETE_STATIC_LENGTH 3

typedef struct DP_MsgLayerDelete DP_MsgLayerDelete;

DP_Message *DP_msg_layer_delete_new(unsigned int context_id, uint16_t id,
                                    bool merge);

DP_Message *DP_msg_layer_delete_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length);

DP_Message *DP_msg_layer_delete_parse(unsigned int context_id,
                                      DP_TextReader *reader);

DP_MsgLayerDelete *DP_msg_layer_delete_cast(DP_Message *msg);

uint16_t DP_msg_layer_delete_id(const DP_MsgLayerDelete *mld);

bool DP_msg_layer_delete_merge(const DP_MsgLayerDelete *mld);


/*
 * DP_MSG_LAYER_VISIBILITY
 *
 * Removed in version 2.2, but still included for compatibility with
 * 2.1 sessions that might send it, the client ignores them though.
 * Effectively replaced by LocalChange.
 */

#define DP_MSG_LAYER_VISIBILITY_STATIC_LENGTH 3

typedef struct DP_MsgLayerVisibility DP_MsgLayerVisibility;

DP_Message *DP_msg_layer_visibility_new(unsigned int context_id, uint16_t id,
                                        bool visible);

DP_Message *DP_msg_layer_visibility_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length);

DP_Message *DP_msg_layer_visibility_parse(unsigned int context_id,
                                          DP_TextReader *reader);

DP_MsgLayerVisibility *DP_msg_layer_visibility_cast(DP_Message *msg);

uint16_t DP_msg_layer_visibility_id(const DP_MsgLayerVisibility *mlv);

bool DP_msg_layer_visibility_visible(const DP_MsgLayerVisibility *mlv);


/*
 * DP_MSG_PUT_IMAGE
 *
 * Draw a bitmap onto a layer
 *
 * This is used for pasting images, floodfill, merging annotations and
 * other tasks where image processing is done clientisde.
 *
 * All layer blending modes are supported.
 *
 * The image data is DEFLATEd 32bit premultiplied ARGB data. The image
 * is prefixed with a 32 bit unsigned integer (big endian) which contains
 * the expected length of the uncompressed data.
 *
 * Note that since the message length is fairly limited, a
 * large image may have to be divided into multiple PutImage
 * commands.
 */

#define DP_MSG_PUT_IMAGE_STATIC_LENGTH 19

typedef struct DP_MsgPutImage DP_MsgPutImage;

DP_Message *
DP_msg_put_image_new(unsigned int context_id, uint16_t layer, uint8_t mode,
                     uint32_t x, uint32_t y, uint32_t w, uint32_t h,
                     void (*set_image)(size_t, unsigned char *, void *),
                     size_t image_size, void *image_user);

DP_Message *DP_msg_put_image_deserialize(unsigned int context_id,
                                         const unsigned char *buffer,
                                         size_t length);

DP_Message *DP_msg_put_image_parse(unsigned int context_id,
                                   DP_TextReader *reader);

DP_MsgPutImage *DP_msg_put_image_cast(DP_Message *msg);

uint16_t DP_msg_put_image_layer(const DP_MsgPutImage *mpi);

uint8_t DP_msg_put_image_mode(const DP_MsgPutImage *mpi);

uint32_t DP_msg_put_image_x(const DP_MsgPutImage *mpi);

uint32_t DP_msg_put_image_y(const DP_MsgPutImage *mpi);

uint32_t DP_msg_put_image_w(const DP_MsgPutImage *mpi);

uint32_t DP_msg_put_image_h(const DP_MsgPutImage *mpi);

const unsigned char *DP_msg_put_image_image(const DP_MsgPutImage *mpi,
                                            size_t *out_size);

size_t DP_msg_put_image_image_size(const DP_MsgPutImage *mpi);


/*
 * DP_MSG_FILL_RECT
 *
 * Fill a rectangle with solid color
 */

#define DP_MSG_FILL_RECT_STATIC_LENGTH 23

typedef struct DP_MsgFillRect DP_MsgFillRect;

DP_Message *DP_msg_fill_rect_new(unsigned int context_id, uint16_t layer,
                                 uint8_t mode, uint32_t x, uint32_t y,
                                 uint32_t w, uint32_t h, uint32_t color);

DP_Message *DP_msg_fill_rect_deserialize(unsigned int context_id,
                                         const unsigned char *buffer,
                                         size_t length);

DP_Message *DP_msg_fill_rect_parse(unsigned int context_id,
                                   DP_TextReader *reader);

DP_MsgFillRect *DP_msg_fill_rect_cast(DP_Message *msg);

uint16_t DP_msg_fill_rect_layer(const DP_MsgFillRect *mfr);

uint8_t DP_msg_fill_rect_mode(const DP_MsgFillRect *mfr);

uint32_t DP_msg_fill_rect_x(const DP_MsgFillRect *mfr);

uint32_t DP_msg_fill_rect_y(const DP_MsgFillRect *mfr);

uint32_t DP_msg_fill_rect_w(const DP_MsgFillRect *mfr);

uint32_t DP_msg_fill_rect_h(const DP_MsgFillRect *mfr);

uint32_t DP_msg_fill_rect_color(const DP_MsgFillRect *mfr);


/*
 * DP_MSG_TOOL_CHANGE
 *
 * Removed in version 2.1
 */


/*
 * DP_MSG_PEN_MOVE
 *
 * Removed in version 2.1
 */


/*
 * DP_MSG_PEN_UP
 *
 * Pen up command
 *
 * The pen up command signals the end of a stroke. In indirect drawing mode, it
 * causes indirect dabs (by this user) to be merged to their parent layers.
 */

#define DP_MSG_PEN_UP_STATIC_LENGTH 0

DP_Message *DP_msg_pen_up_new(unsigned int context_id);

DP_Message *DP_msg_pen_up_deserialize(unsigned int context_id,
                                      const unsigned char *buffer,
                                      size_t length);

DP_Message *DP_msg_pen_up_parse(unsigned int context_id, DP_TextReader *reader);


/*
 * DP_MSG_ANNOTATION_CREATE
 *
 * Create a new annotation
 *
 * Annotations are floating text layers. They are drawn over the image layers
 * and have no defined stacking order.
 *
 * The new annotation created with this command is initally empy with a
 * transparent background
 */

#define DP_MSG_ANNOTATION_CREATE_STATIC_LENGTH 14

typedef struct DP_MsgAnnotationCreate DP_MsgAnnotationCreate;

DP_Message *DP_msg_annotation_create_new(unsigned int context_id, uint16_t id,
                                         int32_t x, int32_t y, uint16_t w,
                                         uint16_t h);

DP_Message *DP_msg_annotation_create_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_annotation_create_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgAnnotationCreate *DP_msg_annotation_create_cast(DP_Message *msg);

uint16_t DP_msg_annotation_create_id(const DP_MsgAnnotationCreate *mac);

int32_t DP_msg_annotation_create_x(const DP_MsgAnnotationCreate *mac);

int32_t DP_msg_annotation_create_y(const DP_MsgAnnotationCreate *mac);

uint16_t DP_msg_annotation_create_w(const DP_MsgAnnotationCreate *mac);

uint16_t DP_msg_annotation_create_h(const DP_MsgAnnotationCreate *mac);


/*
 * DP_MSG_ANNOTATION_RESHAPE
 *
 * Change the position and size of an annotation
 */

#define DP_MSG_ANNOTATION_RESHAPE_STATIC_LENGTH 14

typedef struct DP_MsgAnnotationReshape DP_MsgAnnotationReshape;

DP_Message *DP_msg_annotation_reshape_new(unsigned int context_id, uint16_t id,
                                          int32_t x, int32_t y, uint16_t w,
                                          uint16_t h);

DP_Message *DP_msg_annotation_reshape_deserialize(unsigned int context_id,
                                                  const unsigned char *buffer,
                                                  size_t length);

DP_Message *DP_msg_annotation_reshape_parse(unsigned int context_id,
                                            DP_TextReader *reader);

DP_MsgAnnotationReshape *DP_msg_annotation_reshape_cast(DP_Message *msg);

uint16_t DP_msg_annotation_reshape_id(const DP_MsgAnnotationReshape *mar);

int32_t DP_msg_annotation_reshape_x(const DP_MsgAnnotationReshape *mar);

int32_t DP_msg_annotation_reshape_y(const DP_MsgAnnotationReshape *mar);

uint16_t DP_msg_annotation_reshape_w(const DP_MsgAnnotationReshape *mar);

uint16_t DP_msg_annotation_reshape_h(const DP_MsgAnnotationReshape *mar);


/*
 * DP_MSG_ANNOTATION_EDIT
 *
 * Change annotation content
 *
 * Accepted contents is the subset of HTML understood by QTextDocument
 *
 * If an annotation is flagged as protected, it cannot be modified by users
 * other than the one who created it, or session operators.
 */

#define DP_MSG_ANNOTATION_EDIT_STATIC_LENGTH 8

#define DP_MSG_ANNOTATION_EDIT_FLAGS_PROTECT       0x1
#define DP_MSG_ANNOTATION_EDIT_FLAGS_VALIGN_CENTER 0x2
#define DP_MSG_ANNOTATION_EDIT_FLAGS_VALIGN_BOTTOM 0x4

const char *DP_msg_annotation_edit_flags_flag_name(unsigned int value);

typedef struct DP_MsgAnnotationEdit DP_MsgAnnotationEdit;

DP_Message *DP_msg_annotation_edit_new(unsigned int context_id, uint16_t id,
                                       uint32_t bg, uint8_t flags,
                                       uint8_t border, const char *text_value,
                                       size_t text_len);

DP_Message *DP_msg_annotation_edit_deserialize(unsigned int context_id,
                                               const unsigned char *buffer,
                                               size_t length);

DP_Message *DP_msg_annotation_edit_parse(unsigned int context_id,
                                         DP_TextReader *reader);

DP_MsgAnnotationEdit *DP_msg_annotation_edit_cast(DP_Message *msg);

uint16_t DP_msg_annotation_edit_id(const DP_MsgAnnotationEdit *mae);

uint32_t DP_msg_annotation_edit_bg(const DP_MsgAnnotationEdit *mae);

uint8_t DP_msg_annotation_edit_flags(const DP_MsgAnnotationEdit *mae);

uint8_t DP_msg_annotation_edit_border(const DP_MsgAnnotationEdit *mae);

const char *DP_msg_annotation_edit_text(const DP_MsgAnnotationEdit *mae,
                                        size_t *out_len);

size_t DP_msg_annotation_edit_text_len(const DP_MsgAnnotationEdit *mae);


/*
 * DP_MSG_ANNOTATION_DELETE
 *
 * Delete an annotation
 *
 * Note: Unlike in layer delete command, there is no "merge" option here.
 * Merging an annotation is done by rendering the annotation item to
 * an image and drawing the image with the PutImage command. This ensures
 * identical rendering on all clients.
 */

#define DP_MSG_ANNOTATION_DELETE_STATIC_LENGTH 2

typedef struct DP_MsgAnnotationDelete DP_MsgAnnotationDelete;

DP_Message *DP_msg_annotation_delete_new(unsigned int context_id, uint16_t id);

DP_Message *DP_msg_annotation_delete_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_annotation_delete_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgAnnotationDelete *DP_msg_annotation_delete_cast(DP_Message *msg);

uint16_t DP_msg_annotation_delete_id(const DP_MsgAnnotationDelete *mad);


/*
 * DP_MSG_MOVE_REGION
 *
 * Move (and transform) a region of a layer (legacy, subsumed by
 * TransformRegion)
 *
 * This is used to implement selection moving. It is equivalent
 * to doing two PutImages: the first to mask away the original
 * selection and the other to paste the selection to a new location.
 *
 * This command packages that into a single action that is more
 * bandwidth efficient and can be used even when PutImages in general
 * are locked, since it's not introducing any new pixels onto the canvas.
 *
 * Internally, the paint engine performs the following steps:
 * 1. Copy selected pixels to a buffer
 * 2. Erase selected pixels from the layer
 * 3. Composite transformed buffer onto the layer
 *
 * The pixel selection is determined by the mask bitmap. The mask
 * is DEFLATEd 1 bit per pixel bitmap data.
 *
 * For axis aligned rectangle selections, no bitmap is necessary.
 */

#define DP_MSG_MOVE_REGION_STATIC_LENGTH 50

typedef struct DP_MsgMoveRegion DP_MsgMoveRegion;

DP_Message *
DP_msg_move_region_new(unsigned int context_id, uint16_t layer, int32_t bx,
                       int32_t by, int32_t bw, int32_t bh, int32_t x1,
                       int32_t y1, int32_t x2, int32_t y2, int32_t x3,
                       int32_t y3, int32_t x4, int32_t y4,
                       void (*set_mask)(size_t, unsigned char *, void *),
                       size_t mask_size, void *mask_user);

DP_Message *DP_msg_move_region_deserialize(unsigned int context_id,
                                           const unsigned char *buffer,
                                           size_t length);

DP_Message *DP_msg_move_region_parse(unsigned int context_id,
                                     DP_TextReader *reader);

DP_MsgMoveRegion *DP_msg_move_region_cast(DP_Message *msg);

uint16_t DP_msg_move_region_layer(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_bx(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_by(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_bw(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_bh(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_x1(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_y1(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_x2(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_y2(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_x3(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_y3(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_x4(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_y4(const DP_MsgMoveRegion *mmr);

const unsigned char *DP_msg_move_region_mask(const DP_MsgMoveRegion *mmr,
                                             size_t *out_size);

size_t DP_msg_move_region_mask_size(const DP_MsgMoveRegion *mmr);


/*
 * DP_MSG_PUT_TILE
 *
 * Set the content of a tile
 *
 * Unlike PutImage, this replaces an entire tile directly without any blending.
 * This command is typically used during canvas initialization to set the
 * initial content.
 *
 * PutTile can target sublayers as well. This is used when generating a reset
 * image with incomplete indirect strokes. Sending a PenUp command will merge
 * the sublayer.
 */

#define DP_MSG_PUT_TILE_STATIC_LENGTH 9

typedef struct DP_MsgPutTile DP_MsgPutTile;

DP_Message *
DP_msg_put_tile_new(unsigned int context_id, uint16_t layer, uint8_t sublayer,
                    uint16_t col, uint16_t row, uint16_t repeat,
                    void (*set_image)(size_t, unsigned char *, void *),
                    size_t image_size, void *image_user);

DP_Message *DP_msg_put_tile_deserialize(unsigned int context_id,
                                        const unsigned char *buffer,
                                        size_t length);

DP_Message *DP_msg_put_tile_parse(unsigned int context_id,
                                  DP_TextReader *reader);

DP_MsgPutTile *DP_msg_put_tile_cast(DP_Message *msg);

uint16_t DP_msg_put_tile_layer(const DP_MsgPutTile *mpt);

uint8_t DP_msg_put_tile_sublayer(const DP_MsgPutTile *mpt);

uint16_t DP_msg_put_tile_col(const DP_MsgPutTile *mpt);

uint16_t DP_msg_put_tile_row(const DP_MsgPutTile *mpt);

uint16_t DP_msg_put_tile_repeat(const DP_MsgPutTile *mpt);

const unsigned char *DP_msg_put_tile_image(const DP_MsgPutTile *mpt,
                                           size_t *out_size);

size_t DP_msg_put_tile_image_size(const DP_MsgPutTile *mpt);


/*
 * DP_MSG_CANVAS_BACKGROUND
 *
 * Set the canvas background tile
 *
 * If the payload is exactly 4 bytes long, it should be interpreted as a solid
 * background color. Otherwise, it is the DEFLATED tile bitmap
 */

#define DP_MSG_CANVAS_BACKGROUND_STATIC_LENGTH 0

typedef struct DP_MsgCanvasBackground DP_MsgCanvasBackground;

DP_Message *
DP_msg_canvas_background_new(unsigned int context_id,
                             void (*set_image)(size_t, unsigned char *, void *),
                             size_t image_size, void *image_user);

DP_Message *DP_msg_canvas_background_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_canvas_background_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgCanvasBackground *DP_msg_canvas_background_cast(DP_Message *msg);

const unsigned char *
DP_msg_canvas_background_image(const DP_MsgCanvasBackground *mcb,
                               size_t *out_size);

size_t DP_msg_canvas_background_image_size(const DP_MsgCanvasBackground *mcb);


/*
 * DP_MSG_DRAW_DABS_CLASSIC
 *
 * Draw classic brush dabs
 *
 * A simple delta compression scheme is used.
 * The coordinates of each dab are relative to the previous dab.
 * The coordinate system has 1/4 pixel resolution. Divide by 4.0 before use.
 * The size field is the brush diameter multiplied by 256.
 */

#define DP_MSG_DRAW_DABS_CLASSIC_STATIC_LENGTH 15

#define DP_MSG_DRAW_DABS_CLASSIC_DABS_MAX 10920

typedef struct DP_ClassicDab DP_ClassicDab;

void DP_classic_dab_init(DP_ClassicDab *cds, int i, int8_t x, int8_t y,
                         uint16_t size, uint8_t hardness, uint8_t opacity);

int8_t DP_classic_dab_x(const DP_ClassicDab *cd);

int8_t DP_classic_dab_y(const DP_ClassicDab *cd);

uint16_t DP_classic_dab_size(const DP_ClassicDab *cd);

uint8_t DP_classic_dab_hardness(const DP_ClassicDab *cd);

uint8_t DP_classic_dab_opacity(const DP_ClassicDab *cd);

const DP_ClassicDab *DP_classic_dab_at(const DP_ClassicDab *cd, int i);


typedef struct DP_MsgDrawDabsClassic DP_MsgDrawDabsClassic;

DP_Message *
DP_msg_draw_dabs_classic_new(unsigned int context_id, uint16_t layer, int32_t x,
                             int32_t y, uint32_t color, uint8_t mode,
                             void (*set_dabs)(int, DP_ClassicDab *, void *),
                             int dabs_count, void *dabs_user);

DP_Message *DP_msg_draw_dabs_classic_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_draw_dabs_classic_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgDrawDabsClassic *DP_msg_draw_dabs_classic_cast(DP_Message *msg);

uint16_t DP_msg_draw_dabs_classic_layer(const DP_MsgDrawDabsClassic *mddc);

int32_t DP_msg_draw_dabs_classic_x(const DP_MsgDrawDabsClassic *mddc);

int32_t DP_msg_draw_dabs_classic_y(const DP_MsgDrawDabsClassic *mddc);

uint32_t DP_msg_draw_dabs_classic_color(const DP_MsgDrawDabsClassic *mddc);

uint8_t DP_msg_draw_dabs_classic_mode(const DP_MsgDrawDabsClassic *mddc);

const DP_ClassicDab *
DP_msg_draw_dabs_classic_dabs(const DP_MsgDrawDabsClassic *mddc,
                              int *out_count);

int DP_msg_draw_dabs_classic_dabs_count(const DP_MsgDrawDabsClassic *mddc);


/*
 * DP_MSG_DRAW_DABS_PIXEL
 *
 * Draw round pixel brush dabs
 *
 * The same kind of delta compression is used as in classicdabs,
 * but the fields all have integer precision.
 */

#define DP_MSG_DRAW_DABS_PIXEL_STATIC_LENGTH 15

#define DP_MSG_DRAW_DABS_PIXEL_DABS_MAX 16380

typedef struct DP_PixelDab DP_PixelDab;

void DP_pixel_dab_init(DP_PixelDab *pds, int i, int8_t x, int8_t y,
                       uint8_t size, uint8_t opacity);

int8_t DP_pixel_dab_x(const DP_PixelDab *pd);

int8_t DP_pixel_dab_y(const DP_PixelDab *pd);

uint8_t DP_pixel_dab_size(const DP_PixelDab *pd);

uint8_t DP_pixel_dab_opacity(const DP_PixelDab *pd);

const DP_PixelDab *DP_pixel_dab_at(const DP_PixelDab *pd, int i);


typedef struct DP_MsgDrawDabsPixel DP_MsgDrawDabsPixel;

DP_Message *
DP_msg_draw_dabs_pixel_new(unsigned int context_id, uint16_t layer, int32_t x,
                           int32_t y, uint32_t color, uint8_t mode,
                           void (*set_dabs)(int, DP_PixelDab *, void *),
                           int dabs_count, void *dabs_user);

DP_Message *DP_msg_draw_dabs_pixel_deserialize(unsigned int context_id,
                                               const unsigned char *buffer,
                                               size_t length);

DP_Message *DP_msg_draw_dabs_pixel_parse(unsigned int context_id,
                                         DP_TextReader *reader);

DP_MsgDrawDabsPixel *DP_msg_draw_dabs_pixel_cast(DP_Message *msg);

uint16_t DP_msg_draw_dabs_pixel_layer(const DP_MsgDrawDabsPixel *mddp);

int32_t DP_msg_draw_dabs_pixel_x(const DP_MsgDrawDabsPixel *mddp);

int32_t DP_msg_draw_dabs_pixel_y(const DP_MsgDrawDabsPixel *mddp);

uint32_t DP_msg_draw_dabs_pixel_color(const DP_MsgDrawDabsPixel *mddp);

uint8_t DP_msg_draw_dabs_pixel_mode(const DP_MsgDrawDabsPixel *mddp);

const DP_PixelDab *DP_msg_draw_dabs_pixel_dabs(const DP_MsgDrawDabsPixel *mddp,
                                               int *out_count);

int DP_msg_draw_dabs_pixel_dabs_count(const DP_MsgDrawDabsPixel *mddp);


/*
 * DP_MSG_DRAW_DABS_PIXEL_SQUARE
 *
 * Draw square pixel brush dabs
 */

#define DP_MSG_DRAW_DABS_PIXEL_SQUARE_STATIC_LENGTH 0

DP_Message *DP_msg_draw_dabs_pixel_square_new(
    unsigned int context_id, uint16_t layer, int32_t x, int32_t y,
    uint32_t color, uint8_t mode, void (*set_dabs)(int, DP_PixelDab *, void *),
    int dabs_count, void *dabs_user);

DP_Message *DP_msg_draw_dabs_pixel_square_deserialize(
    unsigned int context_id, const unsigned char *buffer, size_t length);

DP_Message *DP_msg_draw_dabs_pixel_square_parse(unsigned int context_id,
                                                DP_TextReader *reader);

DP_MsgDrawDabsPixel *DP_msg_draw_dabs_pixel_square_cast(DP_Message *msg);


/*
 * DP_MSG_DRAW_DABS_MYPAINT
 *
 * Draw MyPaint brush dabs
 */

#define DP_MSG_DRAW_DABS_MYPAINT_STATIC_LENGTH 18

#define DP_MSG_DRAW_DABS_MYPAINT_DABS_MAX 8189

typedef struct DP_MyPaintDab DP_MyPaintDab;

void DP_mypaint_dab_init(DP_MyPaintDab *mpds, int i, int8_t x, int8_t y,
                         uint16_t size, uint8_t hardness, uint8_t opacity,
                         uint8_t angle, uint8_t aspect_ratio);

int8_t DP_mypaint_dab_x(const DP_MyPaintDab *mpd);

int8_t DP_mypaint_dab_y(const DP_MyPaintDab *mpd);

uint16_t DP_mypaint_dab_size(const DP_MyPaintDab *mpd);

uint8_t DP_mypaint_dab_hardness(const DP_MyPaintDab *mpd);

uint8_t DP_mypaint_dab_opacity(const DP_MyPaintDab *mpd);

uint8_t DP_mypaint_dab_angle(const DP_MyPaintDab *mpd);

uint8_t DP_mypaint_dab_aspect_ratio(const DP_MyPaintDab *mpd);

const DP_MyPaintDab *DP_mypaint_dab_at(const DP_MyPaintDab *mpd, int i);


typedef struct DP_MsgDrawDabsMyPaint DP_MsgDrawDabsMyPaint;

DP_Message *DP_msg_draw_dabs_mypaint_new(
    unsigned int context_id, uint16_t layer, int32_t x, int32_t y,
    uint32_t color, uint8_t lock_alpha, uint8_t colorize, uint8_t posterize,
    uint8_t posterize_num, void (*set_dabs)(int, DP_MyPaintDab *, void *),
    int dabs_count, void *dabs_user);

DP_Message *DP_msg_draw_dabs_mypaint_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_draw_dabs_mypaint_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgDrawDabsMyPaint *DP_msg_draw_dabs_mypaint_cast(DP_Message *msg);

uint16_t DP_msg_draw_dabs_mypaint_layer(const DP_MsgDrawDabsMyPaint *mddmp);

int32_t DP_msg_draw_dabs_mypaint_x(const DP_MsgDrawDabsMyPaint *mddmp);

int32_t DP_msg_draw_dabs_mypaint_y(const DP_MsgDrawDabsMyPaint *mddmp);

uint32_t DP_msg_draw_dabs_mypaint_color(const DP_MsgDrawDabsMyPaint *mddmp);

uint8_t DP_msg_draw_dabs_mypaint_lock_alpha(const DP_MsgDrawDabsMyPaint *mddmp);

uint8_t DP_msg_draw_dabs_mypaint_colorize(const DP_MsgDrawDabsMyPaint *mddmp);

uint8_t DP_msg_draw_dabs_mypaint_posterize(const DP_MsgDrawDabsMyPaint *mddmp);

uint8_t
DP_msg_draw_dabs_mypaint_posterize_num(const DP_MsgDrawDabsMyPaint *mddmp);

const DP_MyPaintDab *
DP_msg_draw_dabs_mypaint_dabs(const DP_MsgDrawDabsMyPaint *mddmp,
                              int *out_count);

int DP_msg_draw_dabs_mypaint_dabs_count(const DP_MsgDrawDabsMyPaint *mddmp);


/*
 * DP_MSG_MOVE_RECT
 *
 * Move a rectangular area on a layer.
 *
 * A mask image can be given to mask out part of the region
 * to support non-rectangular selections.
 *
 * Source and target rects may be (partially) outside the canvas.
 */

#define DP_MSG_MOVE_RECT_STATIC_LENGTH 28

typedef struct DP_MsgMoveRect DP_MsgMoveRect;

DP_Message *DP_msg_move_rect_new(unsigned int context_id, uint16_t layer,
                                 uint16_t source, int32_t sx, int32_t sy,
                                 int32_t tx, int32_t ty, int32_t w, int32_t h,
                                 void (*set_mask)(size_t, unsigned char *,
                                                  void *),
                                 size_t mask_size, void *mask_user);

DP_Message *DP_msg_move_rect_deserialize(unsigned int context_id,
                                         const unsigned char *buffer,
                                         size_t length);

DP_Message *DP_msg_move_rect_parse(unsigned int context_id,
                                   DP_TextReader *reader);

DP_MsgMoveRect *DP_msg_move_rect_cast(DP_Message *msg);

uint16_t DP_msg_move_rect_layer(const DP_MsgMoveRect *mmr);

uint16_t DP_msg_move_rect_source(const DP_MsgMoveRect *mmr);

int32_t DP_msg_move_rect_sx(const DP_MsgMoveRect *mmr);

int32_t DP_msg_move_rect_sy(const DP_MsgMoveRect *mmr);

int32_t DP_msg_move_rect_tx(const DP_MsgMoveRect *mmr);

int32_t DP_msg_move_rect_ty(const DP_MsgMoveRect *mmr);

int32_t DP_msg_move_rect_w(const DP_MsgMoveRect *mmr);

int32_t DP_msg_move_rect_h(const DP_MsgMoveRect *mmr);

const unsigned char *DP_msg_move_rect_mask(const DP_MsgMoveRect *mmr,
                                           size_t *out_size);

size_t DP_msg_move_rect_mask_size(const DP_MsgMoveRect *mmr);


/*
 * DP_MSG_SET_METADATA_INT
 *
 * Set a document metadata field (integer type)
 *
 * These typically don't have an immediate visual effect,
 * but these fields are part of the document, like the pixel content
 * or the annotations.
 */

#define DP_MSG_SET_METADATA_INT_STATIC_LENGTH 5

#define DP_MSG_SET_METADATA_INT_FIELD_DPIX         0
#define DP_MSG_SET_METADATA_INT_FIELD_DPIY         1
#define DP_MSG_SET_METADATA_INT_FIELD_FRAMERATE    2
#define DP_MSG_SET_METADATA_INT_FIELD_USE_TIMELINE 3
#define DP_MSG_SET_METADATA_INT_FIELD_FRAME_COUNT  4

const char *DP_msg_set_metadata_int_field_variant_name(unsigned int value);

typedef struct DP_MsgSetMetadataInt DP_MsgSetMetadataInt;

DP_Message *DP_msg_set_metadata_int_new(unsigned int context_id, uint8_t field,
                                        int32_t value);

DP_Message *DP_msg_set_metadata_int_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length);

DP_Message *DP_msg_set_metadata_int_parse(unsigned int context_id,
                                          DP_TextReader *reader);

DP_MsgSetMetadataInt *DP_msg_set_metadata_int_cast(DP_Message *msg);

uint8_t DP_msg_set_metadata_int_field(const DP_MsgSetMetadataInt *msmi);

int32_t DP_msg_set_metadata_int_value(const DP_MsgSetMetadataInt *msmi);


/*
 * DP_MSG_LAYER_TREE_CREATE
 *
 * Create a new layer
 *
 * A session starts with zero layers, so a layer creation command is typically
 * the second command to be sent, right after setting the canvas size.
 *
 * The layer ID must be prefixed with the context ID of the user creating it.
 * This allows the client to choose the layer ID without worrying about
 * clashes. In multiuser mode the ACL filter validates the prefix for all new
 * layers.
 *
 * If the `source` field is nonzero, a copy of the source layer is made.
 * Otherwise, either a blank new bitmap or a group layer is created.
 * When copying a group, the group's layers are assigned new IDs sequentally,
 * starting from the group ID, using the group IDs user prefix.
 *
 * If the `target` field is nonzero, the newly created layer will be
 * insert above that layer or group, or into that group. If zero,
 * the layer will be added to the top of the root group.
 *
 * The following flags can be used with layer creation:
 * - GROUP: a group layer is created (ignored if `source` is set)
 * - INTO: the new layer will be added to the top to the `target` group.
 *         The target must be nonzero.
 *
 * If layer controls are locked, this command requires session operator
 * privileges.
 */

#define DP_MSG_LAYER_TREE_CREATE_STATIC_LENGTH 11

#define DP_MSG_LAYER_TREE_CREATE_FLAGS_GROUP 0x1
#define DP_MSG_LAYER_TREE_CREATE_FLAGS_INTO  0x2

const char *DP_msg_layer_tree_create_flags_flag_name(unsigned int value);

typedef struct DP_MsgLayerTreeCreate DP_MsgLayerTreeCreate;

DP_Message *DP_msg_layer_tree_create_new(unsigned int context_id, uint16_t id,
                                         uint16_t source, uint16_t target,
                                         uint32_t fill, uint8_t flags,
                                         const char *title_value,
                                         size_t title_len);

DP_Message *DP_msg_layer_tree_create_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_layer_tree_create_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgLayerTreeCreate *DP_msg_layer_tree_create_cast(DP_Message *msg);

uint16_t DP_msg_layer_tree_create_id(const DP_MsgLayerTreeCreate *mltc);

uint16_t DP_msg_layer_tree_create_source(const DP_MsgLayerTreeCreate *mltc);

uint16_t DP_msg_layer_tree_create_target(const DP_MsgLayerTreeCreate *mltc);

uint32_t DP_msg_layer_tree_create_fill(const DP_MsgLayerTreeCreate *mltc);

uint8_t DP_msg_layer_tree_create_flags(const DP_MsgLayerTreeCreate *mltc);

const char *DP_msg_layer_tree_create_title(const DP_MsgLayerTreeCreate *mltc,
                                           size_t *out_len);

size_t DP_msg_layer_tree_create_title_len(const DP_MsgLayerTreeCreate *mltc);


/*
 * DP_MSG_LAYER_TREE_ORDER
 *
 * Reorder layers
 *
 * The layer tree of the given group (0 means whole tree) will be reordered
 * according to the given order.
 * The order should describe a tree using (child count, layer ID) pairs.
 *
 * For example (indented for clarity):
 *
 *   2, 1,
 *     0, 10,
 *     0, 11,
 *   0, 2,
 *   2, 3,
 *     1, 30,
 *       0, 31
 *     0, 32
 *
 *  Each layer in the group must be listed exactly once in the new order,
 *  or the command will be rejected.
 */

#define DP_MSG_LAYER_TREE_ORDER_STATIC_LENGTH 2

typedef struct DP_MsgLayerTreeOrder DP_MsgLayerTreeOrder;

DP_Message *DP_msg_layer_tree_order_new(unsigned int context_id, uint16_t root,
                                        void (*set_layers)(int, uint16_t *,
                                                           void *),
                                        int layers_count, void *layers_user);

DP_Message *DP_msg_layer_tree_order_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length);

DP_Message *DP_msg_layer_tree_order_parse(unsigned int context_id,
                                          DP_TextReader *reader);

DP_MsgLayerTreeOrder *DP_msg_layer_tree_order_cast(DP_Message *msg);

uint16_t DP_msg_layer_tree_order_root(const DP_MsgLayerTreeOrder *mlto);

const uint16_t *DP_msg_layer_tree_order_layers(const DP_MsgLayerTreeOrder *mlto,
                                               int *out_count);

int DP_msg_layer_tree_order_layers_count(const DP_MsgLayerTreeOrder *mlto);


/*
 * DP_MSG_LAYER_TREE_DELETE
 *
 * Delete a layer
 *
 * If the merge to attribute is nonzero, the contents of the layer is merged
 * to the layer with the given ID. If the id and merge id both refer to
 * the same layer group, that group is collapsed into a layer.
 *
 * If the current layer or layer controls in general are locked, this command
 * requires session operator privileges.
 */

#define DP_MSG_LAYER_TREE_DELETE_STATIC_LENGTH 4

typedef struct DP_MsgLayerTreeDelete DP_MsgLayerTreeDelete;

DP_Message *DP_msg_layer_tree_delete_new(unsigned int context_id, uint16_t id,
                                         uint16_t merge_to);

DP_Message *DP_msg_layer_tree_delete_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_layer_tree_delete_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgLayerTreeDelete *DP_msg_layer_tree_delete_cast(DP_Message *msg);

uint16_t DP_msg_layer_tree_delete_id(const DP_MsgLayerTreeDelete *mltd);

uint16_t DP_msg_layer_tree_delete_merge_to(const DP_MsgLayerTreeDelete *mltd);


/*
 * DP_MSG_TRANSFORM_REGION
 *
 * Transform an area, optionally moving it between two layers.
 *
 * This is used to implement selection moving. It is equivalent
 * to doing two PutImages: the first to mask away the original
 * selection and the other to paste the selection to a new location.
 *
 * This command packages that into a single action that is more
 * bandwidth efficient and can be used even when PutImages in general
 * are locked, since it's not introducing any new pixels onto the canvas.
 *
 * Internally, the paint engine performs the following steps:
 * 1. Copy selected pixels to a buffer
 * 2. Erase selected pixels from the source layer
 * 3. Composite transformed buffer onto the target layer
 *
 * The pixel selection is determined by the mask bitmap. The mask
 * is DEFLATEd 8 bit alpha.
 *
 * For axis aligned rectangle selections, no bitmap is necessary.
 */

#define DP_MSG_TRANSFORM_REGION_STATIC_LENGTH 53

#define DP_MSG_TRANSFORM_REGION_MODE_NEAREST  0
#define DP_MSG_TRANSFORM_REGION_MODE_BILINEAR 1

const char *DP_msg_transform_region_mode_variant_name(unsigned int value);

typedef struct DP_MsgTransformRegion DP_MsgTransformRegion;

DP_Message *DP_msg_transform_region_new(
    unsigned int context_id, uint16_t layer, uint16_t source, int32_t bx,
    int32_t by, int32_t bw, int32_t bh, int32_t x1, int32_t y1, int32_t x2,
    int32_t y2, int32_t x3, int32_t y3, int32_t x4, int32_t y4, uint8_t mode,
    void (*set_mask)(size_t, unsigned char *, void *), size_t mask_size,
    void *mask_user);

DP_Message *DP_msg_transform_region_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length);

DP_Message *DP_msg_transform_region_parse(unsigned int context_id,
                                          DP_TextReader *reader);

DP_MsgTransformRegion *DP_msg_transform_region_cast(DP_Message *msg);

uint16_t DP_msg_transform_region_layer(const DP_MsgTransformRegion *mtr);

uint16_t DP_msg_transform_region_source(const DP_MsgTransformRegion *mtr);

int32_t DP_msg_transform_region_bx(const DP_MsgTransformRegion *mtr);

int32_t DP_msg_transform_region_by(const DP_MsgTransformRegion *mtr);

int32_t DP_msg_transform_region_bw(const DP_MsgTransformRegion *mtr);

int32_t DP_msg_transform_region_bh(const DP_MsgTransformRegion *mtr);

int32_t DP_msg_transform_region_x1(const DP_MsgTransformRegion *mtr);

int32_t DP_msg_transform_region_y1(const DP_MsgTransformRegion *mtr);

int32_t DP_msg_transform_region_x2(const DP_MsgTransformRegion *mtr);

int32_t DP_msg_transform_region_y2(const DP_MsgTransformRegion *mtr);

int32_t DP_msg_transform_region_x3(const DP_MsgTransformRegion *mtr);

int32_t DP_msg_transform_region_y3(const DP_MsgTransformRegion *mtr);

int32_t DP_msg_transform_region_x4(const DP_MsgTransformRegion *mtr);

int32_t DP_msg_transform_region_y4(const DP_MsgTransformRegion *mtr);

uint8_t DP_msg_transform_region_mode(const DP_MsgTransformRegion *mtr);

const unsigned char *
DP_msg_transform_region_mask(const DP_MsgTransformRegion *mtr,
                             size_t *out_size);

size_t DP_msg_transform_region_mask_size(const DP_MsgTransformRegion *mtr);


/*
 * DP_MSG_TRACK_CREATE
 *
 * Create a timeline track.
 *
 * The track id must be prefixed by the user's context id, like layer
 * and annotation ids. Operators are exempt from this restriction.
 */

#define DP_MSG_TRACK_CREATE_STATIC_LENGTH 6

typedef struct DP_MsgTrackCreate DP_MsgTrackCreate;

DP_Message *DP_msg_track_create_new(unsigned int context_id, uint16_t id,
                                    uint16_t insert_id, uint16_t source_id,
                                    const char *title_value, size_t title_len);

DP_Message *DP_msg_track_create_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length);

DP_Message *DP_msg_track_create_parse(unsigned int context_id,
                                      DP_TextReader *reader);

DP_MsgTrackCreate *DP_msg_track_create_cast(DP_Message *msg);

uint16_t DP_msg_track_create_id(const DP_MsgTrackCreate *mtc);

uint16_t DP_msg_track_create_insert_id(const DP_MsgTrackCreate *mtc);

uint16_t DP_msg_track_create_source_id(const DP_MsgTrackCreate *mtc);

const char *DP_msg_track_create_title(const DP_MsgTrackCreate *mtc,
                                      size_t *out_len);

size_t DP_msg_track_create_title_len(const DP_MsgTrackCreate *mtc);


/*
 * DP_MSG_TRACK_RETITLE
 *
 * Rename a timeline track.
 */

#define DP_MSG_TRACK_RETITLE_STATIC_LENGTH 2

typedef struct DP_MsgTrackRetitle DP_MsgTrackRetitle;

DP_Message *DP_msg_track_retitle_new(unsigned int context_id, uint16_t id,
                                     const char *title_value, size_t title_len);

DP_Message *DP_msg_track_retitle_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length);

DP_Message *DP_msg_track_retitle_parse(unsigned int context_id,
                                       DP_TextReader *reader);

DP_MsgTrackRetitle *DP_msg_track_retitle_cast(DP_Message *msg);

uint16_t DP_msg_track_retitle_id(const DP_MsgTrackRetitle *mtr);

const char *DP_msg_track_retitle_title(const DP_MsgTrackRetitle *mtr,
                                       size_t *out_len);

size_t DP_msg_track_retitle_title_len(const DP_MsgTrackRetitle *mtr);


/*
 * DP_MSG_TRACK_DELETE
 *
 * Delete a timeline track.
 */

#define DP_MSG_TRACK_DELETE_STATIC_LENGTH 2

typedef struct DP_MsgTrackDelete DP_MsgTrackDelete;

DP_Message *DP_msg_track_delete_new(unsigned int context_id, uint16_t id);

DP_Message *DP_msg_track_delete_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length);

DP_Message *DP_msg_track_delete_parse(unsigned int context_id,
                                      DP_TextReader *reader);

DP_MsgTrackDelete *DP_msg_track_delete_cast(DP_Message *msg);

uint16_t DP_msg_track_delete_id(const DP_MsgTrackDelete *mtd);


/*
 * DP_MSG_TRACK_ORDER
 *
 * Reorder timeline tracks.
 *
 * Works like the LayerOrder command, just for tracks: duplicates are
 * ignored and missing tracks are appended to the end.
 */

#define DP_MSG_TRACK_ORDER_STATIC_LENGTH 0

typedef struct DP_MsgTrackOrder DP_MsgTrackOrder;

DP_Message *DP_msg_track_order_new(unsigned int context_id,
                                   void (*set_tracks)(int, uint16_t *, void *),
                                   int tracks_count, void *tracks_user);

DP_Message *DP_msg_track_order_deserialize(unsigned int context_id,
                                           const unsigned char *buffer,
                                           size_t length);

DP_Message *DP_msg_track_order_parse(unsigned int context_id,
                                     DP_TextReader *reader);

DP_MsgTrackOrder *DP_msg_track_order_cast(DP_Message *msg);

const uint16_t *DP_msg_track_order_tracks(const DP_MsgTrackOrder *mto,
                                          int *out_count);

int DP_msg_track_order_tracks_count(const DP_MsgTrackOrder *mto);


/*
 * DP_MSG_KEY_FRAME_SET
 *
 * Create or modify a key frame.
 *
 * If there's no key frame at the given frame index, it will be
 * created, otherwise it will be clobbered. The layer must exist and
 * the frame index must be within the document's frame count.
 *
 * If the source is `Layer`, a new key frame will be created with
 * `source_id` as the layer id, `source_index` will be ignored. If the
 * source is `KeyFrame`, the key frame is copied from the key frame at
 * track with id `source_id` and frame index `source_index`.
 */

#define DP_MSG_KEY_FRAME_SET_STATIC_LENGTH 9

#define DP_MSG_KEY_FRAME_SET_SOURCE_LAYER     0
#define DP_MSG_KEY_FRAME_SET_SOURCE_KEY_FRAME 1

const char *DP_msg_key_frame_set_source_variant_name(unsigned int value);

typedef struct DP_MsgKeyFrameSet DP_MsgKeyFrameSet;

DP_Message *DP_msg_key_frame_set_new(unsigned int context_id, uint16_t track_id,
                                     uint16_t frame_index, uint16_t source_id,
                                     uint16_t source_index, uint8_t source);

DP_Message *DP_msg_key_frame_set_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length);

DP_Message *DP_msg_key_frame_set_parse(unsigned int context_id,
                                       DP_TextReader *reader);

DP_MsgKeyFrameSet *DP_msg_key_frame_set_cast(DP_Message *msg);

uint16_t DP_msg_key_frame_set_track_id(const DP_MsgKeyFrameSet *mkfs);

uint16_t DP_msg_key_frame_set_frame_index(const DP_MsgKeyFrameSet *mkfs);

uint16_t DP_msg_key_frame_set_source_id(const DP_MsgKeyFrameSet *mkfs);

uint16_t DP_msg_key_frame_set_source_index(const DP_MsgKeyFrameSet *mkfs);

uint8_t DP_msg_key_frame_set_source(const DP_MsgKeyFrameSet *mkfs);


/*
 * DP_MSG_KEY_FRAME_RETITLE
 *
 * Rename a key frame.
 */

#define DP_MSG_KEY_FRAME_RETITLE_STATIC_LENGTH 4

typedef struct DP_MsgKeyFrameRetitle DP_MsgKeyFrameRetitle;

DP_Message *DP_msg_key_frame_retitle_new(unsigned int context_id,
                                         uint16_t track_id,
                                         uint16_t frame_index,
                                         const char *title_value,
                                         size_t title_len);

DP_Message *DP_msg_key_frame_retitle_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_key_frame_retitle_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgKeyFrameRetitle *DP_msg_key_frame_retitle_cast(DP_Message *msg);

uint16_t DP_msg_key_frame_retitle_track_id(const DP_MsgKeyFrameRetitle *mkfr);

uint16_t
DP_msg_key_frame_retitle_frame_index(const DP_MsgKeyFrameRetitle *mkfr);

const char *DP_msg_key_frame_retitle_title(const DP_MsgKeyFrameRetitle *mkfr,
                                           size_t *out_len);

size_t DP_msg_key_frame_retitle_title_len(const DP_MsgKeyFrameRetitle *mkfr);


/*
 * DP_MSG_KEY_FRAME_LAYER_ATTRIBUTES
 *
 * Set (clobber) flags for layers inside of a key frame.
 *
 * This takes a list of (layer id, flags) pairs. If a layer appears
 * multiple times, only the first occurrence will apply. If a layer
 * doesn't exist or the flags value is 0, it will be ignored. Unknown
 * flags will be retained for forward-compatibility.
 *
 * Used flags are:
 *
 * * `0x1` hidden: hides a layer in the key frame. Children can
 *   override being hidden by setting the revealed flag on them.
 *
 * * `0x2` revealed: overrides the hidden state given by a parent
 *   group, making it visible again. Putting both hidden and revealed
 *   on the same layer cancels each other out and will act like
 *   neither is set.
 */

#define DP_MSG_KEY_FRAME_LAYER_ATTRIBUTES_STATIC_LENGTH 4

typedef struct DP_MsgKeyFrameLayerAttributes DP_MsgKeyFrameLayerAttributes;

DP_Message *DP_msg_key_frame_layer_attributes_new(
    unsigned int context_id, uint16_t track_id, uint16_t frame_index,
    void (*set_layers)(int, uint16_t *, void *), int layers_count,
    void *layers_user);

DP_Message *DP_msg_key_frame_layer_attributes_deserialize(
    unsigned int context_id, const unsigned char *buffer, size_t length);

DP_Message *DP_msg_key_frame_layer_attributes_parse(unsigned int context_id,
                                                    DP_TextReader *reader);

DP_MsgKeyFrameLayerAttributes *
DP_msg_key_frame_layer_attributes_cast(DP_Message *msg);

uint16_t DP_msg_key_frame_layer_attributes_track_id(
    const DP_MsgKeyFrameLayerAttributes *mkfla);

uint16_t DP_msg_key_frame_layer_attributes_frame_index(
    const DP_MsgKeyFrameLayerAttributes *mkfla);

const uint16_t *DP_msg_key_frame_layer_attributes_layers(
    const DP_MsgKeyFrameLayerAttributes *mkfla, int *out_count);

int DP_msg_key_frame_layer_attributes_layers_count(
    const DP_MsgKeyFrameLayerAttributes *mkfla);


/*
 * DP_MSG_KEY_FRAME_DELETE
 *
 * Delete a key frame, possibly moving it somewhere else.
 */

#define DP_MSG_KEY_FRAME_DELETE_STATIC_LENGTH 8

typedef struct DP_MsgKeyFrameDelete DP_MsgKeyFrameDelete;

DP_Message *DP_msg_key_frame_delete_new(unsigned int context_id,
                                        uint16_t track_id, uint16_t frame_index,
                                        uint16_t move_track_id,
                                        uint16_t move_frame_index);

DP_Message *DP_msg_key_frame_delete_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length);

DP_Message *DP_msg_key_frame_delete_parse(unsigned int context_id,
                                          DP_TextReader *reader);

DP_MsgKeyFrameDelete *DP_msg_key_frame_delete_cast(DP_Message *msg);

uint16_t DP_msg_key_frame_delete_track_id(const DP_MsgKeyFrameDelete *mkfd);

uint16_t DP_msg_key_frame_delete_frame_index(const DP_MsgKeyFrameDelete *mkfd);

uint16_t
DP_msg_key_frame_delete_move_track_id(const DP_MsgKeyFrameDelete *mkfd);

uint16_t
DP_msg_key_frame_delete_move_frame_index(const DP_MsgKeyFrameDelete *mkfd);


/*
 * DP_MSG_UNDO
 *
 * Undo or redo actions
 */

#define DP_MSG_UNDO_STATIC_LENGTH 2

typedef struct DP_MsgUndo DP_MsgUndo;

DP_Message *DP_msg_undo_new(unsigned int context_id, uint8_t override_user,
                            bool redo);

DP_Message *DP_msg_undo_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length);

DP_Message *DP_msg_undo_parse(unsigned int context_id, DP_TextReader *reader);

DP_MsgUndo *DP_msg_undo_cast(DP_Message *msg);

uint8_t DP_msg_undo_override_user(const DP_MsgUndo *mu);

bool DP_msg_undo_redo(const DP_MsgUndo *mu);


#endif
