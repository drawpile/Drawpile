/*
 * Copyright (C) 2022 askmeaboutloom
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * --------------------------------------------------------------------
 *
 * This code is auto-generated by generators/protogen/protogen_drawdance.py
 * from generators/protogen/messages.h.jinja. Don't edit it directly.
 */
#ifndef DPMSG_MESSAGES_H
#define DPMSG_MESSAGES_H
#include <dpcommon/common.h>

typedef struct DP_Message DP_Message;
typedef struct DP_TextReader DP_TextReader;
typedef struct DP_TextWriter DP_TextWriter;

#define DP_PROTOCOL_VERSION_NAMESPACE "dp"
#define DP_PROTOCOL_VERSION_SERVER    4
#define DP_PROTOCOL_VERSION_MAJOR     23
#define DP_PROTOCOL_VERSION_MINOR     0
#define DP_PROTOCOL_VERSION           "dp:4.23.0"
#define DP_UNDO_DEPTH                 30

typedef struct DP_MessageMethods {
    size_t (*payload_length)(DP_Message *msg);
    size_t (*serialize_payload)(DP_Message *msg, unsigned char *data);
    bool (*write_payload_text)(DP_Message *msg, DP_TextWriter *writer);
    bool (*equals)(DP_Message *DP_RESTRICT msg, DP_Message *DP_RESTRICT other);
} DP_MessageMethods;

typedef enum DP_MessageType {
    DP_MSG_SERVER_COMMAND = 0,
    DP_MSG_DISCONNECT = 1,
    DP_MSG_PING = 2,
    DP_MSG_INTERNAL = 31,
    DP_MSG_JOIN = 32,
    DP_MSG_LEAVE = 33,
    DP_MSG_SESSION_OWNER = 34,
    DP_MSG_CHAT = 35,
    DP_MSG_TRUSTED_USERS = 36,
    DP_MSG_SOFT_RESET = 37,
    DP_MSG_PRIVATE_CHAT = 38,
    DP_MSG_INTERVAL = 64,
    DP_MSG_LASER_TRAIL = 65,
    DP_MSG_MOVE_POINTER = 66,
    DP_MSG_MARKER = 67,
    DP_MSG_USER_ACL = 68,
    DP_MSG_LAYER_ACL = 69,
    DP_MSG_FEATURE_ACCESS_LEVELS = 70,
    DP_MSG_DEFAULT_LAYER = 71,
    DP_MSG_FILTERED = 72,
    DP_MSG_EXTENSION = 73,
    DP_MSG_UNDO_POINT = 128,
    DP_MSG_CANVAS_RESIZE = 129,
    DP_MSG_LAYER_CREATE = 130,
    DP_MSG_LAYER_ATTRIBUTES = 131,
    DP_MSG_LAYER_RETITLE = 132,
    DP_MSG_LAYER_ORDER = 133,
    DP_MSG_LAYER_DELETE = 134,
    DP_MSG_LAYER_VISIBILITY = 135,
    DP_MSG_PUT_IMAGE = 136,
    DP_MSG_FILL_RECT = 137,
    DP_MSG_TOOL_CHANGE = 138,
    DP_MSG_PEN_MOVE = 139,
    DP_MSG_PEN_UP = 140,
    DP_MSG_ANNOTATION_CREATE = 141,
    DP_MSG_ANNOTATION_RESHAPE = 142,
    DP_MSG_ANNOTATION_EDIT = 143,
    DP_MSG_ANNOTATION_DELETE = 144,
    DP_MSG_MOVE_REGION = 145,
    DP_MSG_PUT_TILE = 146,
    DP_MSG_CANVAS_BACKGROUND = 147,
    DP_MSG_DRAW_DABS_CLASSIC = 148,
    DP_MSG_DRAW_DABS_PIXEL = 149,
    DP_MSG_DRAW_DABS_PIXEL_SQUARE = 150,
    DP_MSG_DRAW_DABS_MYPAINT = 151,
    DP_MSG_MOVE_RECT = 160,
    DP_MSG_SET_METADATA_INT = 161,
    DP_MSG_SET_METADATA_STR = 162,
    DP_MSG_SET_TIMELINE_FRAME = 163,
    DP_MSG_REMOVE_TIMELINE_FRAME = 164,
    DP_MSG_UNDO = 255,
    DP_MSG_TYPE_COUNT,
} DP_MessageType;

bool DP_message_type_control(DP_MessageType type);

bool DP_message_type_client_meta(DP_MessageType type);

bool DP_message_type_server_meta(DP_MessageType type);

bool DP_message_type_command(DP_MessageType type);

const char *DP_message_type_name(DP_MessageType type);

const char *DP_message_type_enum_name(DP_MessageType type);

const char *DP_message_type_enum_name_unprefixed(DP_MessageType type);

DP_MessageType DP_message_type_from_name(const char *type_name,
                                         DP_MessageType not_found_value);

// Returns if the given type's text format has a body of value tuples, rather
// than a body of multiline fields. This is the case for draw dabs messages.
bool DP_message_type_parse_multiline_tuples(DP_MessageType type);


DP_Message *DP_message_deserialize_body(int type, unsigned int context_id,
                                        const unsigned char *buf,
                                        size_t length);

DP_Message *DP_message_parse_body(DP_MessageType type, unsigned int context_id,
                                  DP_TextReader *reader);


/*
 * DP_MSG_SERVER_COMMAND
 *
 * Server command message
 *
 * This is a general purpose message for sending commands to the server
 * and receiving replies. This is used for (among other things):
 *
 * - the login handshake
 * - setting session parameters (e.g. max user count and password)
 * - sending administration commands (e.g. kick user)
 */

typedef struct DP_MsgServerCommand DP_MsgServerCommand;

DP_Message *DP_msg_server_command_new(unsigned int context_id,
                                      const char *msg_value, size_t msg_len);

DP_Message *DP_msg_server_command_deserialize(unsigned int context_id,
                                              const unsigned char *buffer,
                                              size_t length);

DP_Message *DP_msg_server_command_parse(unsigned int context_id,
                                        DP_TextReader *reader);

DP_MsgServerCommand *DP_msg_server_command_cast(DP_Message *msg);

const char *DP_msg_server_command_msg(const DP_MsgServerCommand *msc,
                                      size_t *out_len);

size_t DP_msg_server_command_msg_len(const DP_MsgServerCommand *msc);


/*
 * DP_MSG_DISCONNECT
 *
 * Disconnect notification
 *
 * This message is used when closing the connection gracefully. The message
 * queue will automatically close the socket after sending this message.
 */

#define DP_MSG_DISCONNECT_REASON_ERROR    0
#define DP_MSG_DISCONNECT_REASON_KICK     1
#define DP_MSG_DISCONNECT_REASON_SHUTDOWN 2
#define DP_MSG_DISCONNECT_REASON_OTHER    3

const char *DP_msg_disconnect_reason_variant_name(unsigned int value);

typedef struct DP_MsgDisconnect DP_MsgDisconnect;

DP_Message *DP_msg_disconnect_new(unsigned int context_id, uint8_t reason,
                                  const char *message_value,
                                  size_t message_len);

DP_Message *DP_msg_disconnect_deserialize(unsigned int context_id,
                                          const unsigned char *buffer,
                                          size_t length);

DP_Message *DP_msg_disconnect_parse(unsigned int context_id,
                                    DP_TextReader *reader);

DP_MsgDisconnect *DP_msg_disconnect_cast(DP_Message *msg);

uint8_t DP_msg_disconnect_reason(const DP_MsgDisconnect *md);

const char *DP_msg_disconnect_message(const DP_MsgDisconnect *md,
                                      size_t *out_len);

size_t DP_msg_disconnect_message_len(const DP_MsgDisconnect *md);


/*
 * DP_MSG_PING
 *
 * Ping message
 *
 * This is used for latency measurement as well as a keepalive. Normally, the
 * client should be the one to send the ping messages.
 *
 * The server should return a Ping with the is_pong flag set
 */

typedef struct DP_MsgPing DP_MsgPing;

DP_Message *DP_msg_ping_new(unsigned int context_id, bool is_pong);

DP_Message *DP_msg_ping_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length);

DP_Message *DP_msg_ping_parse(unsigned int context_id, DP_TextReader *reader);

DP_MsgPing *DP_msg_ping_cast(DP_Message *msg);

bool DP_msg_ping_is_pong(const DP_MsgPing *mp);


/*
 * DP_MSG_INTERNAL
 *
 * Reserved for internal use
 */


/*
 * DP_MSG_JOIN
 *
 * Inform the client of a new user
 *
 * This message is sent only be the server. It associates a username
 * with a context ID.
 */

#define DP_MSG_JOIN_FLAGS_AUTH 0x1
#define DP_MSG_JOIN_FLAGS_MOD  0x2
#define DP_MSG_JOIN_FLAGS_BOT  0x4

const char *DP_msg_join_flags_flag_name(unsigned int value);

typedef struct DP_MsgJoin DP_MsgJoin;

DP_Message *DP_msg_join_new(unsigned int context_id, uint8_t flags,
                            const char *name_value, size_t name_len,
                            void (*set_avatar)(size_t, unsigned char *, void *),
                            size_t avatar_size, void *avatar_user);

DP_Message *DP_msg_join_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length);

DP_Message *DP_msg_join_parse(unsigned int context_id, DP_TextReader *reader);

DP_MsgJoin *DP_msg_join_cast(DP_Message *msg);

uint8_t DP_msg_join_flags(const DP_MsgJoin *mj);

const char *DP_msg_join_name(const DP_MsgJoin *mj, size_t *out_len);

size_t DP_msg_join_name_len(const DP_MsgJoin *mj);

const unsigned char *DP_msg_join_avatar(const DP_MsgJoin *mj, size_t *out_size);

size_t DP_msg_join_avatar_size(const DP_MsgJoin *mj);


/*
 * DP_MSG_LEAVE
 *
 * Inform the client of a user leaving
 *
 * This message is sent only by the server. Upon receiving this message,
 * clients will typically remove the user from the user listing. The client
 * is also allowed to release resources associated with this context ID.
 */

DP_Message *DP_msg_leave_new(unsigned int context_id);

DP_Message *DP_msg_leave_deserialize(unsigned int context_id,
                                     const unsigned char *buffer,
                                     size_t length);

DP_Message *DP_msg_leave_parse(unsigned int context_id, DP_TextReader *reader);


/*
 * DP_MSG_SESSION_OWNER
 *
 * Session ownership change
 *
 * This message sets the users who have operator status. It can be
 * sent by users who are already operators or by the server (user id=0).
 *
 * The list of operators implicitly contains the user who sends the
 * message, thus users cannot deop themselves.
 *
 * The server sanitizes the ID list so, when distributed to other users,
 * it does not contain any duplicates or non-existing users and can be trusted
 * without checking the access control list.
 */

typedef struct DP_MsgSessionOwner DP_MsgSessionOwner;

DP_Message *DP_msg_session_owner_new(unsigned int context_id,
                                     void (*set_users)(int, uint8_t *, void *),
                                     int users_count, void *users_user);

DP_Message *DP_msg_session_owner_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length);

DP_Message *DP_msg_session_owner_parse(unsigned int context_id,
                                       DP_TextReader *reader);

DP_MsgSessionOwner *DP_msg_session_owner_cast(DP_Message *msg);

const uint8_t *DP_msg_session_owner_users(const DP_MsgSessionOwner *mso,
                                          int *out_count);

int DP_msg_session_owner_users_count(const DP_MsgSessionOwner *mso);


/*
 * DP_MSG_CHAT
 *
 * A chat message
 *
 * Chat message sent by the server with the user ID 0 are server messages.
 * (Typically a Command message is used for server announcements, but the Chat
 * message is used for those messages that must be stored in the session
 * history.)
 */

#define DP_MSG_CHAT_TFLAGS_BYPASS 0x1

const char *DP_msg_chat_tflags_flag_name(unsigned int value);

#define DP_MSG_CHAT_OFLAGS_SHOUT  0x1
#define DP_MSG_CHAT_OFLAGS_ACTION 0x2
#define DP_MSG_CHAT_OFLAGS_PIN    0x4
#define DP_MSG_CHAT_OFLAGS_ALERT  0x8

const char *DP_msg_chat_oflags_flag_name(unsigned int value);

typedef struct DP_MsgChat DP_MsgChat;

DP_Message *DP_msg_chat_new(unsigned int context_id, uint8_t tflags,
                            uint8_t oflags, const char *message_value,
                            size_t message_len);

DP_Message *DP_msg_chat_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length);

DP_Message *DP_msg_chat_parse(unsigned int context_id, DP_TextReader *reader);

DP_MsgChat *DP_msg_chat_cast(DP_Message *msg);

uint8_t DP_msg_chat_tflags(const DP_MsgChat *mc);

uint8_t DP_msg_chat_oflags(const DP_MsgChat *mc);

const char *DP_msg_chat_message(const DP_MsgChat *mc, size_t *out_len);

size_t DP_msg_chat_message_len(const DP_MsgChat *mc);


/*
 * DP_MSG_TRUSTED_USERS
 *
 * List of trusted users
 *
 * This message sets the list of user who have been tagged as trusted,
 * but who are not operators. The meaning of "trusted" is a mostly
 * clientside concept, but the session can be configured to allow trusted
 * users access to some operator commands. (Deputies)
 *
 * This command can be sent by operators or by the server (ctx=0).
 *
 * The server sanitizes the ID list so, when distributed to other users,
 * it does not contain any duplicates or non-existing users and can be trusted
 * without checking the access control list.
 */

typedef struct DP_MsgTrustedUsers DP_MsgTrustedUsers;

DP_Message *DP_msg_trusted_users_new(unsigned int context_id,
                                     void (*set_users)(int, uint8_t *, void *),
                                     int users_count, void *users_user);

DP_Message *DP_msg_trusted_users_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length);

DP_Message *DP_msg_trusted_users_parse(unsigned int context_id,
                                       DP_TextReader *reader);

DP_MsgTrustedUsers *DP_msg_trusted_users_cast(DP_Message *msg);

const uint8_t *DP_msg_trusted_users_users(const DP_MsgTrustedUsers *mtu,
                                          int *out_count);

int DP_msg_trusted_users_users_count(const DP_MsgTrustedUsers *mtu);


/*
 * DP_MSG_SOFT_RESET
 *
 * Soft reset point marker
 *
 * This message marks the point in the session history where a soft reset
 * occurs. A thick-server performs an internal soft-reset when a user joins.
 *
 * All users should truncate their own session history when receiving this
 * message, since undos cannot cross the reset boundary.
 */

DP_Message *DP_msg_soft_reset_new(unsigned int context_id);

DP_Message *DP_msg_soft_reset_deserialize(unsigned int context_id,
                                          const unsigned char *buffer,
                                          size_t length);

DP_Message *DP_msg_soft_reset_parse(unsigned int context_id,
                                    DP_TextReader *reader);


/*
 * DP_MSG_PRIVATE_CHAT
 *
 * A private chat message
 *
 * Note. This message type was added in protocol 4.21.2 (v. 2.1.0). For backward
 * compatiblity, the server will not send any private messages from itself; it
 * will only relay them from other users. In version 3.0, this should be merged
 * with the normal Chat message.
 *
 * Private messages always bypass the session history.
 */

typedef struct DP_MsgPrivateChat DP_MsgPrivateChat;

DP_Message *DP_msg_private_chat_new(unsigned int context_id, uint8_t target,
                                    uint8_t oflags, const char *message_value,
                                    size_t message_len);

DP_Message *DP_msg_private_chat_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length);

DP_Message *DP_msg_private_chat_parse(unsigned int context_id,
                                      DP_TextReader *reader);

DP_MsgPrivateChat *DP_msg_private_chat_cast(DP_Message *msg);

uint8_t DP_msg_private_chat_target(const DP_MsgPrivateChat *mpc);

uint8_t DP_msg_private_chat_oflags(const DP_MsgPrivateChat *mpc);

const char *DP_msg_private_chat_message(const DP_MsgPrivateChat *mpc,
                                        size_t *out_len);

size_t DP_msg_private_chat_message_len(const DP_MsgPrivateChat *mpc);


/*
 * DP_MSG_INTERVAL
 *
 * Event interval record
 *
 * This is used to preserve timing information in session recordings.
 *
 * Note. The maximum interval (using a single message) is about 65 seconds.
 * Typically the intervals we want to store are a few seconds at most, so this
 * should be enough.
 */

typedef struct DP_MsgInterval DP_MsgInterval;

DP_Message *DP_msg_interval_new(unsigned int context_id, uint16_t msecs);

DP_Message *DP_msg_interval_deserialize(unsigned int context_id,
                                        const unsigned char *buffer,
                                        size_t length);

DP_Message *DP_msg_interval_parse(unsigned int context_id,
                                  DP_TextReader *reader);

DP_MsgInterval *DP_msg_interval_cast(DP_Message *msg);

uint16_t DP_msg_interval_msecs(const DP_MsgInterval *mi);


/*
 * DP_MSG_LASER_TRAIL
 *
 * Start/end drawing pointer laser trail
 *
 * This signals the beginning or the end of a laser pointer trail. The trail
 * coordinates are sent with MovePointer messages.
 *
 * A nonzero persistence indicates the start of the trail and zero the end.
 */

typedef struct DP_MsgLaserTrail DP_MsgLaserTrail;

DP_Message *DP_msg_laser_trail_new(unsigned int context_id, uint32_t color,
                                   uint8_t persistence);

DP_Message *DP_msg_laser_trail_deserialize(unsigned int context_id,
                                           const unsigned char *buffer,
                                           size_t length);

DP_Message *DP_msg_laser_trail_parse(unsigned int context_id,
                                     DP_TextReader *reader);

DP_MsgLaserTrail *DP_msg_laser_trail_cast(DP_Message *msg);

uint32_t DP_msg_laser_trail_color(const DP_MsgLaserTrail *mlt);

uint8_t DP_msg_laser_trail_persistence(const DP_MsgLaserTrail *mlt);


/*
 * DP_MSG_MOVE_POINTER
 *
 * Move user pointer
 *
 * This is message is used to update the position of the user pointer when no
 * actual drawing is taking place. It is also used to draw the "laser pointer"
 * trail. Note. This is a META message, since this is used for a temporary
 * visual effect only, and thus doesn't affect the actual canvas content.
 *
 * The pointer position is given in integer coordinates.
 */

typedef struct DP_MsgMovePointer DP_MsgMovePointer;

DP_Message *DP_msg_move_pointer_new(unsigned int context_id, int32_t x,
                                    int32_t y);

DP_Message *DP_msg_move_pointer_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length);

DP_Message *DP_msg_move_pointer_parse(unsigned int context_id,
                                      DP_TextReader *reader);

DP_MsgMovePointer *DP_msg_move_pointer_cast(DP_Message *msg);

int32_t DP_msg_move_pointer_x(const DP_MsgMovePointer *mmp);

int32_t DP_msg_move_pointer_y(const DP_MsgMovePointer *mmp);


/*
 * DP_MSG_MARKER
 *
 * A bookmark
 *
 * This is used to bookmark points in the session for quick access when playing
 * back a recording
 */

typedef struct DP_MsgMarker DP_MsgMarker;

DP_Message *DP_msg_marker_new(unsigned int context_id, const char *text_value,
                              size_t text_len);

DP_Message *DP_msg_marker_deserialize(unsigned int context_id,
                                      const unsigned char *buffer,
                                      size_t length);

DP_Message *DP_msg_marker_parse(unsigned int context_id, DP_TextReader *reader);

DP_MsgMarker *DP_msg_marker_cast(DP_Message *msg);

const char *DP_msg_marker_text(const DP_MsgMarker *mm, size_t *out_len);

size_t DP_msg_marker_text_len(const DP_MsgMarker *mm);


/*
 * DP_MSG_USER_ACL
 *
 * Set user specific locks
 *
 * This is an opaque meta command that contains a list of users to be locked.
 * It can only be sent by session operators.
 */

typedef struct DP_MsgUserAcl DP_MsgUserAcl;

DP_Message *DP_msg_user_acl_new(unsigned int context_id,
                                void (*set_users)(int, uint8_t *, void *),
                                int users_count, void *users_user);

DP_Message *DP_msg_user_acl_deserialize(unsigned int context_id,
                                        const unsigned char *buffer,
                                        size_t length);

DP_Message *DP_msg_user_acl_parse(unsigned int context_id,
                                  DP_TextReader *reader);

DP_MsgUserAcl *DP_msg_user_acl_cast(DP_Message *msg);

const uint8_t *DP_msg_user_acl_users(const DP_MsgUserAcl *mua, int *out_count);

int DP_msg_user_acl_users_count(const DP_MsgUserAcl *mua);


/*
 * DP_MSG_LAYER_ACL
 *
 * Change layer access control list
 *
 * This is an opaque meta command. It is used to set the general layer lock
 * as well as give exclusive access to selected users.
 *
 * When the OWNLAYERS mode is set, any user can use this to change the ACLs on
 * layers they themselves have created (identified by the ID prefix.)
 *
 * Using layer ID 0 sets or clears a general canvaswide lock. The tier and
 * exclusive user list is not used in this case.
 *
 * The eighth bit of the flags field (0x80) indicates whether the layer is
 * locked in general. The first three bits (0x07) indicate the access tier
 * level.
 */

typedef struct DP_MsgLayerAcl DP_MsgLayerAcl;

DP_Message *DP_msg_layer_acl_new(unsigned int context_id, uint16_t id,
                                 uint8_t flags,
                                 void (*set_exclusive)(int, uint8_t *, void *),
                                 int exclusive_count, void *exclusive_user);

DP_Message *DP_msg_layer_acl_deserialize(unsigned int context_id,
                                         const unsigned char *buffer,
                                         size_t length);

DP_Message *DP_msg_layer_acl_parse(unsigned int context_id,
                                   DP_TextReader *reader);

DP_MsgLayerAcl *DP_msg_layer_acl_cast(DP_Message *msg);

uint16_t DP_msg_layer_acl_id(const DP_MsgLayerAcl *mla);

uint8_t DP_msg_layer_acl_flags(const DP_MsgLayerAcl *mla);

const uint8_t *DP_msg_layer_acl_exclusive(const DP_MsgLayerAcl *mla,
                                          int *out_count);

int DP_msg_layer_acl_exclusive_count(const DP_MsgLayerAcl *mla);


/*
 * DP_MSG_FEATURE_ACCESS_LEVELS
 *
 * Change feature access tiers
 */

typedef struct DP_MsgFeatureAccessLevels DP_MsgFeatureAccessLevels;

DP_Message *DP_msg_feature_access_levels_new(
    unsigned int context_id, void (*set_feature_tiers)(int, uint8_t *, void *),
    int feature_tiers_count, void *feature_tiers_user);

DP_Message *DP_msg_feature_access_levels_deserialize(
    unsigned int context_id, const unsigned char *buffer, size_t length);

DP_Message *DP_msg_feature_access_levels_parse(unsigned int context_id,
                                               DP_TextReader *reader);

DP_MsgFeatureAccessLevels *DP_msg_feature_access_levels_cast(DP_Message *msg);

const uint8_t *DP_msg_feature_access_levels_feature_tiers(
    const DP_MsgFeatureAccessLevels *mfal, int *out_count);

int DP_msg_feature_access_levels_feature_tiers_count(
    const DP_MsgFeatureAccessLevels *mfal);


/*
 * DP_MSG_DEFAULT_LAYER
 *
 * Set the default layer
 *
 * The default layer is the one new users default to when logging in.
 * If no default layer is set, the newest layer will be selected by default.
 */

typedef struct DP_MsgDefaultLayer DP_MsgDefaultLayer;

DP_Message *DP_msg_default_layer_new(unsigned int context_id, uint16_t id);

DP_Message *DP_msg_default_layer_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length);

DP_Message *DP_msg_default_layer_parse(unsigned int context_id,
                                       DP_TextReader *reader);

DP_MsgDefaultLayer *DP_msg_default_layer_cast(DP_Message *msg);

uint16_t DP_msg_default_layer_id(const DP_MsgDefaultLayer *mdl);


/*
 * DP_MSG_FILTERED
 *
 * A message that has been filtered away by the ACL filter
 *
 * This is only used in recordings for mainly debugging purposes.
 * This message should never be sent over the network.
 */

typedef struct DP_MsgFiltered DP_MsgFiltered;

DP_Message *DP_msg_filtered_new(unsigned int context_id,
                                void (*set_message)(size_t, unsigned char *,
                                                    void *),
                                size_t message_size, void *message_user);

DP_Message *DP_msg_filtered_deserialize(unsigned int context_id,
                                        const unsigned char *buffer,
                                        size_t length);

DP_Message *DP_msg_filtered_parse(unsigned int context_id,
                                  DP_TextReader *reader);

DP_MsgFiltered *DP_msg_filtered_cast(DP_Message *msg);

const unsigned char *DP_msg_filtered_message(const DP_MsgFiltered *mf,
                                             size_t *out_size);

size_t DP_msg_filtered_message_size(const DP_MsgFiltered *mf);


/*
 * DP_MSG_EXTENSION
 *
 * Reserved for non-standard extension use
 */


/*
 * DP_MSG_UNDO_POINT
 *
 * Undo demarcation point
 *
 * The client sends an UndoPoint message to signal the start of an undoable
 * sequence.
 */

DP_Message *DP_msg_undo_point_new(unsigned int context_id);

DP_Message *DP_msg_undo_point_deserialize(unsigned int context_id,
                                          const unsigned char *buffer,
                                          size_t length);

DP_Message *DP_msg_undo_point_parse(unsigned int context_id,
                                    DP_TextReader *reader);


/*
 * DP_MSG_CANVAS_RESIZE
 *
 * Adjust canvas size
 *
 * This is the first command that must be sent to initialize the session.
 *
 * This affects the size of all existing and future layers.
 *
 * The new canvas size is relative to the old one. The four adjustement
 * parameters extend or retract their respective borders.
 * Initial canvas resize should be (0, w, h, 0).
 */

typedef struct DP_MsgCanvasResize DP_MsgCanvasResize;

DP_Message *DP_msg_canvas_resize_new(unsigned int context_id, int32_t top,
                                     int32_t right, int32_t bottom,
                                     int32_t left);

DP_Message *DP_msg_canvas_resize_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length);

DP_Message *DP_msg_canvas_resize_parse(unsigned int context_id,
                                       DP_TextReader *reader);

DP_MsgCanvasResize *DP_msg_canvas_resize_cast(DP_Message *msg);

int32_t DP_msg_canvas_resize_top(const DP_MsgCanvasResize *mcr);

int32_t DP_msg_canvas_resize_right(const DP_MsgCanvasResize *mcr);

int32_t DP_msg_canvas_resize_bottom(const DP_MsgCanvasResize *mcr);

int32_t DP_msg_canvas_resize_left(const DP_MsgCanvasResize *mcr);


/*
 * DP_MSG_LAYER_CREATE
 *
 * Create a new layer
 *
 * A session starts with zero layers, so a layer creation command is typically
 * the second command to be sent, right after setting the canvas size.
 *
 * The layer ID must be prefixed with the context ID of the user creating it.
 * This allows the client to choose the layer ID without worrying about
 * clashes. In multiuser mode the ACL filter validates the prefix for all new
 * layers.
 *
 * If the `source` field is nonzero, a copy of the source layer is made.
 * Otherwise, either a blank new bitmap or a group layer is created.
 * When copying a group, the group's layers are assigned new IDs sequentally,
 * starting from the group ID, using the group IDs user prefix.
 *
 * If the `target` field is nonzero, the newly created layer will be
 * insert above that layer or group, or into that group. If zero,
 * the layer will be added to the top of the root group.
 *
 * The following flags can be used with layer creation:
 * - GROUP: a group layer is created (ignored if `source` is set)
 * - INTO: the new layer will be added to the top to the `target` group.
 *         The target must be nonzero.
 *
 * If layer controls are locked, this command requires session operator
 * privileges.
 */

#define DP_MSG_LAYER_CREATE_FLAGS_GROUP 0x1
#define DP_MSG_LAYER_CREATE_FLAGS_INTO  0x2

const char *DP_msg_layer_create_flags_flag_name(unsigned int value);

typedef struct DP_MsgLayerCreate DP_MsgLayerCreate;

DP_Message *DP_msg_layer_create_new(unsigned int context_id, uint16_t id,
                                    uint16_t source, uint16_t target,
                                    uint32_t fill, uint8_t flags,
                                    const char *name_value, size_t name_len);

DP_Message *DP_msg_layer_create_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length);

DP_Message *DP_msg_layer_create_parse(unsigned int context_id,
                                      DP_TextReader *reader);

DP_MsgLayerCreate *DP_msg_layer_create_cast(DP_Message *msg);

uint16_t DP_msg_layer_create_id(const DP_MsgLayerCreate *mlc);

uint16_t DP_msg_layer_create_source(const DP_MsgLayerCreate *mlc);

uint16_t DP_msg_layer_create_target(const DP_MsgLayerCreate *mlc);

uint32_t DP_msg_layer_create_fill(const DP_MsgLayerCreate *mlc);

uint8_t DP_msg_layer_create_flags(const DP_MsgLayerCreate *mlc);

const char *DP_msg_layer_create_name(const DP_MsgLayerCreate *mlc,
                                     size_t *out_len);

size_t DP_msg_layer_create_name_len(const DP_MsgLayerCreate *mlc);


/*
 * DP_MSG_LAYER_ATTRIBUTES
 *
 * Change layer attributes
 *
 * If the target layer is locked, this command requires session operator
 * privileges.
 *
 * Specifying a sublayer requires session operator privileges. Currently, it is
 * used only when sublayers are needed at canvas initialization.
 *
 * Note: the `fixed` flag is unused since version 2.2. It's functionality is
 * replaced by the custom timeline feature.
 */

#define DP_MSG_LAYER_ATTRIBUTES_FLAGS_CENSOR   0x1
#define DP_MSG_LAYER_ATTRIBUTES_FLAGS_FIXED    0x2
#define DP_MSG_LAYER_ATTRIBUTES_FLAGS_ISOLATED 0x4

const char *DP_msg_layer_attributes_flags_flag_name(unsigned int value);

typedef struct DP_MsgLayerAttributes DP_MsgLayerAttributes;

DP_Message *DP_msg_layer_attributes_new(unsigned int context_id, uint16_t id,
                                        uint8_t sublayer, uint8_t flags,
                                        uint8_t opacity, uint8_t blend);

DP_Message *DP_msg_layer_attributes_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length);

DP_Message *DP_msg_layer_attributes_parse(unsigned int context_id,
                                          DP_TextReader *reader);

DP_MsgLayerAttributes *DP_msg_layer_attributes_cast(DP_Message *msg);

uint16_t DP_msg_layer_attributes_id(const DP_MsgLayerAttributes *mla);

uint8_t DP_msg_layer_attributes_sublayer(const DP_MsgLayerAttributes *mla);

uint8_t DP_msg_layer_attributes_flags(const DP_MsgLayerAttributes *mla);

uint8_t DP_msg_layer_attributes_opacity(const DP_MsgLayerAttributes *mla);

uint8_t DP_msg_layer_attributes_blend(const DP_MsgLayerAttributes *mla);


/*
 * DP_MSG_LAYER_RETITLE
 *
 * Change a layer's title
 */

typedef struct DP_MsgLayerRetitle DP_MsgLayerRetitle;

DP_Message *DP_msg_layer_retitle_new(unsigned int context_id, uint16_t id,
                                     const char *title_value, size_t title_len);

DP_Message *DP_msg_layer_retitle_deserialize(unsigned int context_id,
                                             const unsigned char *buffer,
                                             size_t length);

DP_Message *DP_msg_layer_retitle_parse(unsigned int context_id,
                                       DP_TextReader *reader);

DP_MsgLayerRetitle *DP_msg_layer_retitle_cast(DP_Message *msg);

uint16_t DP_msg_layer_retitle_id(const DP_MsgLayerRetitle *mlr);

const char *DP_msg_layer_retitle_title(const DP_MsgLayerRetitle *mlr,
                                       size_t *out_len);

size_t DP_msg_layer_retitle_title_len(const DP_MsgLayerRetitle *mlr);


/*
 * DP_MSG_LAYER_ORDER
 *
 * Reorder layers
 *
 * The layer tree of the given group (0 means whole tree) will be reordered
 * according to the given order.
 * The order should describe a tree using (child count, layer ID) pairs.
 *
 * For example (indented for clarity):
 *
 *   2, 1,
 *     0, 10,
 *     0, 11,
 *   0, 2,
 *   2, 3,
 *     1, 30,
 *       0, 31
 *     0, 32
 *
 *  Each layer in the group must be listed exactly once in the new order,
 *  or the command will be rejected.
 */

typedef struct DP_MsgLayerOrder DP_MsgLayerOrder;

DP_Message *DP_msg_layer_order_new(unsigned int context_id, uint16_t root,
                                   void (*set_layers)(int, uint16_t *, void *),
                                   int layers_count, void *layers_user);

DP_Message *DP_msg_layer_order_deserialize(unsigned int context_id,
                                           const unsigned char *buffer,
                                           size_t length);

DP_Message *DP_msg_layer_order_parse(unsigned int context_id,
                                     DP_TextReader *reader);

DP_MsgLayerOrder *DP_msg_layer_order_cast(DP_Message *msg);

uint16_t DP_msg_layer_order_root(const DP_MsgLayerOrder *mlo);

const uint16_t *DP_msg_layer_order_layers(const DP_MsgLayerOrder *mlo,
                                          int *out_count);

int DP_msg_layer_order_layers_count(const DP_MsgLayerOrder *mlo);


/*
 * DP_MSG_LAYER_DELETE
 *
 * Delete a layer
 *
 * If the merge attribute is nonzero, the contents of the layer is merged
 * to the layer with the given ID.
 *
 * If the current layer or layer controls in general are locked, this command
 * requires session operator privileges.
 */

typedef struct DP_MsgLayerDelete DP_MsgLayerDelete;

DP_Message *DP_msg_layer_delete_new(unsigned int context_id, uint16_t id,
                                    uint16_t merge_to);

DP_Message *DP_msg_layer_delete_deserialize(unsigned int context_id,
                                            const unsigned char *buffer,
                                            size_t length);

DP_Message *DP_msg_layer_delete_parse(unsigned int context_id,
                                      DP_TextReader *reader);

DP_MsgLayerDelete *DP_msg_layer_delete_cast(DP_Message *msg);

uint16_t DP_msg_layer_delete_id(const DP_MsgLayerDelete *mld);

uint16_t DP_msg_layer_delete_merge_to(const DP_MsgLayerDelete *mld);


/*
 * DP_MSG_LAYER_VISIBILITY
 *
 * Toggle layer local visibility (this is used internally only and never sent
 * over the network)
 */

typedef struct DP_MsgLayerVisibility DP_MsgLayerVisibility;

DP_Message *DP_msg_layer_visibility_new(unsigned int context_id, uint16_t id,
                                        bool visible);

DP_Message *DP_msg_layer_visibility_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length);

DP_Message *DP_msg_layer_visibility_parse(unsigned int context_id,
                                          DP_TextReader *reader);

DP_MsgLayerVisibility *DP_msg_layer_visibility_cast(DP_Message *msg);

uint16_t DP_msg_layer_visibility_id(const DP_MsgLayerVisibility *mlv);

bool DP_msg_layer_visibility_visible(const DP_MsgLayerVisibility *mlv);


/*
 * DP_MSG_PUT_IMAGE
 *
 * Draw a bitmap onto a layer
 *
 * This is used for pasting images, floodfill, merging annotations and
 * other tasks where image processing is done clientisde.
 *
 * All layer blending modes are supported.
 *
 * The image data is DEFLATEd 32bit premultiplied ARGB data. The image
 * is prefixed with a 32 bit unsigned integer (big endian) which contains
 * the expected length of the uncompressed data.
 *
 * Note that since the message length is fairly limited, a
 * large image may have to be divided into multiple PutImage
 * commands.
 */

typedef struct DP_MsgPutImage DP_MsgPutImage;

DP_Message *
DP_msg_put_image_new(unsigned int context_id, uint16_t layer, uint8_t mode,
                     uint32_t x, uint32_t y, uint32_t w, uint32_t h,
                     void (*set_image)(size_t, unsigned char *, void *),
                     size_t image_size, void *image_user);

DP_Message *DP_msg_put_image_deserialize(unsigned int context_id,
                                         const unsigned char *buffer,
                                         size_t length);

DP_Message *DP_msg_put_image_parse(unsigned int context_id,
                                   DP_TextReader *reader);

DP_MsgPutImage *DP_msg_put_image_cast(DP_Message *msg);

uint16_t DP_msg_put_image_layer(const DP_MsgPutImage *mpi);

uint8_t DP_msg_put_image_mode(const DP_MsgPutImage *mpi);

uint32_t DP_msg_put_image_x(const DP_MsgPutImage *mpi);

uint32_t DP_msg_put_image_y(const DP_MsgPutImage *mpi);

uint32_t DP_msg_put_image_w(const DP_MsgPutImage *mpi);

uint32_t DP_msg_put_image_h(const DP_MsgPutImage *mpi);

const unsigned char *DP_msg_put_image_image(const DP_MsgPutImage *mpi,
                                            size_t *out_size);

size_t DP_msg_put_image_image_size(const DP_MsgPutImage *mpi);


/*
 * DP_MSG_FILL_RECT
 *
 * Fill a rectangle with solid color
 */

typedef struct DP_MsgFillRect DP_MsgFillRect;

DP_Message *DP_msg_fill_rect_new(unsigned int context_id, uint16_t layer,
                                 uint8_t mode, uint32_t x, uint32_t y,
                                 uint32_t w, uint32_t h, uint32_t color);

DP_Message *DP_msg_fill_rect_deserialize(unsigned int context_id,
                                         const unsigned char *buffer,
                                         size_t length);

DP_Message *DP_msg_fill_rect_parse(unsigned int context_id,
                                   DP_TextReader *reader);

DP_MsgFillRect *DP_msg_fill_rect_cast(DP_Message *msg);

uint16_t DP_msg_fill_rect_layer(const DP_MsgFillRect *mfr);

uint8_t DP_msg_fill_rect_mode(const DP_MsgFillRect *mfr);

uint32_t DP_msg_fill_rect_x(const DP_MsgFillRect *mfr);

uint32_t DP_msg_fill_rect_y(const DP_MsgFillRect *mfr);

uint32_t DP_msg_fill_rect_w(const DP_MsgFillRect *mfr);

uint32_t DP_msg_fill_rect_h(const DP_MsgFillRect *mfr);

uint32_t DP_msg_fill_rect_color(const DP_MsgFillRect *mfr);


/*
 * DP_MSG_TOOL_CHANGE
 *
 * Removed in version 2.1
 */


/*
 * DP_MSG_PEN_MOVE
 *
 * Removed in version 2.1
 */


/*
 * DP_MSG_PEN_UP
 *
 * Pen up command
 *
 * The pen up command signals the end of a stroke. In indirect drawing mode, it
 * causes indirect dabs (by this user) to be merged to their parent layers.
 */

DP_Message *DP_msg_pen_up_new(unsigned int context_id);

DP_Message *DP_msg_pen_up_deserialize(unsigned int context_id,
                                      const unsigned char *buffer,
                                      size_t length);

DP_Message *DP_msg_pen_up_parse(unsigned int context_id, DP_TextReader *reader);


/*
 * DP_MSG_ANNOTATION_CREATE
 *
 * Create a new annotation
 *
 * Annotations are floating text layers. They are drawn over the image layers
 * and have no defined stacking order.
 *
 * The new annotation created with this command is initally empy with a
 * transparent background
 */

typedef struct DP_MsgAnnotationCreate DP_MsgAnnotationCreate;

DP_Message *DP_msg_annotation_create_new(unsigned int context_id, uint16_t id,
                                         int32_t x, int32_t y, uint16_t w,
                                         uint16_t h);

DP_Message *DP_msg_annotation_create_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_annotation_create_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgAnnotationCreate *DP_msg_annotation_create_cast(DP_Message *msg);

uint16_t DP_msg_annotation_create_id(const DP_MsgAnnotationCreate *mac);

int32_t DP_msg_annotation_create_x(const DP_MsgAnnotationCreate *mac);

int32_t DP_msg_annotation_create_y(const DP_MsgAnnotationCreate *mac);

uint16_t DP_msg_annotation_create_w(const DP_MsgAnnotationCreate *mac);

uint16_t DP_msg_annotation_create_h(const DP_MsgAnnotationCreate *mac);


/*
 * DP_MSG_ANNOTATION_RESHAPE
 *
 * Change the position and size of an annotation
 */

typedef struct DP_MsgAnnotationReshape DP_MsgAnnotationReshape;

DP_Message *DP_msg_annotation_reshape_new(unsigned int context_id, uint16_t id,
                                          int32_t x, int32_t y, uint16_t w,
                                          uint16_t h);

DP_Message *DP_msg_annotation_reshape_deserialize(unsigned int context_id,
                                                  const unsigned char *buffer,
                                                  size_t length);

DP_Message *DP_msg_annotation_reshape_parse(unsigned int context_id,
                                            DP_TextReader *reader);

DP_MsgAnnotationReshape *DP_msg_annotation_reshape_cast(DP_Message *msg);

uint16_t DP_msg_annotation_reshape_id(const DP_MsgAnnotationReshape *mar);

int32_t DP_msg_annotation_reshape_x(const DP_MsgAnnotationReshape *mar);

int32_t DP_msg_annotation_reshape_y(const DP_MsgAnnotationReshape *mar);

uint16_t DP_msg_annotation_reshape_w(const DP_MsgAnnotationReshape *mar);

uint16_t DP_msg_annotation_reshape_h(const DP_MsgAnnotationReshape *mar);


/*
 * DP_MSG_ANNOTATION_EDIT
 *
 * Change annotation content
 *
 * Accepted contents is the subset of HTML understood by QTextDocument
 *
 * If an annotation is flagged as protected, it cannot be modified by users
 * other than the one who created it, or session operators.
 */

#define DP_MSG_ANNOTATION_EDIT_FLAGS_PROTECT       0x1
#define DP_MSG_ANNOTATION_EDIT_FLAGS_VALIGN_CENTER 0x2
#define DP_MSG_ANNOTATION_EDIT_FLAGS_VALIGN_BOTTOM 0x4

const char *DP_msg_annotation_edit_flags_flag_name(unsigned int value);

typedef struct DP_MsgAnnotationEdit DP_MsgAnnotationEdit;

DP_Message *DP_msg_annotation_edit_new(unsigned int context_id, uint16_t id,
                                       uint32_t bg, uint8_t flags,
                                       uint8_t border, const char *text_value,
                                       size_t text_len);

DP_Message *DP_msg_annotation_edit_deserialize(unsigned int context_id,
                                               const unsigned char *buffer,
                                               size_t length);

DP_Message *DP_msg_annotation_edit_parse(unsigned int context_id,
                                         DP_TextReader *reader);

DP_MsgAnnotationEdit *DP_msg_annotation_edit_cast(DP_Message *msg);

uint16_t DP_msg_annotation_edit_id(const DP_MsgAnnotationEdit *mae);

uint32_t DP_msg_annotation_edit_bg(const DP_MsgAnnotationEdit *mae);

uint8_t DP_msg_annotation_edit_flags(const DP_MsgAnnotationEdit *mae);

uint8_t DP_msg_annotation_edit_border(const DP_MsgAnnotationEdit *mae);

const char *DP_msg_annotation_edit_text(const DP_MsgAnnotationEdit *mae,
                                        size_t *out_len);

size_t DP_msg_annotation_edit_text_len(const DP_MsgAnnotationEdit *mae);


/*
 * DP_MSG_ANNOTATION_DELETE
 *
 * Delete an annotation
 *
 * Note: Unlike in layer delete command, there is no "merge" option here.
 * Merging an annotation is done by rendering the annotation item to
 * an image and drawing the image with the PutImage command. This ensures
 * identical rendering on all clients.
 */

typedef struct DP_MsgAnnotationDelete DP_MsgAnnotationDelete;

DP_Message *DP_msg_annotation_delete_new(unsigned int context_id, uint16_t id);

DP_Message *DP_msg_annotation_delete_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_annotation_delete_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgAnnotationDelete *DP_msg_annotation_delete_cast(DP_Message *msg);

uint16_t DP_msg_annotation_delete_id(const DP_MsgAnnotationDelete *mad);


/*
 * DP_MSG_MOVE_REGION
 *
 * Move (and transform) a region of a layer.
 *
 * This is used to implement selection moving. It is equivalent
 * to doing two PutImages: the first to mask away the original
 * selection and the other to paste the selection to a new location.
 *
 * This command packages that into a single action that is more
 * bandwidth efficient and can be used even when PutImages in general
 * are locked, since it's not introducing any new pixels onto the canvas.
 *
 * Internally, the paint engine performs the following steps:
 * 1. Copy selected pixels to a buffer
 * 2. Erase selected pixels from the layer
 * 3. Composite transformed buffer onto the layer
 *
 * The pixel selection is determined by the mask bitmap. The mask
 * is DEFLATEd 1 bit per pixel bitmap data.
 * For axis aligned rectangle selections, no bitmap is necessary.
 */

typedef struct DP_MsgMoveRegion DP_MsgMoveRegion;

DP_Message *
DP_msg_move_region_new(unsigned int context_id, uint16_t layer, int32_t bx,
                       int32_t by, int32_t bw, int32_t bh, int32_t x1,
                       int32_t y1, int32_t x2, int32_t y2, int32_t x3,
                       int32_t y3, int32_t x4, int32_t y4,
                       void (*set_mask)(size_t, unsigned char *, void *),
                       size_t mask_size, void *mask_user);

DP_Message *DP_msg_move_region_deserialize(unsigned int context_id,
                                           const unsigned char *buffer,
                                           size_t length);

DP_Message *DP_msg_move_region_parse(unsigned int context_id,
                                     DP_TextReader *reader);

DP_MsgMoveRegion *DP_msg_move_region_cast(DP_Message *msg);

uint16_t DP_msg_move_region_layer(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_bx(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_by(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_bw(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_bh(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_x1(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_y1(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_x2(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_y2(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_x3(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_y3(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_x4(const DP_MsgMoveRegion *mmr);

int32_t DP_msg_move_region_y4(const DP_MsgMoveRegion *mmr);

const unsigned char *DP_msg_move_region_mask(const DP_MsgMoveRegion *mmr,
                                             size_t *out_size);

size_t DP_msg_move_region_mask_size(const DP_MsgMoveRegion *mmr);


/*
 * DP_MSG_PUT_TILE
 *
 * Set the content of a tile
 *
 * Unlike PutImage, this replaces an entire tile directly without any blending.
 * This command is typically used during canvas initialization to set the
 * initial content.
 *
 * PutTile can target sublayers as well. This is used when generating a reset
 * image with incomplete indirect strokes. Sending a PenUp command will merge
 * the sublayer.
 */

typedef struct DP_MsgPutTile DP_MsgPutTile;

DP_Message *DP_msg_put_tile_new(unsigned int context_id, uint16_t layer,
                                uint8_t sublayer, uint8_t last_touch,
                                uint16_t col, uint16_t row, uint16_t repeat,
                                void (*set_image)(size_t, unsigned char *,
                                                  void *),
                                size_t image_size, void *image_user);

DP_Message *DP_msg_put_tile_deserialize(unsigned int context_id,
                                        const unsigned char *buffer,
                                        size_t length);

DP_Message *DP_msg_put_tile_parse(unsigned int context_id,
                                  DP_TextReader *reader);

DP_MsgPutTile *DP_msg_put_tile_cast(DP_Message *msg);

uint16_t DP_msg_put_tile_layer(const DP_MsgPutTile *mpt);

uint8_t DP_msg_put_tile_sublayer(const DP_MsgPutTile *mpt);

uint8_t DP_msg_put_tile_last_touch(const DP_MsgPutTile *mpt);

uint16_t DP_msg_put_tile_col(const DP_MsgPutTile *mpt);

uint16_t DP_msg_put_tile_row(const DP_MsgPutTile *mpt);

uint16_t DP_msg_put_tile_repeat(const DP_MsgPutTile *mpt);

const unsigned char *DP_msg_put_tile_image(const DP_MsgPutTile *mpt,
                                           size_t *out_size);

size_t DP_msg_put_tile_image_size(const DP_MsgPutTile *mpt);


/*
 * DP_MSG_CANVAS_BACKGROUND
 *
 * Set the canvas background tile
 *
 * If the payload is exactly 4 bytes long, it should be interpreted as a solid
 * background color. Otherwise, it is the DEFLATED tile bitmap
 */

typedef struct DP_MsgCanvasBackground DP_MsgCanvasBackground;

DP_Message *
DP_msg_canvas_background_new(unsigned int context_id,
                             void (*set_image)(size_t, unsigned char *, void *),
                             size_t image_size, void *image_user);

DP_Message *DP_msg_canvas_background_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_canvas_background_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgCanvasBackground *DP_msg_canvas_background_cast(DP_Message *msg);

const unsigned char *
DP_msg_canvas_background_image(const DP_MsgCanvasBackground *mcb,
                               size_t *out_size);

size_t DP_msg_canvas_background_image_size(const DP_MsgCanvasBackground *mcb);


/*
 * DP_MSG_DRAW_DABS_CLASSIC
 *
 * Draw classic brush dabs
 *
 * A simple delta compression scheme is used.
 * The coordinates of each dab are relative to the previous dab.
 * The coordinate system has 1/4 pixel resolution. Divide by 4.0 before use.
 * The size field is the brush diameter multiplied by 256.
 */

#define DP_MSG_DRAW_DABS_CLASSIC_DABS_MAX 10920

typedef struct DP_ClassicDab DP_ClassicDab;

void DP_classic_dab_init(DP_ClassicDab *cds, int i, int8_t x, int8_t y,
                         uint16_t size, uint8_t hardness, uint8_t opacity);

int8_t DP_classic_dab_x(const DP_ClassicDab *cd);

int8_t DP_classic_dab_y(const DP_ClassicDab *cd);

uint16_t DP_classic_dab_size(const DP_ClassicDab *cd);

uint8_t DP_classic_dab_hardness(const DP_ClassicDab *cd);

uint8_t DP_classic_dab_opacity(const DP_ClassicDab *cd);

const DP_ClassicDab *DP_classic_dab_at(const DP_ClassicDab *cd, int i);


typedef struct DP_MsgDrawDabsClassic DP_MsgDrawDabsClassic;

DP_Message *
DP_msg_draw_dabs_classic_new(unsigned int context_id, uint16_t layer, int32_t x,
                             int32_t y, uint32_t color, uint8_t mode,
                             void (*set_dabs)(int, DP_ClassicDab *, void *),
                             int dabs_count, void *dabs_user);

DP_Message *DP_msg_draw_dabs_classic_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_draw_dabs_classic_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgDrawDabsClassic *DP_msg_draw_dabs_classic_cast(DP_Message *msg);

uint16_t DP_msg_draw_dabs_classic_layer(const DP_MsgDrawDabsClassic *mddc);

int32_t DP_msg_draw_dabs_classic_x(const DP_MsgDrawDabsClassic *mddc);

int32_t DP_msg_draw_dabs_classic_y(const DP_MsgDrawDabsClassic *mddc);

uint32_t DP_msg_draw_dabs_classic_color(const DP_MsgDrawDabsClassic *mddc);

uint8_t DP_msg_draw_dabs_classic_mode(const DP_MsgDrawDabsClassic *mddc);

const DP_ClassicDab *
DP_msg_draw_dabs_classic_dabs(const DP_MsgDrawDabsClassic *mddc,
                              int *out_count);

int DP_msg_draw_dabs_classic_dabs_count(const DP_MsgDrawDabsClassic *mddc);


/*
 * DP_MSG_DRAW_DABS_PIXEL
 *
 * Draw round pixel brush dabs
 *
 * The same kind of delta compression is used as in classicdabs,
 * but the fields all have integer precision.
 */

#define DP_MSG_DRAW_DABS_PIXEL_DABS_MAX 16380

typedef struct DP_PixelDab DP_PixelDab;

void DP_pixel_dab_init(DP_PixelDab *pds, int i, int8_t x, int8_t y,
                       uint8_t size, uint8_t opacity);

int8_t DP_pixel_dab_x(const DP_PixelDab *pd);

int8_t DP_pixel_dab_y(const DP_PixelDab *pd);

uint8_t DP_pixel_dab_size(const DP_PixelDab *pd);

uint8_t DP_pixel_dab_opacity(const DP_PixelDab *pd);

const DP_PixelDab *DP_pixel_dab_at(const DP_PixelDab *pd, int i);


typedef struct DP_MsgDrawDabsPixel DP_MsgDrawDabsPixel;

DP_Message *
DP_msg_draw_dabs_pixel_new(unsigned int context_id, uint16_t layer, int32_t x,
                           int32_t y, uint32_t color, uint8_t mode,
                           void (*set_dabs)(int, DP_PixelDab *, void *),
                           int dabs_count, void *dabs_user);

DP_Message *DP_msg_draw_dabs_pixel_deserialize(unsigned int context_id,
                                               const unsigned char *buffer,
                                               size_t length);

DP_Message *DP_msg_draw_dabs_pixel_parse(unsigned int context_id,
                                         DP_TextReader *reader);

DP_MsgDrawDabsPixel *DP_msg_draw_dabs_pixel_cast(DP_Message *msg);

uint16_t DP_msg_draw_dabs_pixel_layer(const DP_MsgDrawDabsPixel *mddp);

int32_t DP_msg_draw_dabs_pixel_x(const DP_MsgDrawDabsPixel *mddp);

int32_t DP_msg_draw_dabs_pixel_y(const DP_MsgDrawDabsPixel *mddp);

uint32_t DP_msg_draw_dabs_pixel_color(const DP_MsgDrawDabsPixel *mddp);

uint8_t DP_msg_draw_dabs_pixel_mode(const DP_MsgDrawDabsPixel *mddp);

const DP_PixelDab *DP_msg_draw_dabs_pixel_dabs(const DP_MsgDrawDabsPixel *mddp,
                                               int *out_count);

int DP_msg_draw_dabs_pixel_dabs_count(const DP_MsgDrawDabsPixel *mddp);


/*
 * DP_MSG_DRAW_DABS_PIXEL_SQUARE
 *
 * Draw square pixel brush dabs
 */

DP_Message *DP_msg_draw_dabs_pixel_square_new(
    unsigned int context_id, uint16_t layer, int32_t x, int32_t y,
    uint32_t color, uint8_t mode, void (*set_dabs)(int, DP_PixelDab *, void *),
    int dabs_count, void *dabs_user);

DP_Message *DP_msg_draw_dabs_pixel_square_deserialize(
    unsigned int context_id, const unsigned char *buffer, size_t length);

DP_Message *DP_msg_draw_dabs_pixel_square_parse(unsigned int context_id,
                                                DP_TextReader *reader);

DP_MsgDrawDabsPixel *DP_msg_draw_dabs_pixel_square_cast(DP_Message *msg);


/*
 * DP_MSG_DRAW_DABS_MYPAINT
 *
 * Draw MyPaint brush dabs
 */

#define DP_MSG_DRAW_DABS_MYPAINT_DABS_MAX 8190

typedef struct DP_MyPaintDab DP_MyPaintDab;

void DP_mypaint_dab_init(DP_MyPaintDab *mpds, int i, int8_t x, int8_t y,
                         uint16_t size, uint8_t hardness, uint8_t opacity,
                         uint8_t angle, uint8_t aspect_ratio);

int8_t DP_mypaint_dab_x(const DP_MyPaintDab *mpd);

int8_t DP_mypaint_dab_y(const DP_MyPaintDab *mpd);

uint16_t DP_mypaint_dab_size(const DP_MyPaintDab *mpd);

uint8_t DP_mypaint_dab_hardness(const DP_MyPaintDab *mpd);

uint8_t DP_mypaint_dab_opacity(const DP_MyPaintDab *mpd);

uint8_t DP_mypaint_dab_angle(const DP_MyPaintDab *mpd);

uint8_t DP_mypaint_dab_aspect_ratio(const DP_MyPaintDab *mpd);

const DP_MyPaintDab *DP_mypaint_dab_at(const DP_MyPaintDab *mpd, int i);


typedef struct DP_MsgDrawDabsMyPaint DP_MsgDrawDabsMyPaint;

DP_Message *
DP_msg_draw_dabs_mypaint_new(unsigned int context_id, uint16_t layer, int32_t x,
                             int32_t y, uint32_t color, uint8_t lock_alpha,
                             void (*set_dabs)(int, DP_MyPaintDab *, void *),
                             int dabs_count, void *dabs_user);

DP_Message *DP_msg_draw_dabs_mypaint_deserialize(unsigned int context_id,
                                                 const unsigned char *buffer,
                                                 size_t length);

DP_Message *DP_msg_draw_dabs_mypaint_parse(unsigned int context_id,
                                           DP_TextReader *reader);

DP_MsgDrawDabsMyPaint *DP_msg_draw_dabs_mypaint_cast(DP_Message *msg);

uint16_t DP_msg_draw_dabs_mypaint_layer(const DP_MsgDrawDabsMyPaint *mddmp);

int32_t DP_msg_draw_dabs_mypaint_x(const DP_MsgDrawDabsMyPaint *mddmp);

int32_t DP_msg_draw_dabs_mypaint_y(const DP_MsgDrawDabsMyPaint *mddmp);

uint32_t DP_msg_draw_dabs_mypaint_color(const DP_MsgDrawDabsMyPaint *mddmp);

uint8_t DP_msg_draw_dabs_mypaint_lock_alpha(const DP_MsgDrawDabsMyPaint *mddmp);

const DP_MyPaintDab *
DP_msg_draw_dabs_mypaint_dabs(const DP_MsgDrawDabsMyPaint *mddmp,
                              int *out_count);

int DP_msg_draw_dabs_mypaint_dabs_count(const DP_MsgDrawDabsMyPaint *mddmp);


/*
 * DP_MSG_MOVE_RECT
 *
 * Move a rectangular area on a layer.
 *
 * A mask image can be given to mask out part of the region
 * to support non-rectangular selections.
 *
 * Source and target rects may be (partially) outside the canvas.
 *
 * Note: The MoveRegion command that can also transform the
 * selection is currently not implemented. The same effect can be
 * achieved by performing the transformation clientside then
 * sending the results as PutImages, including one to erase the
 * source.
 */

typedef struct DP_MsgMoveRect DP_MsgMoveRect;

DP_Message *
DP_msg_move_rect_new(unsigned int context_id, uint16_t layer, int32_t sx,
                     int32_t sy, int32_t tx, int32_t ty, int32_t w, int32_t h,
                     void (*set_mask)(size_t, unsigned char *, void *),
                     size_t mask_size, void *mask_user);

DP_Message *DP_msg_move_rect_deserialize(unsigned int context_id,
                                         const unsigned char *buffer,
                                         size_t length);

DP_Message *DP_msg_move_rect_parse(unsigned int context_id,
                                   DP_TextReader *reader);

DP_MsgMoveRect *DP_msg_move_rect_cast(DP_Message *msg);

uint16_t DP_msg_move_rect_layer(const DP_MsgMoveRect *mmr);

int32_t DP_msg_move_rect_sx(const DP_MsgMoveRect *mmr);

int32_t DP_msg_move_rect_sy(const DP_MsgMoveRect *mmr);

int32_t DP_msg_move_rect_tx(const DP_MsgMoveRect *mmr);

int32_t DP_msg_move_rect_ty(const DP_MsgMoveRect *mmr);

int32_t DP_msg_move_rect_w(const DP_MsgMoveRect *mmr);

int32_t DP_msg_move_rect_h(const DP_MsgMoveRect *mmr);

const unsigned char *DP_msg_move_rect_mask(const DP_MsgMoveRect *mmr,
                                           size_t *out_size);

size_t DP_msg_move_rect_mask_size(const DP_MsgMoveRect *mmr);


/*
 * DP_MSG_SET_METADATA_INT
 *
 * Set a document metadata field (integer type)
 *
 * These typically don't have an immediate visual effect,
 * but these fields are part of the document, like the pixel content
 * or the annotations.
 */

#define DP_MSG_SET_METADATA_INT_FIELD_DPIX         0
#define DP_MSG_SET_METADATA_INT_FIELD_DPIY         1
#define DP_MSG_SET_METADATA_INT_FIELD_FRAMERATE    2
#define DP_MSG_SET_METADATA_INT_FIELD_USE_TIMELINE 3

const char *DP_msg_set_metadata_int_field_variant_name(unsigned int value);

typedef struct DP_MsgSetMetadataInt DP_MsgSetMetadataInt;

DP_Message *DP_msg_set_metadata_int_new(unsigned int context_id, uint8_t field,
                                        int32_t value);

DP_Message *DP_msg_set_metadata_int_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length);

DP_Message *DP_msg_set_metadata_int_parse(unsigned int context_id,
                                          DP_TextReader *reader);

DP_MsgSetMetadataInt *DP_msg_set_metadata_int_cast(DP_Message *msg);

uint8_t DP_msg_set_metadata_int_field(const DP_MsgSetMetadataInt *msmi);

int32_t DP_msg_set_metadata_int_value(const DP_MsgSetMetadataInt *msmi);


/*
 * DP_MSG_SET_METADATA_STR
 *
 * Set a document metadata field (string type)
 */

typedef struct DP_MsgSetMetadataStr DP_MsgSetMetadataStr;

DP_Message *DP_msg_set_metadata_str_new(unsigned int context_id, uint8_t field,
                                        const char *value_value,
                                        size_t value_len);

DP_Message *DP_msg_set_metadata_str_deserialize(unsigned int context_id,
                                                const unsigned char *buffer,
                                                size_t length);

DP_Message *DP_msg_set_metadata_str_parse(unsigned int context_id,
                                          DP_TextReader *reader);

DP_MsgSetMetadataStr *DP_msg_set_metadata_str_cast(DP_Message *msg);

uint8_t DP_msg_set_metadata_str_field(const DP_MsgSetMetadataStr *msms);

const char *DP_msg_set_metadata_str_value(const DP_MsgSetMetadataStr *msms,
                                          size_t *out_len);

size_t DP_msg_set_metadata_str_value_len(const DP_MsgSetMetadataStr *msms);


/*
 * DP_MSG_SET_TIMELINE_FRAME
 *
 * Set the layers included in the given animation frame
 *
 * The frame number must be between zero and last frame number + 1.
 *
 * If the `insert` flag is true, the frame will be inserted at the given
 * position rather than replacing the existing frame.
 */

typedef struct DP_MsgSetTimelineFrame DP_MsgSetTimelineFrame;

DP_Message *DP_msg_set_timeline_frame_new(unsigned int context_id,
                                          uint16_t frame, bool insert,
                                          void (*set_layers)(int, uint16_t *,
                                                             void *),
                                          int layers_count, void *layers_user);

DP_Message *DP_msg_set_timeline_frame_deserialize(unsigned int context_id,
                                                  const unsigned char *buffer,
                                                  size_t length);

DP_Message *DP_msg_set_timeline_frame_parse(unsigned int context_id,
                                            DP_TextReader *reader);

DP_MsgSetTimelineFrame *DP_msg_set_timeline_frame_cast(DP_Message *msg);

uint16_t DP_msg_set_timeline_frame_frame(const DP_MsgSetTimelineFrame *mstf);

bool DP_msg_set_timeline_frame_insert(const DP_MsgSetTimelineFrame *mstf);

const uint16_t *
DP_msg_set_timeline_frame_layers(const DP_MsgSetTimelineFrame *mstf,
                                 int *out_count);

int DP_msg_set_timeline_frame_layers_count(const DP_MsgSetTimelineFrame *mstf);


/*
 * DP_MSG_REMOVE_TIMELINE_FRAME
 *
 * Remove a frame from the timeline
 */

typedef struct DP_MsgRemoveTimelineFrame DP_MsgRemoveTimelineFrame;

DP_Message *DP_msg_remove_timeline_frame_new(unsigned int context_id,
                                             uint16_t frame);

DP_Message *DP_msg_remove_timeline_frame_deserialize(
    unsigned int context_id, const unsigned char *buffer, size_t length);

DP_Message *DP_msg_remove_timeline_frame_parse(unsigned int context_id,
                                               DP_TextReader *reader);

DP_MsgRemoveTimelineFrame *DP_msg_remove_timeline_frame_cast(DP_Message *msg);

uint16_t
DP_msg_remove_timeline_frame_frame(const DP_MsgRemoveTimelineFrame *mrtf);


/*
 * DP_MSG_UNDO
 *
 * Undo or redo actions
 */

typedef struct DP_MsgUndo DP_MsgUndo;

DP_Message *DP_msg_undo_new(unsigned int context_id, uint8_t override_user,
                            bool redo);

DP_Message *DP_msg_undo_deserialize(unsigned int context_id,
                                    const unsigned char *buffer, size_t length);

DP_Message *DP_msg_undo_parse(unsigned int context_id, DP_TextReader *reader);

DP_MsgUndo *DP_msg_undo_cast(DP_Message *msg);

uint8_t DP_msg_undo_override_user(const DP_MsgUndo *mu);

bool DP_msg_undo_redo(const DP_MsgUndo *mu);


#endif
